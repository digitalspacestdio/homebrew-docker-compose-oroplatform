#!/usr/bin/env bash
if [[ -n $DEBUG ]]; then
  set -x
fi
# Global variable to store already selected ports
__FOUND_PORTS=""

# Cache for Docker container information to avoid repeated calls
__DOCKER_CONTAINERS_CACHE=""
__DOCKER_INSPECT_CACHE=""
__DOCKER_CACHE_LOADED=false

# Function to get all Docker containers info once
load_docker_containers_cache() {
  if [[ "$__DOCKER_CACHE_LOADED" == "false" ]]; then
    __DOCKER_CONTAINERS_CACHE=$(docker ps -a --format '{{.Names}} {{.Ports}}' | grep -v '^k8s_')
    
    # Get all container names and create inspect cache
    local container_names
    container_names=$(echo "$__DOCKER_CONTAINERS_CACHE" | awk '{print $1}' | tr '\n' ' ')
    
    if [[ -n "$container_names" ]]; then
      # Single docker inspect call for all containers
      __DOCKER_INSPECT_CACHE=$(docker inspect --format '{{.Name}}|{{ index .Config.Labels "com.docker.compose.project" }}|{{ index .Config.Labels "com.docker.compose.service" }}' $container_names 2>/dev/null)
    fi
    
    __DOCKER_CACHE_LOADED=true
  fi
}

# Function to get container labels from cache
get_container_labels() {
  local container_name="$1"
  local project_var="$2"
  local service_var="$3"
  
  # Look for container in inspect cache
  while IFS='|' read -r name project service; do
    # Remove leading slash from docker inspect name
    name="${name#/}"
    if [[ "$name" == "$container_name" ]]; then
      eval "$project_var=\"$project\""
      eval "$service_var=\"$service\""
      return 0
    fi
  done <<< "$__DOCKER_INSPECT_CACHE"
  
  # Not found, set empty values
  eval "$project_var=\"\""
  eval "$service_var=\"\""
  return 1
}

# Function to get information about which container/project is using a port
get_port_usage_info() {
  local port="$1"
  local current_project="$2"
  
  # Load cache if not loaded yet
  load_docker_containers_cache
  
  # Check Docker containers
  while read -r name ports; do
    [[ -z "$name" ]] && continue
    
    local container_project
    local container_service
    get_container_labels "$name" container_project container_service
    
    # Skip containers from the same project
    if [[ "$container_project" == "$current_project" ]]; then
      continue
    fi
    
    # Check if this container uses the port
    for part in ${ports//,/ }; do
      part="${part%/tcp}"
      part="${part%/udp}"
      
      local host_port=""
      if [[ "$part" == *"->"* ]]; then
        local host_port_part="${part%%->*}"
        if [[ "$host_port_part" == *":"* ]]; then
          host_port="${host_port_part##*:}"
        else
          host_port="$host_port_part"
        fi
      else
        host_port="$part"
      fi
      
      # Check for exact port match or port range
      if [[ "$host_port" == *"-"* ]]; then
        local range_start=${host_port%-*}
        local range_end=${host_port#*-}
        if [[ "$port" -ge "$range_start" && "$port" -le "$range_end" ]]; then
          if [[ -n "$container_project" ]]; then
            echo "project '$container_project' (container: $name)"
          else
            echo "container '$name'"
          fi
          return 0
        fi
      elif [[ "$host_port" == "$port" ]]; then
        if [[ -n "$container_project" ]]; then
          echo "project '$container_project' (container: $name)"
        else
          echo "container '$name'"
        fi
        return 0
      fi
    done
  done <<< "$__DOCKER_CONTAINERS_CACHE"
  
  # Check local processes (only LISTEN state)
  if lsof -t -i tcp:$port -sTCP:LISTEN > /dev/null 2>&1; then
    local process_info
    process_info=$(lsof -i tcp:$port -P -n -sTCP:LISTEN | tail -n +2 | head -1 | awk '{print $1 " (PID: " $2 ")"}')
    if [[ -n "$process_info" ]]; then
      echo "local process: $process_info"
    else
      echo "local process"
    fi
    return 0
  fi
  
  echo "unknown process"
  return 1
}

# Batch function to find free ports for multiple services
find_free_ports_batch() {
  local PROJECT_NAME="$1"
  local COMPOSE_CONFIG_DIR="$2"
  shift 2
  
  # Load Docker containers info once
  load_docker_containers_cache
  
  local COMPOSE_FILE="${COMPOSE_CONFIG_DIR}/compose.yml"
  local USED_PORTS=""
  
  # Get all used ports from compose.yml once
  if [[ -f "$COMPOSE_FILE" ]]; then
    USED_PORTS=$(yq '.services[].ports[]? | select(.published) | .published' "$COMPOSE_FILE" 2>/dev/null | xargs)
  fi
  
  # Process each service
  while [[ $# -gt 0 ]]; do
    local SERVICE_NAME="$1"
    local DEFAULT_PORT="$2"
    shift 2
    
    local SELECTED_PORT=""
    if [[ -f "$COMPOSE_FILE" ]]; then
      SELECTED_PORT=$(yq '.services["'"$SERVICE_NAME"'"].ports[]? | select(.published) | .published' "$COMPOSE_FILE" 2>/dev/null)
    fi
    
    # Find free port for this service
    # CRITICAL: Always start from DEFAULT_PORT (with prefix), not from SELECTED_PORT
    # SELECTED_PORT from compose.yml is only used to check if it matches our default
    local port_found=""
    
    # First, check if SELECTED_PORT matches DEFAULT_PORT and is available
    if [[ -n "$SELECTED_PORT" ]] && [[ "$SELECTED_PORT" == "$DEFAULT_PORT" ]]; then
      if ! is_port_used_batch "$SELECTED_PORT" "$PROJECT_NAME" "$SERVICE_NAME" "$USED_PORTS"; then
        # Port matches default and is free - use it
        port_found="$SELECTED_PORT"
      else
        # Port matches default but is occupied - find alternative starting from default
        local usage_info
        usage_info=$(get_port_usage_info "$SELECTED_PORT" "$PROJECT_NAME")
        if [[ -n "${DEBUG:-}" ]] || [[ -n "${VERBOSE:-}" ]]; then
          echo -e "\033[33m==> Warning: compose.yml port=${SELECTED_PORT} (default=${DEFAULT_PORT}) is occupied by ${usage_info}. Searching for alternative starting from default.\033[0m" >&2
        fi
      fi
    elif [[ -n "$SELECTED_PORT" ]] && [[ "$SELECTED_PORT" != "$DEFAULT_PORT" ]]; then
      # SELECTED_PORT exists but doesn't match default - check if it's used by our project
      # If port is used by our project container, use it (even if it doesn't match default)
      if ! is_port_used_batch "$SELECTED_PORT" "$PROJECT_NAME" "$SERVICE_NAME" "$USED_PORTS"; then
        # Port is free - use it even though it doesn't match default
        port_found="$SELECTED_PORT"
      else
        # Port is occupied - check if it's used by our project
        local usage_info
        usage_info=$(get_port_usage_info "$SELECTED_PORT" "$PROJECT_NAME")
        if [[ "$usage_info" == *"$PROJECT_NAME"* ]]; then
          # Port is used by our project - use it
          port_found="$SELECTED_PORT"
        else
          # Port is occupied by another project - warn and use default instead
          if [[ -n "${DEBUG:-}" ]] || [[ -n "${VERBOSE:-}" ]]; then
            echo -e "\033[33m==> Warning: compose.yml port=${SELECTED_PORT} (source=compose.yml, default=${DEFAULT_PORT}) is occupied by ${usage_info}. Searching for alternative.\033[0m" >&2
          fi
        fi
      fi
    fi
    
    if [[ -z "$port_found" ]]; then
      # Find a free port starting from DEFAULT_PORT (always use default, not selected)
      local PORT="$DEFAULT_PORT"
      while [[ "$PORT" -le 65535 ]]; do
        if ! is_port_used_batch "$PORT" "$PROJECT_NAME" "$SERVICE_NAME" "$USED_PORTS"; then
          port_found="$PORT"
          break
        fi
        PORT=$((PORT+1))
      done
    fi
    
    if [[ -n "$port_found" ]]; then
      # For database services, don't add to __FOUND_PORTS to allow port reuse between mysql/pgsql
      if [[ "$SERVICE_NAME" != "database" ]]; then
        __FOUND_PORTS+=" $port_found"
      fi
      echo "${SERVICE_NAME}:${port_found}"
    else
      echo -e "\033[38;5;208m==> Error: could not find a free port for $SERVICE_NAME\033[0m" >&2
      return 1
    fi
  done
}

# Optimized port check using cached Docker info
is_port_used_batch() {
  local p=$1
  local PROJECT_NAME=$2
  local SERVICE_NAME=$3
  local USED_PORTS=$4
  
  # Check if already found in this session, but allow same port for different database types
  if [[ " $__FOUND_PORTS " == *" $p "* ]]; then
    # Allow reuse of the same port for different database services (mysql/pgsql)
    if [[ "$SERVICE_NAME" == "database" ]]; then
      # For database services, allow port reuse since only one DB type will be active
      return 1
    else
      # For other services, port reuse is not allowed
      return 0
    fi
  fi
  
  # Don't check USED_PORTS here - those are from our own compose.yml and should be reusable
  
  # First check Docker containers using cached data to see if it's used by our project
  local found=1
  local used_by_our_project=false
  while read -r name ports; do
    [[ -z "$name" ]] && continue
    
    local container_project
    local container_service
    get_container_labels "$name" container_project container_service
    
    # Check if this container belongs to our project
    if [[ "$container_project" == "$PROJECT_NAME" ]]; then
      # Check if this container uses the port we're checking
      for part in ${ports//,/ }; do
        part="${part// /}"
        if [[ "$part" == *"->"* ]]; then
          local host_port_part="${part%->*}"
          if [[ "$host_port_part" == *":"* ]]; then
            local host_port="${host_port_part##*:}"
          else
            local host_port="$host_port_part"
          fi
          if [[ "$host_port" != *"-"* ]] && [[ "$host_port" == "$p" ]]; then
            used_by_our_project=true
            break 2
          fi
        else
          if [[ "$part" != *"-"* ]] && [[ "$part" == "$p" ]]; then
            used_by_our_project=true
            break 2
          fi
        fi
      done
    fi
  done <<< "$__DOCKER_CONTAINERS_CACHE"
  
  # Check if port is listening on host (using multiple methods for reliability)
  # Docker bind will fail if port is already allocated, even by our own containers
  local port_in_use=false
  
  # Method 1: ss (most reliable for Docker ports, check first)
  if command -v ss >/dev/null 2>&1; then
    if ss -tln 2>/dev/null | grep -q ":${p} "; then
      port_in_use=true
    fi
  # Method 2: netstat (fallback if ss not available)
  elif command -v netstat >/dev/null 2>&1; then
    if netstat -tln 2>/dev/null | grep -q ":${p} "; then
      port_in_use=true
    fi
  fi
  
  # Method 3: lsof (additional check, but less reliable for Docker ports)
  if [[ "$port_in_use" == "false" ]] && command -v lsof >/dev/null 2>&1; then
    if lsof -t -i tcp:$p -sTCP:LISTEN > /dev/null 2>&1; then
      port_in_use=true
    fi
  fi
  
  # If port is used by our project, it's available for reuse
  if [[ "$used_by_our_project" == "true" ]]; then
    [[ "$DEBUG" == "1" ]] && echo "DEBUG: Port $p is used by our project, allowing reuse" >&2
    return 1
  fi
  
  if [[ "$port_in_use" == "true" ]]; then
    [[ "$DEBUG" == "1" ]] && echo "DEBUG: Port $p is listening on host (lsof/ss/netstat)" >&2
    return 0
  fi
  
  # If port is used by our project but not by local process, check if container is running
  # If container is stopped/exited, we can reuse the port
  if [[ "$used_by_our_project" == "true" ]]; then
    # Check if the container using this port is actually running
    local container_running=false
    while read -r name ports; do
      [[ -z "$name" ]] && continue
      
      local container_project
      local container_service
      get_container_labels "$name" container_project container_service
      
      if [[ "$container_project" == "$PROJECT_NAME" ]]; then
        # Check if this container uses the port and is running
        for part in ${ports//,/ }; do
          part="${part// /}"
          if [[ "$part" == *"->"* ]]; then
            local host_port_part="${part%->*}"
            if [[ "$host_port_part" == *":"* ]]; then
              local host_port="${host_port_part##*:}"
            else
              local host_port="$host_port_part"
            fi
            if [[ "$host_port" != *"-"* ]] && [[ "$host_port" == "$p" ]]; then
              # Check if container is running (not stopped/exited)
              if docker ps --format '{{.Names}}' | grep -q "^${name}$"; then
                container_running=true
                break 2
              fi
            fi
          fi
        done
      fi
    done <<< "$__DOCKER_CONTAINERS_CACHE"
    
    # If container is running, port is in use
    if [[ "$container_running" == "true" ]]; then
      [[ "$DEBUG" == "1" ]] && echo "DEBUG: Port $p is used by running container from our project ($PROJECT_NAME)" >&2
      return 0
    else
      # Container is stopped/exited, port can be reused
      [[ "$DEBUG" == "1" ]] && echo "DEBUG: Port $p was used by stopped container from our project ($PROJECT_NAME), allowing reuse" >&2
      return 1
    fi
  fi
  
  # Check Docker containers from other projects
  local found=1
  while read -r name ports; do
    [[ -z "$name" ]] && continue
    
    local container_project
    local container_service
    get_container_labels "$name" container_project container_service
    
    # Ignore all containers from the same project (not just same service)
    if [[ "$container_project" == "$PROJECT_NAME" ]]; then
      continue
    fi
    
    # Debug: show which project is using the port
    local port_conflict=false
    
    for part in ${ports//,/ }; do
      part="${part%/tcp}"
      part="${part%/udp}"
      
      if [[ "$part" == *"->"* ]]; then
        host_port_part="${part%%->*}"
        if [[ "$host_port_part" == *":"* ]]; then
          host_port="${host_port_part##*:}"
        else
          host_port="$host_port_part"
        fi
        
        if [[ "$host_port" == *"-"* ]]; then
          range_start=${host_port%-*}
          range_end=${host_port#*-}
          if [[ "$p" -ge "$range_start" && "$p" -le "$range_end" ]]; then
            [[ "$DEBUG" == "1" ]] && echo "DEBUG: Port $p is used by container $name from project '$container_project' (range $range_start-$range_end)" >&2
            return 0
          fi
        elif [[ "$host_port" == "$p" ]]; then
          [[ "$DEBUG" == "1" ]] && echo "DEBUG: Port $p is used by container $name from project '$container_project'" >&2
          return 0
        fi
      fi
    done
  done <<< "$__DOCKER_CONTAINERS_CACHE"
  
  # Port is free
  return 1
}

find_free_port() {
  local PROJECT_NAME="$1"
  local COMPOSE_CONFIG_DIR="$2"
  local SERVICE_NAME="$3"
  local PORT="$4"

  local COMPOSE_FILE="${COMPOSE_CONFIG_DIR}/compose.yml"
  local SELECTED_PORT=""
  local USED_PORTS=""

  # Get a list of all published ports from compose.yml (for all services)
  if [[ -f "$COMPOSE_FILE" ]]; then
    USED_PORTS=$(yq '.services[].ports[]? | select(.published) | .published' "$COMPOSE_FILE" 2>/dev/null | xargs)
    SELECTED_PORT=$(yq '.services["'"$SERVICE_NAME"'"].ports[]? | select(.published) | .published' "$COMPOSE_FILE" 2>/dev/null)
  fi

  # Check if the port is used by a local process (only LISTEN state)
  # Uses multiple methods for reliability (lsof, ss, netstat)
  is_port_used_by_local() {
    local p=$1
    
    # Method 1: lsof (works for most processes)
    if lsof -t -i tcp:$p -sTCP:LISTEN > /dev/null 2>&1; then
      return 0
    fi
    
    # Method 2: ss (more reliable for Docker ports)
    if command -v ss >/dev/null 2>&1; then
      if ss -tlnp 2>/dev/null | grep -q ":${p} "; then
        return 0
      fi
    fi
    
    # Method 3: netstat (fallback)
    if command -v netstat >/dev/null 2>&1; then
      if netstat -tlnp 2>/dev/null | grep -q ":${p} "; then
        return 0
      fi
    fi
    
    return 1
  }

  # Check if the port is used by another Docker container
  is_port_used_by_other_container() {
    local p=$1
    # Load cache if not loaded yet
    load_docker_containers_cache
    
    # First check if port is used by our project - if so, allow reuse
    local used_by_our_project=false
    while read -r name ports; do
      [[ -z "$name" ]] && continue
      
      local container_project
      local container_service
      get_container_labels "$name" container_project container_service
      
      # Check if this container belongs to our project
      if [[ "$container_project" == "$PROJECT_NAME" ]]; then
        # Check if this container uses the port we're checking
        for part in ${ports//,/ }; do
          part="${part// /}"
          if [[ "$part" == *"->"* ]]; then
            local host_port_part="${part%->*}"
            if [[ "$host_port_part" == *":"* ]]; then
              local host_port="${host_port_part##*:}"
            else
              local host_port="$host_port_part"
            fi
            if [[ "$host_port" != *"-"* ]] && [[ "$host_port" == "$p" ]]; then
              used_by_our_project=true
              break 2
            fi
          else
            if [[ "$part" != *"-"* ]] && [[ "$part" == "$p" ]]; then
              used_by_our_project=true
              break 2
            fi
          fi
        done
      fi
    done <<< "$__DOCKER_CONTAINERS_CACHE"
    
    # If port is used by our project, consider it available for reuse
    if [[ "$used_by_our_project" == "true" ]]; then
      return 1
    fi
    
    # Check other projects
    local found=1
    while read -r name ports; do
      local container_project
      local container_service
      get_container_labels "$name" container_project container_service

      # Ignore all containers from the same project (not just same service)
      if [[ "$container_project" == "$PROJECT_NAME" ]]; then
        continue
      fi

      for part in ${ports//,/ }; do
        part="${part%/tcp}"
        part="${part%/udp}"

        if [[ "$part" == *"->"* ]]; then
          host_port_part="${part%%->*}"
          if [[ "$host_port_part" == *":"* ]]; then
            host_port="${host_port_part##*:}"
          else
            host_port="$host_port_part"
          fi

          if [[ "$host_port" == *"-"* ]]; then
            range_start=${host_port%-*}
            range_end=${host_port#*-}
            if [[ "$p" -ge "$range_start" && "$p" -le "$range_end" ]]; then
              found=0
              break
            fi
          elif [[ "$host_port" == "$p" ]]; then
            found=0
            break
          fi
        else
          if [[ "$part" == *"-"* ]]; then
            range_start=${part%-*}
            range_end=${part#*-}
            if [[ "$p" -ge "$range_start" && "$p" -le "$range_end" ]]; then
              found=0
              break
            fi
          elif [[ "$part" == "$p" ]]; then
            found=0
            break
          fi
        fi
      done

      if [[ $found -eq 0 ]]; then
        break
      fi
    done <<< "$__DOCKER_CONTAINERS_CACHE"

    return $found
  }

  # Main check: whether the port is in use (excluding the current service in the current project)
  is_port_used() {
    local p=$1
    # Check if already found in this session, but allow same port for different database types
    if [[ " $__FOUND_PORTS " == *" $p "* ]]; then
      # Allow reuse of the same port for different database services (mysql/pgsql)
      if [[ "$SERVICE_NAME" == "database" ]]; then
        # For database services, allow port reuse since only one DB type will be active
        return 1
      else
        # For other services, port reuse is not allowed
        return 0
      fi
    fi
    # Don't check USED_PORTS here - those are from our own compose.yml and should be reusable

    if is_port_used_by_local "$p"; then
      return 0
    fi

    if is_port_used_by_other_container "$p"; then
      return 0
    fi

    return 1
  }

  # If a port is specified in compose.yml, check if it's available or used by our project
  if [[ -n "$SELECTED_PORT" ]]; then
    if ! is_port_used "$SELECTED_PORT"; then
      # Port is free or used by our project - use it
      # For database services, don't add to __FOUND_PORTS to allow port reuse between mysql/pgsql
      if [[ "$SERVICE_NAME" != "database" ]]; then
        __FOUND_PORTS+=" $SELECTED_PORT"
      fi
      echo "$SELECTED_PORT"
      return
    else
      # Port is occupied by another project - continue to find alternative
      local usage_info
      usage_info=$(get_port_usage_info "$SELECTED_PORT" "$PROJECT_NAME")
      echo -e "\033[33m==> Warning: Port $SELECTED_PORT from compose.yml is occupied by $usage_info, searching for alternative\033[0m" >&2
    fi
  fi

  # Search for a free port starting from the given port (or compose port if it was occupied)
  [[ -n "$SELECTED_PORT" ]] && PORT="$SELECTED_PORT"
  while [ "$PORT" -le 65535 ]; do
    if ! is_port_used "$PORT"; then
      # For database services, don't add to __FOUND_PORTS to allow port reuse between mysql/pgsql
      if [[ "$SERVICE_NAME" != "database" ]]; then
        __FOUND_PORTS+=" $PORT"
      fi
      echo "$PORT"
      return
    fi
    PORT=$((PORT+1))
  done

  echo -e "\033[38;5;208m==> Error: could not find a free port\033[0m" >&2
  return 1
}

# If the script is run directly, execute the function with the provided arguments
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  if [[ "$1" == "--batch" ]]; then
    # Batch mode: orodc-find_free_port --batch PROJECT_NAME CONFIG_DIR service1 port1 service2 port2 ...
    shift
    find_free_ports_batch "$@"
  else
    # Single mode: orodc-find_free_port PROJECT_NAME SERVICE_NAME PORT CONFIG_DIR
    find_free_port "$@"
  fi
fi
