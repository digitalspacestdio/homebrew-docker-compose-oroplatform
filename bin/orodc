#!/bin/bash
set -e
if [ "$DEBUG" ]; then set -x; fi

# Restore cursor visibility on exit
trap 'tput cnorm 2>/dev/null || true' EXIT

# Setup logging only when OroDC is used as PHP binary
setup_php_logging() {
  mkdir -p /tmp/.orodc
  local log_file="/tmp/.orodc/$(basename "$0").$(echo "$@" | md5sum - | awk '{ print $1 }').log"
  local err_file="/tmp/.orodc/$(basename "$0").$(echo "$@" | md5sum - | awk '{ print $1 }').err"
  touch "$log_file" "$err_file"
  exec 1> >(tee "$log_file")
  exec 2> >(tee "$err_file")
}

# Function to display informational messages with consistent formatting
msg_info() {
  # Always write to stderr (>&2) to keep separate from command stdout
  >&2 echo -e "\033[36m==> $1\033[0m"
}

# Function to display warning messages
msg_warning() {
  # Always write to stderr (>&2) to keep separate from command stdout
  >&2 echo -e "\033[33m==> Warning: $1\033[0m"
}

# Function to display success messages
msg_ok() {
  # Always write to stderr (>&2) to keep separate from command stdout
  >&2 echo -e "\033[32m==> $1\033[0m"
}

# Function to display error messages
msg_error() {
  # Always write to stderr (>&2) to keep separate from command stdout
  >&2 echo -e "\033[31m==> Error: $1\033[0m"
}

# Function to display header messages (bold blue)
msg_header() {
  >&2 echo -e "\033[1;34m==> $1\033[0m"
}

# Function to display highlighted text (bold white)
msg_highlight() {
  >&2 echo -e "\033[1;37m$1\033[0m"
}

# Backward compatibility aliases
echo_info() { msg_info "$*"; }
echo_ok() { msg_ok "$*"; }
echo_warn() { msg_warning "$*"; }
echo_error() { msg_error "$*"; }
echo_header() { msg_header "$*"; }

# Debug logging stub (will be overridden by common.sh library)
DEBUG_LOG="/tmp/orodc-debug.log"
debug_log() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$DEBUG_LOG"
}

# Spinner animation for long-running commands
show_spinner() {
  local pid=$1
  local message=$2
  local spinstr='|/-\'
  local delay=0.1
  
  # Only show spinner if stderr is connected to terminal (not redirected to file/pipe)
  # This ensures spinner animation works properly in interactive sessions
  if [[ -t 2 ]]; then
    # Hide cursor during spinner animation (write to stderr)
    tput civis 2>/dev/null || true
    
    while kill -0 "$pid" 2>/dev/null; do
      local temp=${spinstr#?}
      # Spinner always writes to stderr (>&2) to avoid mixing with command output
      printf "\r\033[36m==> %s %c\033[0m" "$message" "$spinstr" >&2
      spinstr=$temp${spinstr%"$temp"}
      sleep $delay
    done
    
    # Clear spinner line (write to stderr)
    printf "\r\033[K" >&2
    # Show cursor again (write to stderr)
    tput cnorm 2>/dev/null || true
  else
    # If not in terminal, just wait silently (e.g., when output is redirected)
    while kill -0 "$pid" 2>/dev/null; do
      sleep $delay
    done
  fi
}

# Command timing functions
get_timing_log_file() {
  local timing_dir="${HOME}/.orodc"
  mkdir -p "$timing_dir"
  echo "${timing_dir}/.timing-log"
}

get_previous_timing() {
  local command=$1
  local timing_file=$(get_timing_log_file)
  
  if [[ -f "$timing_file" ]]; then
    grep "^${command}:" "$timing_file" 2>/dev/null | tail -1 | cut -d: -f2
  fi
}

save_timing() {
  local command=$1
  local duration=$2
  local timing_file=$(get_timing_log_file)
  
  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  echo "${command}:${duration}:${timestamp}" >> "$timing_file"
}

# Function to update or add environment variable in .env.orodc file
update_env_var() {
  local file="$1"
  local key="$2"
  local value="$3"
  
  if [[ -f "$file" ]]; then
    if grep -q "^${key}=" "$file"; then
      sed -i.tmp "s|^${key}=.*|${key}=${value}|" "$file"
      rm -f "${file}.tmp"
    else
      echo "${key}=${value}" >> "$file"
    fi
  else
    echo "${key}=${value}" >> "$file"
  fi
}

show_spinner_with_progress() {
  local pid=$1
  local message=$2
  local expected_duration=${3:-0}
  local spinstr='|/-\'
  local delay=1
  local elapsed=0
  
  # Only show spinner if running in terminal (not captured)
  if [[ -t 2 ]]; then
    tput civis 2>/dev/null || true
    
    while kill -0 "$pid" 2>/dev/null; do
      local temp=${spinstr#?}
      
      if [[ $expected_duration -gt 0 ]]; then
        local remaining=$((expected_duration - elapsed))
        if [[ $remaining -lt 0 ]]; then
          remaining=0
        fi
        printf "\r\033[36m==> %s %c %d sec of ~%d\033[0m" "$message" "$spinstr" "$elapsed" "$expected_duration" >&2
      else
        printf "\r\033[36m==> %s %c %d sec\033[0m" "$message" "$spinstr" "$elapsed" >&2
      fi
      
      spinstr=$temp${spinstr%"$temp"}
      sleep $delay
      elapsed=$((elapsed + 1))
    done
    
    printf "\r\033[K" >&2
    tput cnorm 2>/dev/null || true
  else
    # If not in terminal, just wait silently
    while kill -0 "$pid" 2>/dev/null; do
      sleep $delay
    done
  fi
}

# Execute command with spinner and log on error
# Usage: run_with_spinner "message" "command"
# Spinner is disabled if DEBUG=1 or VERBOSE=1 is set, or if command contains --verbose/-v flags
# Logs are written to /tmp and preserved on error for user inspection
run_with_spinner() {
  local message=$1
  shift
  local cmd="$*"
  
  # If DEBUG or VERBOSE mode is enabled, or command contains verbose flags, run directly without spinner
  if [[ -n "${DEBUG:-}" ]] || [[ -n "${VERBOSE:-}" ]] || [[ "$cmd" =~ (--verbose|-vv) ]]; then
    msg_info "$message..."  # writes to stderr
    eval "$cmd"
    return $?
  fi
  
  # Run with spinner
  local log_file
  log_file=$(mktemp /tmp/orodc-output.XXXXXX)
  local exit_code=0
  
  # Run command in background: redirect both stdout and stderr to log file
  # This keeps command output separate from spinner animation (which writes to stderr)
  eval "$cmd" > "$log_file" 2>&1 &
  local cmd_pid=$!
  
  # Show spinner in foreground (writes to stderr of parent process)
  show_spinner $cmd_pid "$message"
  
  wait $cmd_pid || exit_code=$?
  
  # Special handling for docker-compose up: check if all containers are running or exited successfully
  # Containers are OK if they are either:
  # 1. Running (Healthy or Started)
  # 2. Exited with code 0
  if [[ $exit_code -ne 0 ]] && [[ "$cmd" =~ "up" ]]; then
    # Check if there are any failed containers (not "exited (0)" and not "Healthy")
    if ! grep -qE "exited \([1-9]|Error|failed" "$log_file"; then
      # No real errors found, all containers are either Healthy or exited (0)
      exit_code=0
    fi
  fi
  
  if [[ $exit_code -ne 0 ]]; then
    msg_error "Command failed (exit code: $exit_code)"  # writes to stderr
    echo "" >&2
    
    # Show last 20 lines of the log (write to stderr for consistency)
    local line_count=$(wc -l < "$log_file")
    if [[ $line_count -gt 20 ]]; then
      msg_info "Last 20 lines of output:"  # writes to stderr
      echo "" >&2
      tail -n 20 "$log_file" >&2  # writes to stderr
      echo "" >&2
      msg_info "Full log available at: $log_file"  # writes to stderr
      msg_info "View with: cat $log_file"  # writes to stderr
    else
      # If log is 20 lines or less, show everything (write to stderr)
      cat "$log_file" >&2
      echo "" >&2
      msg_info "Full log saved at: $log_file"  # writes to stderr
    fi
    
    # Keep log file for user inspection
    return $exit_code
  fi
  
  # Remove log file on success
  rm -f "$log_file"
  msg_ok "$message completed"  # writes to stderr
  return 0
}

# Interactive selector with validation and retry
# Usage: prompt_selector "prompt text" "default" "option1:value1" "option2:value2" ...
prompt_selector() {
  local prompt="$1"
  local default="$2"
  shift 2
  local options=("$@")
  local choice=""
  
  while true; do
    read -r -p "$prompt" choice
    
    # Empty input - use default
    if [[ -z "$choice" ]]; then
      if [[ -n "$default" ]]; then
        echo "$default"
        return 0
      else
        msg_error "Input required"
        continue
      fi
    fi
    
    # Check if input is a number (option index)
    if [[ "$choice" =~ ^[0-9]+$ ]]; then
      local idx=$((choice - 1))
      if [[ $idx -ge 0 ]] && [[ $idx -lt ${#options[@]} ]]; then
        local option="${options[$idx]}"
        echo "${option#*:}"  # Return value part
        return 0
      fi
    fi
    
    # Check if input matches any value directly
    for option in "${options[@]}"; do
      local value="${option#*:}"
      if [[ "$choice" == "$value" ]]; then
        echo "$value"
        return 0
      fi
    done
    
    # Check if it could be a custom value (for IP address case)
    if [[ "$choice" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]] || [[ "$choice" =~ ^[a-zA-Z0-9\.\-\_]+$ ]]; then
      echo "$choice"
      return 0
    fi
    
    # Invalid input - show error and retry
    msg_error "Invalid choice: '$choice'. Please try again."
  done
}

# Prompt for port number with validation
# Usage: prompt_port "prompt text" "default_port"
prompt_port() {
  local prompt="$1"
  local default="$2"
  local choice=""
  
  while true; do
    read -r -p "$prompt" choice
    
    # Empty input - use default
    if [[ -z "$choice" ]]; then
      if [[ -n "$default" ]]; then
        echo "$default"
        return 0
      else
        msg_error "Port number required"
        continue
      fi
    fi
    
    # Validate port number
    if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le 65535 ]]; then
      echo "$choice"
      return 0
    else
      msg_error "Invalid port: '$choice'. Port must be a number between 1 and 65535."
    fi
  done
}

# Prompt for yes/no confirmation with validation
# Usage: confirm_yes_no "prompt text" "default" (default: yes or no)
# Returns: 0 for yes, 1 for no
confirm_yes_no() {
  local prompt="$1"
  local default="${2:-no}"
  local answer
  
  while true; do
    if [[ "$default" == "yes" ]]; then
      printf "\033[1;33m%s [Y/n]: \033[0m" "$prompt" >&2
      read -r answer </dev/tty 2>/dev/null || read -r answer
      answer="${answer:-y}"
    else
      printf "\033[1;33m%s [y/N]: \033[0m" "$prompt" >&2
      read -r answer </dev/tty 2>/dev/null || read -r answer
      answer="${answer:-n}"
    fi
    
    # Accept: y, yes, Y, YES, n, no, N, NO
    answer_lower="$(echo "$answer" | tr '[:upper:]' '[:lower:]')"
    case "$answer_lower" in  # Convert to lowercase
      y|yes) return 0 ;;
      n|no) return 1 ;;
      *)
        msg_error "Invalid input: '$answer'. Please enter 'y' (yes) or 'n' (no)."
        ;;
    esac
  done
}

# Show service URLs after successful 'up' command
show_service_urls() {
  echo "" >&2
  
  # Check if proxy container is running
  local proxy_running=false
  if ${DOCKER_BIN} ps --filter "name=proxy" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -q "^proxy$"; then
    proxy_running=true
  fi
  
  # Show domain URLs if proxy is running
  if [[ "$proxy_running" == "true" ]]; then
    # Main domain (bold green)
    printf "\033[1;32m[${DC_ORO_NAME}] Application: https://${DC_ORO_NAME}.docker.local\033[0m\n"
    
    # Additional domains from DC_ORO_EXTRA_HOSTS
    if [[ -n "${DC_ORO_EXTRA_HOSTS:-}" ]]; then
      IFS=',' read -ra HOSTS <<< "$DC_ORO_EXTRA_HOSTS"
      for host in "${HOSTS[@]}"; do
        # Trim whitespace
        host=$(echo "$host" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        if [[ -n "$host" ]]; then
          # Auto-append .docker.local if host is a single word (no dots)
          if [[ "$host" != *.* ]]; then
            host="$host.docker.local"
          fi
          printf "\033[1;32m[${DC_ORO_NAME}] Application: https://${host}\033[0m\n"
        fi
      done
    fi
    
    echo "" >&2
  fi
  
  # Always show localhost URLs
  printf "\033[0;37m[${DC_ORO_NAME}] Application: http://localhost:${DC_ORO_PORT_NGINX}\033[0m\n"
  printf "\033[0;37m[${DC_ORO_NAME}] Mailpit: http://localhost:${DC_ORO_PORT_MAIL_WEBGUI}\033[0m\n"
  
  # Show Mailpit alternative entry point on main domain if proxy is running
  if [[ "$proxy_running" == "true" ]]; then
    printf "\033[0;37m[${DC_ORO_NAME}] Mailpit: https://${DC_ORO_NAME}.docker.local/mailbox\033[0m\n"
  fi
  
  printf "\033[0;37m[${DC_ORO_NAME}] Elasticsearch: http://localhost:${DC_ORO_PORT_SEARCH}\033[0m\n"
  printf "\033[0;37m[${DC_ORO_NAME}] Mq: http://localhost:${DC_ORO_PORT_MQ}\033[0m\n"
  
  if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pdo_pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]];then
    printf "\033[0;37m[${DC_ORO_NAME}] Database: 127.0.0.1:${DC_ORO_PORT_PGSQL}\033[0m\n"
  elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "pdo_mysql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
    printf "\033[0;37m[${DC_ORO_NAME}] Database: 127.0.0.1:${DC_ORO_PORT_MYSQL}\033[0m\n"
  fi

  printf "\033[0;37m[${DC_ORO_NAME}] SSH: 127.0.0.1:${DC_ORO_PORT_SSH}\033[0m\n"
  
  # Show proxy hint if not running
  if [[ "$proxy_running" == "false" ]]; then
    echo "" >&2
    msg_info "Want to use custom domains and SSL? Start the proxy:"
    msg_info "  orodc proxy up -d"
    msg_info "  orodc proxy install-certs"
    msg_info ""
    msg_info "Then access via: https://${DC_ORO_NAME}.docker.local"
  fi
}

# ============================================================================
# Interactive Menu System
# ============================================================================

# Get environment registry file path
get_environment_registry_file() {
  local registry_dir="${HOME}/.orodc"
  mkdir -p "$registry_dir"
  echo "${registry_dir}/environments.json"
}

# Read environment registry
get_environment_registry() {
  local registry_file=$(get_environment_registry_file)
  if [[ -f "$registry_file" ]]; then
    cat "$registry_file" 2>/dev/null || echo '{"environments":[]}'
  else
    echo '{"environments":[]}'
  fi
}

# Write environment registry
write_environment_registry() {
  local registry_file=$(get_environment_registry_file)
  local json_content="$1"
  echo "$json_content" > "$registry_file" 2>/dev/null || return 1
}

# Check if environment is registered
is_environment_registered() {
  local env_name="$1"

  # Check if jq is available
  if ! command -v jq >/dev/null 2>&1; then
    return 1
  fi

  local registry=$(get_environment_registry)
  local count=$(echo "$registry" | jq --arg name "$env_name" '[.environments[] | select(.name == $name)] | length')

  if [[ "$count" -gt 0 ]]; then
    return 0
  else
    return 1
  fi
}

# Clean up non-existent environments from registry
cleanup_registry() {
  if ! command -v jq >/dev/null 2>&1; then
    return 0
  fi

  local registry=$(get_environment_registry)
  local env_count=$(echo "$registry" | jq '.environments | length')
  local cleaned_registry="$registry"
  local removed_count=0

  local i=0
  while [[ $i -lt $env_count ]]; do
    local env_name=$(echo "$registry" | jq -r ".environments[$i].name")
    local env_path=$(echo "$registry" | jq -r ".environments[$i].path")
    local config_dir=$(echo "$registry" | jq -r ".environments[$i].config_dir")
    local should_remove=false

    # Check if path exists
    if [[ ! -d "$env_path" ]]; then
      debug_log "cleanup_registry: Removing '$env_name' - path does not exist: $env_path"
      should_remove=true
    fi

    # Check if config directory exists
    if [[ -n "$config_dir" ]] && [[ ! -d "$config_dir" ]]; then
      debug_log "cleanup_registry: Removing '$env_name' - config_dir does not exist: $config_dir"
      should_remove=true
    fi

    # Check if compose.yml exists in config directory
    # If compose.yml is missing, the project cannot be started and should be removed
    if [[ -n "$config_dir" ]] && [[ -d "$config_dir" ]] && [[ ! -f "${config_dir}/compose.yml" ]]; then
      debug_log "cleanup_registry: Removing '$env_name' - compose.yml missing in $config_dir"
      should_remove=true
    fi

    if [[ "$should_remove" == "true" ]]; then
      cleaned_registry=$(echo "$cleaned_registry" | jq --arg name "$env_name" '.environments = (.environments | map(select(.name != $name)))')
      removed_count=$((removed_count + 1))
    fi

    i=$((i + 1))
  done

  if [[ $removed_count -gt 0 ]]; then
    write_environment_registry "$cleaned_registry"
    debug_log "cleanup_registry: Removed $removed_count environment(s)"
  fi
}

# Register or update environment in registry
register_environment() {
  local env_name="$1"
  local env_path="$2"
  local config_dir="$3"
  
  local registry=$(get_environment_registry)
  local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  
  # Check if jq is available
  if ! command -v jq >/dev/null 2>&1; then
    msg_warning "jq not found, skipping environment registration"
    return 0
  fi
  
  # Ensure absolute path - always use realpath
  local absolute_path=$(realpath "$env_path" 2>/dev/null || echo "$env_path")
  if [[ -n "$absolute_path" ]] && [[ "$absolute_path" != "$env_path" ]]; then
    env_path="$absolute_path"
  fi
  
  # Remove existing entry if present
  registry=$(echo "$registry" | jq --arg name "$env_name" '.environments = (.environments | map(select(.name != $name)))')
  
  # Add new entry
  registry=$(echo "$registry" | jq --arg name "$env_name" \
    --arg path "$env_path" \
    --arg config "$config_dir" \
    --arg timestamp "$timestamp" \
    '.environments += [{
      "name": $name,
      "path": $path,
      "config_dir": $config,
      "last_used": $timestamp
    }]')
  
  write_environment_registry "$registry"
}

# Check if directory is an OroPlatform project
is_oroplatform_project() {
  local dir="${1:-$PWD}"
  
  # Exclude Homebrew formula/tap directories
  if [[ "$dir" == *"/Homebrew/Library/Taps/"* ]] || [[ "$dir" == *"/Cellar/"* ]] || [[ "$dir" == *"/Caskroom/"* ]]; then
    return 1
  fi
  
  # Check for common OroPlatform indicators
  if [[ -f "$dir/composer.json" ]] || [[ -f "$dir/app/config/parameters.yml" ]] || [[ -d "$dir/bin" ]] || [[ -f "$dir/bin/console" ]]; then
    return 0
  fi
  return 1
}

# Get environment status (running/stopped/uninitialized)
get_environment_status() {
  local env_name="$1"
  local check_dir="${2:-$PWD}"
  
  if [[ -z "$env_name" ]]; then
    echo "unknown"
    return
  fi
  
  # First check if this is an OroPlatform project
  if ! is_oroplatform_project "$check_dir"; then
    echo "uninitialized"
    return
  fi
  
  # Check if Docker is available
  if ! command -v docker >/dev/null 2>&1 && [[ -z "${DOCKER_BIN:-}" ]]; then
    echo "unknown"
    return
  fi
  
  local docker_cmd="${DOCKER_BIN:-docker}"
  
  # Check if any containers for this project are running
  local project_name="${env_name}"
  if ${docker_cmd} ps --filter "label=com.docker.compose.project=${project_name}" --format "{{.Names}}" 2>/dev/null | grep -q .; then
    echo "running"
  else
    echo "stopped"
  fi
}

# Scan and auto-register environments from ~/.orodc/* directories
scan_and_register_environments() {
  # DO NOT auto-register environments from ~/.orodc scanning
  # Environments are registered only when user runs init or docker compose commands
  # This prevents wrong paths from being registered
  debug_log "scan_and_register_environments: Skipped (no auto-registration)"
}

# Get real environment path from Docker mounts
get_environment_real_path() {
  local env_name="$1"
  local docker_cmd="${DOCKER_BIN:-docker}"
  
  # Try to find containers for this project
  local containers=$(${docker_cmd} ps -a --filter "label=com.docker.compose.project=${env_name}" --format "{{.Names}}" 2>/dev/null | head -1)
  
  if [[ -z "$containers" ]]; then
    echo ""
    return 1
  fi
  
  # Get mounts from the first container
  local mounts=$(${docker_cmd} inspect "$containers" --format '{{json .Mounts}}' 2>/dev/null)
  
  if [[ -z "$mounts" ]] || [[ "$mounts" == "null" ]]; then
    echo ""
    return 1
  fi
  
  # Try to find source path from mounts (look for bind mounts with application directory)
  # Check for common mount patterns: /app, /var/www, or paths containing the project name
  local real_path=$(echo "$mounts" | jq -r '.[] | select(.Type == "bind") | select(.Source != null) | .Source' 2>/dev/null | grep -E "(/app|/var/www|${env_name})" | head -1)
  
  # If not found, try to get any bind mount source that looks like a project directory
  if [[ -z "$real_path" ]]; then
    real_path=$(echo "$mounts" | jq -r '.[] | select(.Type == "bind") | select(.Source != null and (.Source | contains("/home") or contains("/Users") or contains("/var/www"))) | .Source' 2>/dev/null | head -1)
  fi
  
  # Verify the path exists and contains typical OroPlatform files
  if [[ -n "$real_path" ]] && [[ -d "$real_path" ]]; then
    # Check if it looks like an OroPlatform project
    if [[ -f "$real_path/composer.json" ]] || [[ -f "$real_path/app/config/parameters.yml" ]] || [[ -d "$real_path/bin" ]]; then
      echo "$real_path"
      return 0
    fi
  fi
  
  echo ""
  return 1
}

# List all environments and allow selection
list_environments() {
  # Clean up non-existent environments first
  cleanup_registry

  local registry=$(get_environment_registry)

  if ! command -v jq >/dev/null 2>&1; then
    msg_error "jq is required for environment listing"
    return 1
  fi

  local env_count=$(echo "$registry" | jq '.environments | length')

  echo "" >&2
  msg_header "Environments"
  echo "" >&2
  printf "%-5s %-32s %-24s %s\n" "NUM" "NAME" "STATUS" "PATH" >&2
  printf "%-5s %-32s %-24s %s\n" "---" "----" "------" "----" >&2

  local env_names=()
  local env_paths=()
  local env_config_dirs=()
  local display_count=0

  # First, add current environment if it exists and is not registered
  debug_log "list_environments: DC_ORO_NAME='${DC_ORO_NAME:-<not set>}' DC_ORO_CONFIG_DIR='${DC_ORO_CONFIG_DIR:-<not set>}'"

  if [[ -n "${DC_ORO_NAME:-}" ]] && [[ -n "${DC_ORO_CONFIG_DIR:-}" ]]; then
    debug_log "list_environments: Checking if '${DC_ORO_NAME}' is registered"

    if ! is_environment_registered "${DC_ORO_NAME}"; then
      debug_log "list_environments: '${DC_ORO_NAME}' is NOT registered"
      local current_path=$(realpath "$PWD" 2>/dev/null || echo "$PWD")
      local current_status=$(get_environment_status "${DC_ORO_NAME}" "$current_path")
      debug_log "list_environments: current_status='$current_status' current_path='$current_path'"

      # Show if it has a status (not uninitialized means it's been set up)
      if [[ "$current_status" != "uninitialized" ]] && [[ -n "$current_status" ]]; then
        debug_log "list_environments: Adding current unregistered env to list"
        env_names+=("${DC_ORO_NAME}")
        env_config_dirs+=("${DC_ORO_CONFIG_DIR}")
        env_paths+=("$current_path")

        local display_name="${DC_ORO_NAME}"
        if [[ ${#display_name} -gt 32 ]]; then
          display_name="${display_name:0:29}..."
        fi

        # Add (unregistered) to status
        local display_status="${current_status} (unregistered)"

        display_count=$((display_count + 1))
        printf "%-5s %-32s %-24s %s\n" "$display_count" "$display_name" "$display_status" "$current_path" >&2
      else
        debug_log "list_environments: Skipping - status is '$current_status'"
      fi
    else
      debug_log "list_environments: '${DC_ORO_NAME}' IS registered, skipping"
    fi
  else
    debug_log "list_environments: DC_ORO_NAME or DC_ORO_CONFIG_DIR not set"
  fi

  # Then add all registered environments
  local i=0
  while [[ $i -lt $env_count ]]; do
    local env_name=$(echo "$registry" | jq -r ".environments[$i].name")
    local config_dir=$(echo "$registry" | jq -r ".environments[$i].config_dir")
    local registry_path=$(echo "$registry" | jq -r ".environments[$i].path")

    local env_status=$(get_environment_status "$env_name")

    # Skip if uninitialized and no compose.yml (never been set up)
    if [[ "$env_status" == "uninitialized" ]] && [[ -n "$config_dir" ]] && [[ ! -f "${config_dir}/compose.yml" ]]; then
      debug_log "list_environments: Skipping '$env_name' - uninitialized and no compose.yml"
      i=$((i + 1))
      continue
    fi

    # Check if registered (should be, but double-check)
    local display_status="$env_status"
    if ! is_environment_registered "$env_name"; then
      display_status="${env_status} (unregistered)"
    fi

    # Ensure registry_path is absolute
    local absolute_registry_path=$(realpath "$registry_path" 2>/dev/null || echo "$registry_path")

    # Check if path exists, show "-" if not
    local display_path="$absolute_registry_path"
    if [[ ! -d "$absolute_registry_path" ]]; then
      display_path="-"
    fi

    env_names+=("$env_name")
    env_config_dirs+=("$config_dir")
    env_paths+=("$absolute_registry_path")

    debug_log "list_environments: Added env='$env_name' path='$absolute_registry_path' display='$display_path'"

    # Truncate name to 32 characters if longer
    local display_name="$env_name"
    if [[ ${#display_name} -gt 32 ]]; then
      display_name="${display_name:0:29}..."
    fi

    display_count=$((display_count + 1))
    printf "%-5s %-32s %-24s %s\n" "$display_count" "$display_name" "$display_status" "$display_path" >&2
    i=$((i + 1))
  done
  
  if [[ $display_count -eq 0 ]]; then
    msg_info "No valid environments found (all missing compose.yml)"
    return 0
  fi
  echo "" >&2
  
  # Allow selection
  echo -n "Select environment number to switch (or Enter to return): " >&2
  read -r selection
  
  if [[ -z "$selection" ]]; then
    return 0
  fi
  
  if [[ "$selection" =~ ^[0-9]+$ ]] && [[ $selection -ge 1 ]] && [[ $selection -le $display_count ]]; then
    local idx=$((selection - 1))
    local selected_name="${env_names[$idx]}"
    local selected_path="${env_paths[$idx]}"
    local selected_config_dir="${env_config_dirs[$idx]}"

      debug_log "list_environments: Selected idx=$idx name='$selected_name' path='$selected_path' config='$selected_config_dir'"

      # If path doesn't exist, ask user to provide it
      if [[ ! -d "$selected_path" ]]; then
        echo "" >&2
        msg_warning "Path not found: $selected_path"
        msg_info "Please enter the correct path to the project directory:"
        echo -n "> " >&2
        read -r user_path

        if [[ -z "$user_path" ]]; then
          msg_error "Path not provided"
          echo "" >&2
          echo -n "Press Enter to continue..." >&2
          read -r
          return 1
        fi

        # Expand tilde and make absolute
        user_path="${user_path/#\~/$HOME}"
        user_path=$(realpath "$user_path" 2>/dev/null || echo "$user_path")

        if [[ ! -d "$user_path" ]]; then
          msg_error "Directory does not exist: $user_path"
          echo "" >&2
          echo -n "Press Enter to continue..." >&2
          read -r
          return 1
        fi

        # Update selected_path and registry
        selected_path="$user_path"
        register_environment "$selected_name" "$selected_path" "$selected_config_dir"
        msg_ok "Path updated in registry"
      fi
      
      msg_info "Switching to environment: $selected_name"
      msg_info "Changing directory to: $selected_path"
      
      # Change directory - use realpath to ensure absolute path
      local absolute_path=$(realpath "$selected_path" 2>/dev/null || echo "$selected_path")
      
      if [[ ! -d "$absolute_path" ]]; then
        msg_error "Environment path does not exist: $absolute_path"
        echo "" >&2
        echo -n "Press Enter to continue..." >&2
        read -r
        return 1
      fi
      
      msg_info "Switching to environment: $selected_name"
      msg_info "Changing directory to: $absolute_path"
      
      # Update last_used timestamp in registry with absolute path
      register_environment "$selected_name" "$absolute_path" "$selected_config_dir"

      # Restart the entire script in the new directory
      # Export selected environment name so it's preserved after exec
      export DC_ORO_SELECTED_ENV_NAME="$selected_name"
      export DC_ORO_SELECTED_ENV_PATH="$absolute_path"
      export DC_ORO_SELECTED_ENV_CONFIG="$selected_config_dir"

      debug_log "list_environments: Exporting DC_ORO_SELECTED_ENV_NAME='$selected_name' PATH='$absolute_path' CONFIG='$selected_config_dir'"
      # Unset all environment-related variables to force recalculation
      unset DC_ORO_NAME
      unset DC_ORO_CONFIG_DIR
      unset DC_ORO_APPDIR
      unset COMPOSE_PROJECT_NAME
      
      # Change directory and exec script in new directory
      # CRITICAL: cd must happen before exec, and exec must use absolute path to script
      cd "$absolute_path" || {
        msg_error "Failed to change directory to $absolute_path"
        return 1
      }
      
      msg_ok "Successfully switched to environment: $selected_name"
      echo "" >&2
      
      # Get absolute path to script for exec (important for proper execution)
      local script_path=$(realpath "$0" 2>/dev/null || echo "$0")
      if [[ ! "$script_path" = /* ]]; then
        # If still relative, try to find it in PATH
        script_path=$(command -v "$0" 2>/dev/null || echo "$0")
      fi
      
      # This ensures all environment variables are properly reinitialized in new directory
      exec "$script_path"
  else
    msg_error "Invalid selection: $selection"
    return 1
  fi
}

# Get last used environment from registry
get_last_used_environment() {
  local registry=$(get_environment_registry)
  
  if ! command -v jq >/dev/null 2>&1; then
    return 1
  fi
  
  local env_count=$(echo "$registry" | jq '.environments | length')
  if [[ "$env_count" == "0" ]]; then
    return 1
  fi
  
  # Find environment with latest last_used timestamp that has compose.yml
  local last_env=""
  local last_timestamp=0
  
  local i=0
  while [[ $i -lt $env_count ]]; do
    local env_name=$(echo "$registry" | jq -r ".environments[$i].name")
    local env_path=$(echo "$registry" | jq -r ".environments[$i].path")
    local config_dir=$(echo "$registry" | jq -r ".environments[$i].config_dir")
    local last_used=$(echo "$registry" | jq -r ".environments[$i].last_used // \"0\"")
    
    # Skip if compose.yml doesn't exist
    if [[ -n "$config_dir" ]] && [[ ! -f "${config_dir}/compose.yml" ]]; then
      i=$((i + 1))
      continue
    fi
    
    # Convert timestamp to number for comparison
    local timestamp_num=0
    if [[ "$last_used" != "null" ]] && [[ "$last_used" != "0" ]] && [[ -n "$last_used" ]]; then
      timestamp_num=$(date -d "$last_used" +%s 2>/dev/null || echo "0")
    fi
    
    if [[ $timestamp_num -gt $last_timestamp ]] && [[ -d "$env_path" ]]; then
      last_timestamp=$timestamp_num
      last_env="$env_path"
    fi
    
    i=$((i + 1))
  done
  
  if [[ -n "$last_env" ]] && [[ -d "$last_env" ]]; then
    echo "$last_env"
    return 0
  fi
  
  return 1
}

# Detect current environment (NO auto-registration)
detect_current_environment() {
  # This function no longer auto-registers environments
  # Environments are registered only after 'init' or when compose.yml is created
  debug_log "detect_current_environment: Called (no auto-registration)"
}

# Check if we're in a project directory
# Returns 0 if in project, 1 if not
check_in_project() {
  if [[ -z "${DC_ORO_NAME:-}" ]] || [[ -z "${DC_ORO_CONFIG_DIR:-}" ]]; then
    msg_error "No project found in current directory"
    msg_info "Please navigate to a project directory or select a project from the list (option 1)"
    echo "" >&2
    return 1
  fi
  return 0
}

# Manage domains interactively
manage_domains() {
  local env_file="${DC_ORO_APPDIR}/.env.orodc"
  if [[ ! -f "$env_file" ]]; then
    env_file="${DC_ORO_CONFIG_DIR}/.env.orodc"
  fi
  
  local current_hosts=""
  if [[ -f "$env_file" ]]; then
    current_hosts=$(grep "^DC_ORO_EXTRA_HOSTS=" "$env_file" 2>/dev/null | cut -d'=' -f2- | tr -d '"' | tr -d "'" || echo "")
  fi
  
  echo "" >&2
  msg_header "Domain Management"
  echo "" >&2
  if [[ -n "$current_hosts" ]]; then
    msg_info "Current domains: $current_hosts"
  else
    msg_info "No domains currently configured"
  fi
  echo "" >&2
  
  local domains=()
  if [[ -n "$current_hosts" ]]; then
    IFS=',' read -ra domains <<< "$current_hosts"
  fi
  
  while true; do
    echo -n "Add domain (or 'remove' to delete, 'done' to finish): " >&2
    read -r input
    
    if [[ -z "$input" ]]; then
      continue
    fi
    
    if [[ "$input" == "done" ]]; then
      break
    fi
    
    if [[ "$input" == "remove" ]]; then
      if [[ ${#domains[@]} -eq 0 ]]; then
        msg_warning "No domains to remove"
        continue
      fi
      
      echo "" >&2
      msg_info "Current domains:"
      local i=0
      for domain in "${domains[@]}"; do
        echo "  $((i + 1)). $domain" >&2
        i=$((i + 1))
      done
      echo "" >&2
      echo -n "Enter domain number to remove: " >&2
      read -r num
      
      if [[ "$num" =~ ^[0-9]+$ ]] && [[ $num -ge 1 ]] && [[ $num -le ${#domains[@]} ]]; then
        local idx=$((num - 1))
        unset "domains[$idx]"
        domains=("${domains[@]}")
        msg_ok "Domain removed"
      else
        msg_error "Invalid selection"
      fi
      continue
    fi
    
    # Validate and add domain
    local domain=$(echo "$input" | xargs)  # trim whitespace
    
    # Handle short names (add .docker.local)
    if [[ ! "$domain" =~ \. ]]; then
      domain="${domain}.docker.local"
    fi
    
    # Basic validation
    if [[ "$domain" =~ ^[a-zA-Z0-9._-]+$ ]]; then
      domains+=("$domain")
      msg_ok "Domain added: $domain"
    else
      msg_error "Invalid domain format: $domain"
    fi
  done
  
  # Update .env.orodc file
  local new_hosts=$(IFS=','; echo "${domains[*]}")
  if [[ -n "$new_hosts" ]]; then
    update_env_var "$env_file" "DC_ORO_EXTRA_HOSTS" "$new_hosts"
    msg_ok "Domains updated: $new_hosts"
  else
    # Remove the line if no domains
    if [[ -f "$env_file" ]]; then
      sed -i.tmp '/^DC_ORO_EXTRA_HOSTS=/d' "$env_file"
      rm -f "${env_file}.tmp"
    fi
    msg_ok "All domains removed"
  fi
}

# List database dump files in var/backup/ directory
list_database_dumps() {
  local project_dir="${DC_ORO_APPDIR:-$PWD}"
  local backup_dir="${project_dir}/var/backup"
  local var_dir="${project_dir}/var"
  
  local dumps=()
  
  # Check backup directory first
  if [[ -d "$backup_dir" ]]; then
    while IFS= read -r -d '' file; do
      dumps+=("$file")
    done < <(find "$backup_dir" -maxdepth 1 -type f \( -name "*.sql" -o -name "*.sql.gz" \) -print0 2>/dev/null | sort -z)
  fi
  
  # Fallback to var/ directory if backup is empty
  if [[ ${#dumps[@]} -eq 0 ]] && [[ -d "$var_dir" ]]; then
    while IFS= read -r -d '' file; do
      dumps+=("$file")
    done < <(find "$var_dir" -maxdepth 1 -type f \( -name "*.sql" -o -name "*.sql.gz" \) -print0 2>/dev/null | sort -z)
  fi
  
  if [[ ${#dumps[@]} -eq 0 ]]; then
    return 1
  fi
  
  printf '%s\n' "${dumps[@]}"
}

# Export database to var/backup/ folder
export_database_interactive() {
  # Use project directory, fallback to current directory
  local project_dir="${DC_ORO_APPDIR:-$PWD}"
  local backup_dir="${project_dir}/var/backup"
  mkdir -p "$backup_dir"
  
  local default_filename="database-$(date +'%Y%m%d%H%M%S').sql.gz"
  echo -n "Enter filename [default: $default_filename]: " >&2
  read -r filename
  
  if [[ -z "$filename" ]]; then
    filename="$default_filename"
  fi
  
  # Ensure .sql.gz extension
  if [[ ! "$filename" =~ \.(sql|sql\.gz)$ ]]; then
    filename="${filename}.sql.gz"
  fi
  
  local dump_path="${backup_dir}/${filename}"
  
  # Use existing exportdb logic
  DB_DUMP="$dump_path"
  DB_DUMP_BASENAME=$(echo "${DB_DUMP##*/}")
  touch "${DB_DUMP}"
  
  if [[ $DC_ORO_DATABASE_SCHEMA == "pgsql" ]] || [[ $DC_ORO_DATABASE_SCHEMA == "postgres" ]] || [[ $DC_ORO_DATABASE_SCHEMA == "postgresql" ]]; then
    DB_EXPORT_CMD="PGPASSWORD=\$DC_ORO_DATABASE_PASSWORD pg_dump -Fp --clean --if-exists -h \$DC_ORO_DATABASE_HOST -p \$DC_ORO_DATABASE_PORT -U \$DC_ORO_DATABASE_USER -d \$DC_ORO_DATABASE_DBNAME"
  elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
    DB_EXPORT_CMD="MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysqldump --no-tablespaces --column-statistics=0 --set-gtid-purged=OFF --quick --max-allowed-packet=16M --disable-keys --hex-blob --no-autocommit --insert-ignore --skip-lock-tables --single-transaction -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME | sed -E 's/[Dd][Ee][Ff][Ii][Nn][Ee][Rr][ ]*=[ ]*[^*]*\*/DEFINER=CURRENT_USER \*/'"
  fi
  
  msg_info "Starting export of the database..."
  msg_info "Database: $DC_ORO_DATABASE_HOST:$DC_ORO_DATABASE_PORT/$DC_ORO_DATABASE_DBNAME"
  msg_info "Export to: $DB_DUMP"
  
  export_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run --quiet --rm -v \"${DB_DUMP}:/${DB_DUMP_BASENAME}\" database-cli bash -c \"$DB_EXPORT_CMD | gzip > /${DB_DUMP_BASENAME}\""
  run_with_spinner "Exporting database" "$export_cmd" || return $?
  
  msg_ok "Database exported successfully"
  msg_info "File: $DB_DUMP"
  msg_info "Size: $(du -h "$DB_DUMP" | cut -f1)"
}

# Import database from var/backup/ folder or file path
import_database_interactive() {
  # Use project directory, fallback to current directory
  local project_dir="${DC_ORO_APPDIR:-$PWD}"
  local backup_dir="${project_dir}/var/backup"
  local var_dir="${project_dir}/var"
  local dumps=()
  local dump_files=()
  
  # Get dumps using list_database_dumps (checks var/backup/ first, then var/)
  while IFS= read -r file; do
    if [[ -n "$file" ]]; then
      dumps+=("$file")
      dump_files+=("$file")
    fi
  done < <(list_database_dumps 2>/dev/null || true)
  
  local selected_file=""
  
  if [[ ${#dumps[@]} -gt 0 ]]; then
    echo "" >&2
    msg_header "Available Database Dumps"
    echo "" >&2
    local i=1
    for dump in "${dumps[@]}"; do
      local basename_dump=$(basename "$dump")
      local size=$(du -h "$dump" 2>/dev/null | cut -f1)
      printf "  %2d) %s (%s)\n" "$i" "$basename_dump" "$size" >&2
      i=$((i + 1))
    done
    echo "" >&2
    echo -n "Select dump number or enter file path: " >&2
    read -r input
    
    if [[ "$input" =~ ^[0-9]+$ ]] && [[ $input -ge 1 ]] && [[ $input -le ${#dumps[@]} ]]; then
      selected_file="${dumps[$((input - 1))]}"
    elif [[ -n "$input" ]]; then
      # Try as file path
      if [[ -r "$input" ]]; then
        selected_file=$(realpath "$input")
      elif [[ -r "${project_dir}/${input}" ]]; then
        selected_file=$(realpath "${project_dir}/${input}")
      elif [[ -r "${backup_dir}/${input}" ]]; then
        selected_file=$(realpath "${backup_dir}/${input}")
      elif [[ -r "${var_dir}/${input}" ]]; then
        selected_file=$(realpath "${var_dir}/${input}")
      else
        msg_error "File not found or not readable: $input"
        return 1
      fi
    else
      msg_error "No selection made"
      return 1
    fi
  else
    echo -n "Enter database dump file path: " >&2
    read -r input
    
    if [[ -z "$input" ]]; then
      msg_error "No file provided"
      return 1
    fi
    
    if [[ -r "$input" ]]; then
      selected_file=$(realpath "$input")
    elif [[ -r "${backup_dir}/${input}" ]]; then
      selected_file=$(realpath "${backup_dir}/${input}")
    elif [[ -r "${var_dir}/${input}" ]]; then
      selected_file=$(realpath "${var_dir}/${input}")
    elif [[ -r "${project_dir}/${input}" ]]; then
      selected_file=$(realpath "${project_dir}/${input}")
    else
      msg_error "File not found or not readable: $input"
      return 1
    fi
  fi
  
  if [[ -z "$selected_file" ]] || [[ ! -r "$selected_file" ]]; then
    msg_error "Invalid file: $selected_file"
    return 1
  fi
  
  # Use existing importdb logic
  DB_DUMP="$selected_file"
  DB_DUMP_BASENAME=$(echo "${DB_DUMP##*/}")
  
  if [[ $DC_ORO_DATABASE_SCHEMA == "pdo_pgsql" ]] || [[ $DC_ORO_DATABASE_SCHEMA == "postgres" ]];then
    DB_IMPORT_CMD="sed -E 's/[Oo][Ww][Nn][Ee][Rr]:[[:space:]]*[a-zA-Z0-9_]+/Owner: '\$DC_ORO_DATABASE_USER'/g' | sed -E 's/[Oo][Ww][Nn][Ee][Rr][[:space:]]+[Tt][Oo][[:space:]]+[a-zA-Z0-9_]+/OWNER TO '\$DC_ORO_DATABASE_USER'/g' | sed -E 's/[Ff][Oo][Rr][[:space:]]+[Rr][Oo][Ll][Ee][[:space:]]+[a-zA-Z0-9_]+/FOR ROLE '\$DC_ORO_DATABASE_USER'/g' | sed -E 's/[Tt][Oo][[:space:]]+[a-zA-Z0-9_]+;/TO '\$DC_ORO_DATABASE_USER';/g' | sed -E '/^[[:space:]]*[Rr][Ee][Vv][Oo][Kk][Ee][[:space:]]+[Aa][Ll][Ll]/d' | sed -e '/SET transaction_timeout = 0;/d' | sed -E '/[\\]restrict|[\\]unrestrict/d' | PGPASSWORD=\$DC_ORO_DATABASE_PASSWORD psql --set ON_ERROR_STOP=on -h \$DC_ORO_DATABASE_HOST -p \$DC_ORO_DATABASE_PORT -U \$DC_ORO_DATABASE_USER -d \$DC_ORO_DATABASE_DBNAME -1 >/dev/null"
  elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "pdo_mysql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
    DB_IMPORT_CMD="sed -E 's/[Dd][Ee][Ff][Ii][Nn][Ee][Rr][ ]*=[ ]*[^*]*\*/DEFINER=CURRENT_USER \*/' | MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME"
  fi
  
  if echo ${DB_DUMP_BASENAME} | grep -i 'sql\.gz$' > /dev/null; then
    DB_IMPORT_CMD="zcat ${DB_DUMP_BASENAME} | sed -E 's/^[[:space:]]*[Cc][Rr][Ee][Aa][Tt][Ee][[:space:]]+[Ff][Uu][Nn][Cc][Tt][Ii][Oo][Nn]/CREATE OR REPLACE FUNCTION/g' | ${DB_IMPORT_CMD}"
  else
    DB_IMPORT_CMD="cat /${DB_DUMP_BASENAME} | sed -E 's/^[[:space:]]*[Cc][Rr][Ee][Aa][Tt][Ee][[:space:]]+[Ff][Uu][Nn][Cc][Tt][Ii][Oo][Nn]/CREATE OR REPLACE FUNCTION/g' | ${DB_IMPORT_CMD}"
  fi
  
  msg_info "Starting import of the database dump..."
  msg_info "From: $DB_DUMP"
  msg_info "File size: $(du -h "$DB_DUMP" | cut -f1)"
  msg_info "Database: $DC_ORO_DATABASE_HOST:$DC_ORO_DATABASE_PORT/$DC_ORO_DATABASE_DBNAME"
  
  import_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run --quiet -i --rm -v \"${DB_DUMP}:/${DB_DUMP_BASENAME}\" database-cli bash -c \"$DB_IMPORT_CMD\""
  run_with_spinner "Importing database" "$import_cmd" || return $?
  
  msg_ok "Database imported successfully"
}

# Configure application URL interactively
configure_url_interactive() {
  local current_url="https://${DC_ORO_NAME}.docker.local"
  
  # Try to get current URL from Oro config
  if command -v jq >/dev/null 2>&1; then
    local url_from_config=$(${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:get oro_website.secure_url" 2>/dev/null | grep -v "^\s*$" | tail -1 | xargs || echo "")
    if [[ -n "$url_from_config" ]] && [[ "$url_from_config" != "null" ]]; then
      current_url="$url_from_config"
    fi
  fi
  
  echo "" >&2
  msg_header "Configure Application URL"
  echo "" >&2
  msg_info "Current URL: $current_url"
  echo "" >&2
  echo -n "Enter new application URL [default: https://${DC_ORO_NAME}.docker.local]: " >&2
  read -r new_url
  
  if [[ -z "$new_url" ]]; then
    new_url="https://${DC_ORO_NAME}.docker.local"
  fi
  
  # Validate URL format
  if [[ ! "$new_url" =~ ^https?:// ]]; then
    msg_error "URL must start with http:// or https://"
    return 1
  fi
  
  # Use existing updateurl logic
  URL="$new_url"
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:update oro_website.secure_url ${URL}" || true
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:update oro_ui.application_url ${URL}" || true
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:update oro_website.url ${URL}" || true
  
  msg_ok "Application URL updated to: $new_url"
}

# Platform update with service management
platform_update_interactive() {
  msg_header "Platform Update"
  echo "" >&2
  msg_info "Stopping application services..."
  
  # Stop application services but keep dependencies
  # Only stop services that exist in compose config (websocket/consumer are Oro-only)
  local services_to_stop=("fpm" "nginx" "websocket" "consumer")
  local available_services
  available_services=$(${DOCKER_COMPOSE_BIN_CMD} config --services 2>/dev/null || true)
  for service in "${services_to_stop[@]}"; do
    if echo "$available_services" | grep -q "^${service}$"; then
      ${DOCKER_COMPOSE_BIN_CMD} stop "$service" >/dev/null 2>&1 || true
    fi
  done
  
  msg_info "Running platform update..."
  
  # Clear cache and run update
  local update_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm cli bash -c \"rm -rf var/cache/* || true; php bin/console oro:platform:update --force\""
  run_with_spinner "Updating platform" "$update_cmd" || return $?
  
  msg_ok "Platform update completed"
  echo "" >&2
  
  if confirm_yes_no "Restart services?" "yes"; then
    msg_info "Restarting services..."
    ${DOCKER_COMPOSE_BIN_CMD} up -d >/dev/null 2>&1
    msg_ok "Services restarted"
  fi
}

# Run command and ask to return to menu
run_command_with_menu_return() {
  local cmd=("$@")

  # Run command
  "$0" "${cmd[@]}"
  local exit_code=$?

  echo "" >&2
  # Ask to return to menu
  if confirm_yes_no "Return to menu?" "yes"; then
    show_interactive_menu
  else
    exit $exit_code
  fi
}

# Show interactive menu
show_interactive_menu() {
  # Handle Ctrl+C gracefully
  trap 'echo ""; echo ""; msg_info "Goodbye!"; exit 0' SIGINT

  # Debug output
  if [[ -n "${DEBUG:-}" ]]; then
    echo "[DEBUG show_interactive_menu] PWD: $PWD" >&2
    echo "[DEBUG show_interactive_menu] DC_ORO_NAME: ${DC_ORO_NAME:-<not set>}" >&2
    echo "[DEBUG show_interactive_menu] DC_ORO_APPDIR: ${DC_ORO_APPDIR:-<not set>}" >&2
    echo "[DEBUG show_interactive_menu] DC_ORO_CONFIG_DIR: ${DC_ORO_CONFIG_DIR:-<not set>}" >&2
  fi

  # Auto-register current environment
  detect_current_environment

  # Scan and register other environments
  scan_and_register_environments

  # Clean up non-existent environments from registry
  cleanup_registry

  # Initialize Docker Compose variables for menu functions
  BREW_BIN=$(resolve_bin "brew")
  DOCKER_BIN=$(resolve_bin "docker")
  DOCKER_COMPOSE_BIN="$DOCKER_BIN compose"
  DOCKER_COMPOSE_BIN_CMD="$DOCKER_COMPOSE_BIN"

  # Initialize argument arrays as empty for menu functions
  left_flags=()
  left_options=()
  right_flags=()
  right_options=()

  # Get DIR for any operations that need it
  DIR=$("$BREW_BIN" --prefix docker-compose-oroplatform)/share/docker-compose-oroplatform

  # Build compose command with config files (needed for menu functions)
  if [[ -n "${DC_ORO_CONFIG_DIR:-}" ]] && [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose.yml" ]]; then
    DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose.yml"
  fi

  # Set DOCKER_COMPOSE_RUN_CMD after compose files are added
  DOCKER_COMPOSE_RUN_CMD="${DOCKER_COMPOSE_BIN_CMD} run --rm"

  # Initialize required environment variables to avoid warnings
  export DC_ORO_PORT_PREFIX=${DC_ORO_PORT_PREFIX:-"301"}
  # Build Traefik rule if not set
  if [[ -z "${DC_ORO_TRAEFIK_RULE:-}" ]]; then
    local traefik_rule="Host(\`${DC_ORO_NAME:-unnamed}.docker.local\`)"
    if [[ -n "${DC_ORO_EXTRA_HOSTS:-}" ]]; then
      IFS=',' read -ra HOSTS <<< "$DC_ORO_EXTRA_HOSTS"
      for host in "${HOSTS[@]}"; do
        host=$(echo "$host" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        if [[ -n "$host" ]]; then
          if [[ "$host" != *.* ]]; then
            host="$host.docker.local"
          fi
          traefik_rule="$traefik_rule || Host(\`$host\`)"
        fi
      done
    fi
    export DC_ORO_TRAEFIK_RULE="$traefik_rule"
  fi

  # Use batch port resolution for better performance
  if [[ -n "${DC_ORO_NAME:-}" ]] && [[ -n "${DC_ORO_CONFIG_DIR:-}" ]]; then
    BATCH_PORTS=$(orodc-find_free_port --batch ${DC_ORO_NAME} $DC_ORO_CONFIG_DIR \
      nginx "${DC_ORO_PORT_PREFIX}80" \
      xhgui "${DC_ORO_PORT_PREFIX}81" \
      database "${DC_ORO_PORT_PREFIX}06" \
      database "${DC_ORO_PORT_PREFIX}32" \
      search "${DC_ORO_PORT_PREFIX}92" \
      mq "${DC_ORO_PORT_PREFIX}72" \
      redis "${DC_ORO_PORT_PREFIX}79" \
      mail "${DC_ORO_PORT_PREFIX}25" \
      ssh "${DC_ORO_PORT_PREFIX}22" \
      gotenberg "${DC_ORO_PORT_PREFIX}00")

    # Parse batch results and export individual port variables
    while IFS=':' read -r service port; do
      case "$service" in
        nginx)
          export DC_ORO_PORT_NGINX="$port"
          ;;
        xhgui)
          export DC_ORO_PORT_XHGUI="$port"
          ;;
        database)
          if [[ -z "$DC_ORO_PORT_MYSQL" ]]; then
            export DC_ORO_PORT_MYSQL="$port"
          else
            export DC_ORO_PORT_PGSQL="$port"
          fi
          ;;
        search)
          export DC_ORO_PORT_SEARCH="$port"
          ;;
        mq)
          export DC_ORO_PORT_MQ="$port"
          ;;
        redis)
          export DC_ORO_PORT_REDIS="$port"
          ;;
        mail)
          export DC_ORO_PORT_MAIL_WEBGUI="$port"
          ;;
        ssh)
          export DC_ORO_PORT_SSH="$port"
          ;;
        gotenberg)
          export DC_ORO_PORT_GOTENBERG="$port"
          ;;
      esac
    done <<< "$BATCH_PORTS"
  fi

  local current_status=$(get_environment_status "${DC_ORO_NAME}" "$PWD")
  local status_display=""
  local is_registered=false

  # Check if environment is registered
  if [[ -n "${DC_ORO_NAME:-}" ]] && is_environment_registered "${DC_ORO_NAME}"; then
    is_registered=true
  fi

  if [[ "$current_status" == "running" ]]; then
    if [[ "$is_registered" == "true" ]]; then
      status_display="\033[32mrunning\033[0m"
    else
      status_display="\033[32mrunning\033[0m \033[33m(unregistered)\033[0m"
    fi
  elif [[ "$current_status" == "uninitialized" ]]; then
    status_display="\033[33muninitialized\033[0m"
  else
    if [[ "$is_registered" == "true" ]]; then
      status_display="\033[31mstopped\033[0m"
    else
      status_display="\033[31mstopped\033[0m \033[33m(unregistered)\033[0m"
    fi
  fi
  
  # Check if current project is Oro Platform based
  local is_oro=false
  if is_oro_project; then
    is_oro=true
  fi
  
  clear
  echo -e "\033[1;34m========================================\033[0m" >&2
  echo -e "\033[1;34m    OroDC Interactive Menu\033[0m" >&2
  echo -e "\033[1;34m========================================\033[0m" >&2
  echo "" >&2
  msg_info "Welcome to OroDC Interactive Menu!"
  msg_info "Manage your Application development environments easily."
  echo "" >&2
  echo "Select an option:" >&2
  echo "" >&2
  
  # Get terminal width, default to 80 if not available
  local term_width=${COLUMNS:-80}
  local use_two_columns=false
  if [[ $term_width -ge 100 ]]; then
    use_two_columns=true
  fi
  
  if [[ "$use_two_columns" == "true" ]]; then
    # Two column layout
    printf "  \033[1;36m%-30s\033[0m  \033[1;33m%-30s\033[0m\n" "Environment Management:" "Configuration:" >&2
    printf "  %-30s  %-30s\n" "  1) List all environments" "  7) Add/Manage domains" >&2
    printf "  %-30s  %-30s\n" "  2) Initialize environment" "  8) Configure URL" >&2
    printf "  %-30s  %-30s\n" "  3) Start environment" "" >&2
    printf "  %-30s  %-30s\n" "  4) Stop environment" "" >&2
    printf "  %-30s  %-30s\n" "  5) Delete environment" "" >&2
    printf "  %-30s  %-30s\n" "  6) Connect via SSH" "" >&2
    echo "" >&2
    printf "  \033[1;35m%-30s\033[0m  \033[1;32m%-30s\033[0m\n" "Database:" "Maintenance:" >&2
    printf "  %-30s  %-30s\n" "  9)  Export database" "  11) Clear cache" >&2
    if [[ "$is_oro" == "true" ]]; then
      printf "  %-30s  %-30s\n" "  10) Import database" "  12) Platform update" >&2
    else
      printf "  %-30s  %-30s\n" "  10) Import database" "" >&2
    fi
    printf "  %-30s  %-30s\n" "" "  13) Run doctor" >&2
    echo "" >&2
    if [[ "$is_oro" == "true" ]]; then
      printf "  \033[1;37m%-30s\033[0m  \033[1;31m%-30s\033[0m\n" "Other:" "Installation (Oro):" >&2
      printf "  %-30s  %-30s\n" "  14) Image build" "  17) Install with demo" >&2
      printf "  %-30s  %-30s\n" "  15) Start proxy" "  18) Install without demo" >&2
      printf "  %-30s  %-30s\n" "  16) Stop proxy" "" >&2
    else
      printf "  \033[1;37m%-30s\033[0m\n" "Other:" >&2
      printf "  %-30s\n" "  14) Image build" >&2
      printf "  %-30s\n" "  15) Start proxy" >&2
      printf "  %-30s\n" "  16) Stop proxy" >&2
    fi
  else
    # Single column layout (original)
    echo -e "\033[1;36mEnvironment Management:\033[0m" >&2
    echo "  1)  List all environments" >&2
    echo "  2)  Initialize environment and determine versions" >&2
    echo "  3)  Start environment in current folder" >&2
    echo "  4)  Stop environment" >&2
    echo "  5)  Delete environment" >&2
    echo "  6)  Connect via SSH" >&2
    echo "" >&2
    echo -e "\033[1;33mConfiguration:\033[0m" >&2
    echo "  7)  Add/Manage domains" >&2
    echo "  8)  Configure application URL" >&2
    echo "" >&2
    echo -e "\033[1;35mDatabase:\033[0m" >&2
    echo "  9)  Export database" >&2
    echo "  10) Import database" >&2
    echo "" >&2
    echo -e "\033[1;32mMaintenance:\033[0m" >&2
    echo "  11) Clear cache" >&2
    if [[ "$is_oro" == "true" ]]; then
      echo "  12) Platform update" >&2
    fi
    echo "  13) Run doctor (show ps)" >&2
    echo "" >&2
    echo -e "\033[1;37mOther:\033[0m" >&2
    echo "  14) Image build" >&2
    echo "  15) Start proxy" >&2
    echo "  16) Stop proxy" >&2
    if [[ "$is_oro" == "true" ]]; then
      echo "" >&2
      echo -e "\033[1;31mInstallation (Oro):\033[0m" >&2
      echo "  17) Install with demo data" >&2
      echo "  18) Install without demo data" >&2
    fi
  fi
  
  echo "" >&2
  # Show current environment or "-" if not in a project
  local env_display="${DC_ORO_NAME:--}"
  if [[ "$env_display" != "-" ]]; then
    echo -e "Current Environment: \033[1m${env_display}\033[0m ($status_display)" >&2
  else
    echo -e "Current Environment: \033[1m-\033[0m (\033[33mnot in project\033[0m)" >&2
  fi

  # Use DC_ORO_APPDIR if set, otherwise PWD if in project, otherwise "-"
  local display_dir="${DC_ORO_APPDIR:-}"
  if [[ -z "$display_dir" ]]; then
    if [[ -n "${DC_ORO_NAME:-}" ]]; then
      # We're in a project but DC_ORO_APPDIR not set yet, use PWD
      display_dir="$(realpath "$(pwd)" 2>/dev/null || pwd)"
    else
      display_dir="-"
    fi
  fi

  if [[ "$display_dir" == "-" ]]; then
    echo -e "Current Directory: \033[2m-\033[0m" >&2
  else
    echo -e "Current Directory: $display_dir" >&2
  fi
  if [[ "$is_oro" == "true" ]]; then
    echo -e "Project Type: \033[1;32mOro Platform\033[0m" >&2
  else
    echo -e "Project Type: \033[1;33mGeneric PHP/Symfony\033[0m" >&2
  fi
  echo "" >&2
  if [[ "$is_oro" == "true" ]]; then
    echo -n "Enter option [1-18] or 'q' to quit: " >&2
  else
    echo -n "Enter option [1-16] or 'q' to quit: " >&2
  fi
  read -r choice
  
  case "$choice" in
    1)
      list_environments
      local list_result=$?
      # If list_environments switched directory, it will exec the script itself
      # So we only get here if no switch happened
      if [[ $list_result -ne 2 ]]; then
        echo "" >&2
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
      fi
      ;;
    2)
      echo "" >&2
      # Call init command
      run_command_with_menu_return init
      ;;
    3)
      echo "" >&2
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      # Call up command
      run_command_with_menu_return up -d
      ;;
    4)
      echo "" >&2
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      # Call down command
      run_command_with_menu_return down
      ;;
    5)
      echo "" >&2
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      if confirm_yes_no "Are you sure you want to delete this environment? This will purge all data and remove config directory." "no"; then
        run_command_with_menu_return purge --yes
        echo "" >&2
        
        # Remove config directory
        if [[ -n "${DC_ORO_CONFIG_DIR:-}" ]] && [[ -d "${DC_ORO_CONFIG_DIR}" ]]; then
          msg_info "Removing config directory: ${DC_ORO_CONFIG_DIR}"
          rm -rf "${DC_ORO_CONFIG_DIR}" 2>/dev/null && msg_ok "Config directory removed" || msg_warning "Failed to remove config directory"
        fi
        
        msg_ok "Environment deleted successfully"
        echo "" >&2
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
      else
        show_interactive_menu
      fi
      ;;
    6)
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      # Call ssh command
      run_command_with_menu_return ssh
      ;;
    7)
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      manage_domains
      echo "" >&2
      if confirm_yes_no "Return to menu?" "yes"; then
        show_interactive_menu
      else
        exit 0
      fi
      ;;
    8)
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      configure_url_interactive
      echo "" >&2
      if confirm_yes_no "Return to menu?" "yes"; then
        show_interactive_menu
      else
        exit 0
      fi
      ;;
    9)
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      export_database_interactive
      echo "" >&2
      if confirm_yes_no "Return to menu?" "yes"; then
        show_interactive_menu
      else
        exit 0
      fi
      ;;
    10)
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      import_database_interactive
      echo "" >&2
      if confirm_yes_no "Return to menu?" "yes"; then
        show_interactive_menu
      else
        exit 0
      fi
      ;;
    11)
      echo "" >&2
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      # Call cache clear command
      run_command_with_menu_return cache clear
      ;;
    12)
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      if ! is_oro_project; then
        msg_warning "Platform update is only available for Oro Platform projects"
        echo "" >&2
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      platform_update_interactive
      echo "" >&2
      if confirm_yes_no "Return to menu?" "yes"; then
        show_interactive_menu
      else
        exit 0
      fi
      ;;
    13)
      echo "" >&2
      msg_header "Environment Status"
      echo "" >&2
      # Ensure Docker Compose command is initialized
      local docker_cmd="${DOCKER_BIN:-docker}"
      local compose_cmd="${docker_cmd} compose"

      # Show only container name and status
      printf "%-40s %-15s\n" "CONTAINER" "STATUS" >&2
      printf "%-40s %-15s\n" "----------------------------------------" "---------------" >&2

      local output_file=$(mktemp)

      # Build compose command
      local compose_ps_cmd="${compose_cmd}"
      if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose.yml" ]]; then
        compose_ps_cmd="${compose_ps_cmd} -f ${DC_ORO_CONFIG_DIR}/docker-compose.yml"
      fi
      compose_ps_cmd="${compose_ps_cmd} -p ${DC_ORO_NAME}"

      # Try JSON format first (more reliable)
      local ps_output=$(${compose_ps_cmd} ps --format json 2>&1 | grep -v "WARN\[0000\]" || true)

      if command -v jq >/dev/null 2>&1 && echo "$ps_output" | jq -e '. | length > 0' >/dev/null 2>&1; then
        # Parse JSON output and write to file
        echo "$ps_output" | jq -r '.[] | "\(.Name)\t\(.State)"' 2>/dev/null > "$output_file"
      else
        # Fallback: use table format
        ${compose_ps_cmd} ps --format "table {{.Name}}\t{{.State}}" 2>&1 | grep -v "WARN\[0000\]" | tail -n +2 > "$output_file" || true
      fi

      # Display results from file
      local has_output=false
      if [[ -s "$output_file" ]]; then
        while IFS=$'\t' read -r name state; do
          if [[ -n "$name" ]] && [[ "$name" != "NAME" ]] && [[ "$name" != "null" ]] && [[ "$name" != "" ]]; then
            printf "%-40s %-15s\n" "$name" "$state" >&2
            has_output=true
          fi
        done < "$output_file"
      fi

      rm -f "$output_file"

      if [[ "$has_output" == "false" ]]; then
        msg_info "No containers found for this environment."
        msg_info "Start the environment with option 3 to see containers here."
      fi

      echo "" >&2
      echo -n "Press Enter to continue..." >&2
      read -r
      show_interactive_menu
      ;;
    14)
      echo "" >&2
      msg_info "Image build - rebuild or pull PHP images"
      echo "" >&2
      if confirm_yes_no "Build images with cache?" "yes"; then
        run_command_with_menu_return image build
      else
        if confirm_yes_no "Build images without cache (full rebuild)?" "no"; then
          run_command_with_menu_return image build --no-cache
        else
          show_interactive_menu
        fi
      fi
      ;;
    15)
      echo "" >&2
      msg_info "Starting proxy..."
      run_command_with_menu_return proxy up -d
      ;;
    16)
      echo "" >&2
      if confirm_yes_no "Are you sure you want to stop the proxy?" "no"; then
        msg_info "Stopping proxy..."
        run_command_with_menu_return proxy down
      else
        show_interactive_menu
      fi
      ;;
    17)
      echo "" >&2
      if ! is_oro_project; then
        msg_warning "Oro installation is only available for Oro Platform projects"
        echo "" >&2
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      msg_warning "WARNING: This will PURGE all existing data (database, cache, volumes) and reinstall!"
      echo "" >&2
      if confirm_yes_no "Install Application WITH demo data? (purge + install)" "no"; then
        msg_info "Starting fresh installation with demo data..."
        msg_info "Step 1: Purging existing environment..."
        echo "" >&2
        "$0" purge --yes 2>&1 || true
        echo "" >&2
        msg_info "Step 2: Running installation (this may take 5-30 minutes depending on hardware)..."
        echo "" >&2
        run_command_with_menu_return install with demo
      else
        show_interactive_menu
      fi
      ;;
    18)
      echo "" >&2
      if ! is_oro_project; then
        msg_warning "Oro installation is only available for Oro Platform projects"
        echo "" >&2
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      msg_warning "WARNING: This will PURGE all existing data (database, cache, volumes) and reinstall!"
      echo "" >&2
      if confirm_yes_no "Install Application WITHOUT demo data? (purge + install)" "no"; then
        msg_info "Starting fresh installation without demo data..."
        msg_info "Step 1: Purging existing environment..."
        echo "" >&2
        "$0" purge --yes 2>&1 || true
        echo "" >&2
        msg_info "Step 2: Running installation (this may take 5-30 minutes depending on hardware)..."
        echo "" >&2
        run_command_with_menu_return install without demo
      else
        show_interactive_menu
      fi
      ;;
    q|Q)
      echo "" >&2
      msg_info "Goodbye!"
      exit 0
      ;;
    *)
      echo "" >&2
      msg_error "Invalid option: $choice"
      echo "" >&2
      echo -n "Press Enter to continue..." >&2
      read -r
      show_interactive_menu
      ;;
  esac
}

# Function to resolve binary location with error handling
# Usage: resolve_bin "binary_name" ["install_instructions"]
resolve_bin() {
  local bin_name="$1"
  local install_msg="${2:-}"
  local found_path=""
  
  # Try PATH first
  if command -v "$bin_name" >/dev/null 2>&1; then
    found_path=$(command -v "$bin_name")
    if [ "$DEBUG" ]; then echo "DEBUG: Found $bin_name in PATH: $found_path" >&2; fi
    echo "$found_path"
    return 0
  fi
  
  # Try common locations for specific binaries
  case "$bin_name" in
    "brew")
      local brew_paths=("/opt/homebrew/bin/brew" "/usr/local/bin/brew" "/home/linuxbrew/.linuxbrew/bin/brew")
      for brew_path in "${brew_paths[@]}"; do
        if [[ -x "$brew_path" ]]; then
          found_path="$brew_path"
          msg_warning "$bin_name found at $found_path but not in PATH"
          echo "   Add to PATH: export PATH=\"$(dirname "$found_path"):\$PATH\"" >&2
          echo "$found_path"
          return 0
        fi
      done
      ;;
    "docker")
      local docker_paths=("/usr/bin/docker" "/usr/local/bin/docker" "/snap/bin/docker")
      for docker_path in "${docker_paths[@]}"; do
        if [[ -x "$docker_path" ]]; then
          found_path="$docker_path"
          msg_warning "$bin_name found at $found_path but not in PATH"
          echo "$found_path"
          return 0
        fi
      done
      ;;
  esac
  
  # Not found - show error and exit
  msg_error "$bin_name not found in PATH or common locations"
  
  if [[ -n "$install_msg" ]]; then
    echo "   $install_msg"
  else
    # Default install instructions
    case "$bin_name" in
      "docker")
        echo "   Install: curl -fsSL https://get.docker.com | sh"
        echo "   Or visit: https://docs.docker.com/engine/install/"
        ;;
      "brew")
        echo "   Install: /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
        echo "   Then add to PATH: export PATH=\"/home/linuxbrew/.linuxbrew/bin:\$PATH\""
        ;;
      "rsync")
        echo "   Install: sudo apt-get install rsync  # Ubuntu/Debian"
        echo "   Or: brew install rsync"
        ;;
      "jq")
        echo "   Install: sudo apt-get install jq  # Ubuntu/Debian"
        echo "   Or: brew install jq"
        ;;
      *)
        echo "   Please install $bin_name and ensure it's in your PATH"
        ;;
    esac
  fi
  
  echo
  msg_error "OroDC cannot continue without $bin_name"
  exit 1
}
echo_highlight() { msg_highlight "$*"; }

# Save original arguments before any processing
original_args=("$@")

left_flags=()
right_flags=()
left_options=()
right_options=()
args=()

args_input=("$@")

# Save and load XDEBUG_MODE* environment variables
# Use realpath to ensure we have absolute path (important after menu switch)
export PWD=$(realpath "$(pwd)" 2>/dev/null || pwd)
# Use selected environment name if available (from menu switch), otherwise use basename
# Compare using realpath to handle symlinks and relative paths
current_pwd=$(realpath "$(pwd)" 2>/dev/null || pwd)
selected_path_normalized=$(realpath "${DC_ORO_SELECTED_ENV_PATH:-}" 2>/dev/null || echo "${DC_ORO_SELECTED_ENV_PATH:-}")

debug_log "Script start: PWD='$PWD' current_pwd='$current_pwd'"
debug_log "Script start: DC_ORO_SELECTED_ENV_NAME='${DC_ORO_SELECTED_ENV_NAME:-<not set>}' PATH='${DC_ORO_SELECTED_ENV_PATH:-<not set>}' CONFIG='${DC_ORO_SELECTED_ENV_CONFIG:-<not set>}'"

# CRITICAL: Always set SCRIPT_DIR and LIBEXEC_DIR first (needed for source commands)
# Homebrew installation - resolve symlink to find actual script location
# BASH_SOURCE may be a symlink (e.g. bin/orodc -> libexec/orodc-main)
REAL_SCRIPT="$(realpath "${BASH_SOURCE[0]}" 2>/dev/null || readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(cd "$(dirname "$REAL_SCRIPT")" && pwd)"
LIBEXEC_DIR="${SCRIPT_DIR}/orodc"

if [[ -n "${DC_ORO_SELECTED_ENV_NAME:-}" ]] && [[ -n "${DC_ORO_SELECTED_ENV_PATH:-}" ]]; then
  debug_log "Script start: Processing DC_ORO_SELECTED_ENV_* variables"

  # Debug output if DEBUG is set
  if [[ -n "${DEBUG:-}" ]]; then
    echo "[DEBUG] DC_ORO_SELECTED_ENV_NAME: ${DC_ORO_SELECTED_ENV_NAME}" >&2
    echo "[DEBUG] DC_ORO_SELECTED_ENV_PATH: ${DC_ORO_SELECTED_ENV_PATH}" >&2
    echo "[DEBUG] current_pwd: $current_pwd" >&2
    echo "[DEBUG] selected_path_normalized: $selected_path_normalized" >&2
    echo "[DEBUG] Comparison: '$current_pwd' == '$selected_path_normalized'" >&2
  fi
  
  # Check if we're in the selected directory (with tolerance for path variations)
  if [[ "$current_pwd" == "$selected_path_normalized" ]]; then
    debug_log "Script start: Paths match - setting DC_ORO_NAME='${DC_ORO_SELECTED_ENV_NAME}' DC_ORO_APPDIR='${DC_ORO_SELECTED_ENV_PATH}'"
    export DC_ORO_NAME="${DC_ORO_SELECTED_ENV_NAME}"
    if [[ -n "${DC_ORO_SELECTED_ENV_CONFIG:-}" ]]; then
      export DC_ORO_CONFIG_DIR="${DC_ORO_SELECTED_ENV_CONFIG}"
    else
      export DC_ORO_CONFIG_DIR="$HOME/.$(basename $0)/${DC_ORO_NAME}"
    fi
    # Set DC_ORO_APPDIR to the selected path to ensure correct project directory
    export DC_ORO_APPDIR="${DC_ORO_SELECTED_ENV_PATH}"
    # Clear selection variables after use
    unset DC_ORO_SELECTED_ENV_NAME
    unset DC_ORO_SELECTED_ENV_PATH
    unset DC_ORO_SELECTED_ENV_CONFIG
  else
    # If paths don't match, we might need to cd first
    # This can happen if exec didn't preserve the directory change
    if [[ -d "$selected_path_normalized" ]]; then
      debug_log "Script start: Paths don't match - cd to '$selected_path_normalized'"
      if [[ -n "${DEBUG:-}" ]]; then
        echo "[DEBUG] Paths don't match, changing directory to: $selected_path_normalized" >&2
      fi
      cd "$selected_path_normalized" || true
      export PWD=$(realpath "$(pwd)" 2>/dev/null || pwd)
      debug_log "Script start: After cd - PWD='$PWD' setting DC_ORO_NAME='${DC_ORO_SELECTED_ENV_NAME}' DC_ORO_APPDIR='${DC_ORO_SELECTED_ENV_PATH}'"
      export DC_ORO_NAME="${DC_ORO_SELECTED_ENV_NAME}"
      if [[ -n "${DC_ORO_SELECTED_ENV_CONFIG:-}" ]]; then
        export DC_ORO_CONFIG_DIR="${DC_ORO_SELECTED_ENV_CONFIG}"
      else
        export DC_ORO_CONFIG_DIR="$HOME/.$(basename $0)/${DC_ORO_NAME}"
      fi
      export DC_ORO_APPDIR="${DC_ORO_SELECTED_ENV_PATH}"
      # Clear selection variables after use
      unset DC_ORO_SELECTED_ENV_NAME
      unset DC_ORO_SELECTED_ENV_PATH
      unset DC_ORO_SELECTED_ENV_CONFIG
    fi
  fi
fi
# Export SCRIPT_DIR so sourced libraries can use it to find orodc-find_free_port
export SCRIPT_DIR

# Source all library files
source "${LIBEXEC_DIR}/lib/ui.sh"
source "${LIBEXEC_DIR}/lib/common.sh"
source "${LIBEXEC_DIR}/lib/port-manager.sh"
source "${LIBEXEC_DIR}/lib/docker-utils.sh"
source "${LIBEXEC_DIR}/lib/environment.sh"

# Early detection of first non-flag argument for special commands
# This is needed before full argument parsing for docker-build and image commands
temp_first_non_flag_arg=""
for arg in "$@"; do
  if [[ "$arg" != -* ]]; then
    temp_first_non_flag_arg="$arg"
    break
  fi
done

# Handle version command (only "version", not --version)
if [[ "$1" == "version" ]]; then
  # Try to find and read version from Formula file
  FORMULA_VERSION=""
  FORMULA_FILE=""

  # Use find to locate Formula file, starting from script directory and going up
  # First try relative to script directory (for development)
  FORMULA_FILE=$(find "$SCRIPT_DIR" -name "docker-compose-oroplatform.rb" -type f 2>/dev/null | head -1)

  # If not found, try going up from script directory (for tap development)
  if [[ -z "$FORMULA_FILE" ]]; then
    SEARCH_DIR="$SCRIPT_DIR"
    while [[ "$SEARCH_DIR" != "/" ]] && [[ -z "$FORMULA_FILE" ]]; do
      FORMULA_FILE=$(find "$SEARCH_DIR" -maxdepth 2 -name "docker-compose-oroplatform.rb" -type f 2>/dev/null | head -1)
      SEARCH_DIR=$(dirname "$SEARCH_DIR")
    done
  fi

  # If not found relative to script, try brew repository
  if [[ -z "$FORMULA_FILE" ]] && command -v brew >/dev/null 2>&1; then
    BREW_REPO=$(brew --repository 2>/dev/null)
    if [[ -n "$BREW_REPO" ]]; then
      FORMULA_FILE=$(find "$BREW_REPO" -name "docker-compose-oroplatform.rb" -type f 2>/dev/null | head -1)
    fi
  fi

  # Extract version from Formula file
  if [[ -n "$FORMULA_FILE" && -f "$FORMULA_FILE" ]]; then
    FORMULA_VERSION=$(grep -o 'version "[^"]*"' "$FORMULA_FILE" 2>/dev/null | sed 's/version "\(.*\)"/\1/')
  fi

  # Output version or fallback
  if [[ -n "$FORMULA_VERSION" ]]; then
    echo "orodc version $FORMULA_VERSION"
  else
    echo "orodc version unknown (formula file not found)"
  fi
  exit 0
fi

# Handle help/man command
if [[ "$1" == "help" ]] || [[ "$1" == "man" ]]; then
  # Try to find README.md file
  README_FILE=""

  # Look for README.md in various locations
  # 1. Relative to script directory (development)
  if [[ -f "$SCRIPT_DIR/../README.md" ]]; then
    README_FILE="$SCRIPT_DIR/../README.md"
  elif [[ -f "$SCRIPT_DIR/README.md" ]]; then
    README_FILE="$SCRIPT_DIR/README.md"
  elif [[ -f "$SCRIPT_DIR/../../README.md" ]]; then
    README_FILE="$SCRIPT_DIR/../../README.md"
  fi

  # 2. Try to find in Homebrew tap directory
  if [[ -z "$README_FILE" ]] && command -v brew >/dev/null 2>&1; then
    BREW_REPO=$(brew --repository 2>/dev/null)
    if [[ -n "$BREW_REPO" ]]; then
      TAP_README="$BREW_REPO/Library/Taps/digitalspacestdio/homebrew-docker-compose-oroplatform/README.md"
      if [[ -f "$TAP_README" ]]; then
        README_FILE="$TAP_README"
      fi
    fi
  fi

  # If README found, display it without pager (always use cat)
  if [[ -n "$README_FILE" && -f "$README_FILE" ]]; then
    echo "==> OroDC Documentation"
    echo
    cat "$README_FILE"
  else
    echo "==> OroDC Help"
    echo
    msg_highlight "Documentation not found locally. Please visit:"
    echo "   https://github.com/digitalspacestdio/homebrew-docker-compose-oroplatform"
    echo
    msg_highlight "Quick Commands:"
    echo "   orodc version                    # Show version"
    echo "   orodc install && orodc up -d     # Setup and start"
    echo "   orodc --version                  # Check PHP version"
    echo "   orodc psql -l                    # List databases"
    echo "   orodc tests install              # Setup test environment"
    echo "   orodc config-refresh             # Clear cached configs and force resync"
    echo
    echo " For full documentation, run: brew info docker-compose-oroplatform"
  fi
  exit 0
fi

# Initialize environment for most commands
# Skip for: help, version, proxy, image, init (these don't require project)
case "$1" in
  help|man|version|proxy|image|docker-build|init|status|agents)
    # Skip initialization for these commands
    # init: creates project, so doesn't need existing project
    # status: read-only command, should not initialize or create files
    # agents: documentation-only, has own project detection logic
    ;;
  codex|gemini|cursor)
    # Codex/Gemini/Cursor need project context but should work gracefully without project
    # These commands use prepare_project_environment from their own scripts
    # which doesn't require full initialize_environment (avoids starting Docker Compose)
    # All three agents (codex.sh, gemini.sh, cursor.sh) use prepare_project_environment
    # which only loads config and detects CMS type, without starting Docker services
    ;;
  *)
    # Initialize environment for all other commands (including menu when no args)
    # For menu, allow initialization to fail gracefully if not in project
    if [[ $# -eq 0 ]]; then
      # Menu case - try to initialize but don't fail if not in project
      initialize_environment 2>/dev/null || true
    else
      # Regular command - require initialization
      initialize_environment
    fi
    ;;
esac

# ============================================================================
# GLOBAL PROJECT VALIDATION
# Load validation library and run project validation
# ============================================================================
if [[ -f "${SCRIPT_DIR}/../libexec/orodc/lib/validation.sh" ]]; then
  source "${SCRIPT_DIR}/../libexec/orodc/lib/validation.sh"
  validate_project "$1"
fi

# Handle VERBOSE toggle command
if [[ "$1" == "v" ]] || [[ "$1" == "verbose" ]]; then
  if [[ -n "${VERBOSE:-}" ]]; then
    unset VERBOSE
    echo "VERBOSE mode disabled"
  else
    export VERBOSE=1
    echo "VERBOSE mode enabled"
  fi
  exit 0
fi

# Show interactive menu when no arguments provided
if [[ $# -eq 0 ]]; then
  exec "${LIBEXEC_DIR}/menu.sh"
fi

# Store original command for menu return
ORIGINAL_CMD="$1"

# Helper function to execute command and return to menu if needed
# This ensures menu reflects 1:1 command line behavior - commands execute
# exactly as they would from command line, only difference is return to menu
execute_with_menu_return() {
  local script="$1"
  shift
  
  # Temporarily disable set -e to capture exit code
  set +e
  
  # Execute the script exactly as it would be executed from command line
  "$script" "$@"
  local exit_code=$?
  
  # Re-enable set -e
  set -e
  
  # Always add empty line after command execution
  echo "" >&2
  
  # If DC_ORO_IS_INTERACTIVE_MENU is set, return to menu after command
  # No additional output or processing - just return to menu
  if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
    echo -n "Press Enter to continue..." >&2
    read -r
    exec "${LIBEXEC_DIR}/menu.sh"
  fi
  
  exit $exit_code
}

# Route commands to appropriate modules
case "$1" in
  # Docker Compose commands - route to compose.sh module
  compose)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/compose.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/compose.sh" "$@"
    fi
    ;;

  # Database commands - route to database/*.sh modules
  database|db)
    shift
    case "$1" in
      mysql)
        shift
        if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
          execute_with_menu_return "${LIBEXEC_DIR}/database/mysql.sh" "$@"
        else
          exec "${LIBEXEC_DIR}/database/mysql.sh" "$@"
        fi
        ;;
      psql)
        shift
        if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
          execute_with_menu_return "${LIBEXEC_DIR}/database/psql.sh" "$@"
        else
          exec "${LIBEXEC_DIR}/database/psql.sh" "$@"
        fi
        ;;
      import)
        shift
        if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
          execute_with_menu_return "${LIBEXEC_DIR}/database/import.sh" "$@"
        else
          exec "${LIBEXEC_DIR}/database/import.sh" "$@"
        fi
        ;;
      export)
        shift
        if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
          execute_with_menu_return "${LIBEXEC_DIR}/database/export.sh" "$@"
        else
          exec "${LIBEXEC_DIR}/database/export.sh" "$@"
        fi
        ;;
      cli)
        shift
        if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
          execute_with_menu_return "${LIBEXEC_DIR}/database/cli.sh" "$@"
        else
          exec "${LIBEXEC_DIR}/database/cli.sh" "$@"
        fi
        ;;
      purge)
        shift
        if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
          execute_with_menu_return "${LIBEXEC_DIR}/database/purge.sh" "$@"
        else
          exec "${LIBEXEC_DIR}/database/purge.sh" "$@"
        fi
        ;;
      *)
        msg_error "Unknown database command: ${1:-<none>}"
        msg_info "Available: mysql, psql, import, export, cli, purge"
        exit 1
        ;;
    esac
    exit 0
    ;;

  # Docker build command - route early to avoid project initialization
  docker-build)
    shift
    exec "${LIBEXEC_DIR}/docker-build.sh" "$@"
    ;;
esac

# Check if a command is a docker compose command
is_compose_command() {
  local cmd="$1"
  case "$cmd" in
    up|down|start|stop|restart|exec|run|build|pull|push|logs|ps|top|config|kill|rm|create|pause|unpause|port|images|events|wait|ls|scale|version)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

# Check if we need argument parsing
# Parse for docker compose commands OR commands with docker compose flags
has_docker_compose_flags=false
for arg in "$@"; do
  if [[ "$arg" =~ ^--profile(=.*)?$ ]] || [[ "$arg" =~ ^--env-file(=.*)?$ ]] || [[ "$arg" =~ ^--project-name(=.*)?$ ]] || [[ "$arg" =~ ^--file(=.*)?$ ]] || [[ "$arg" =~ ^-f$ ]]; then
    has_docker_compose_flags=true
    if [ "$DEBUG" ]; then echo "DEBUG: Found docker compose flag: $arg" >&2; fi
    break
  fi
done

if [ "$DEBUG" ]; then echo "DEBUG: has_docker_compose_flags=$has_docker_compose_flags, temp_first_non_flag_arg=$temp_first_non_flag_arg" >&2; fi

if [[ $# -gt 0 ]] && (is_compose_command "$temp_first_non_flag_arg" || [[ "$temp_first_non_flag_arg" == "purge" ]] || [[ "$temp_first_non_flag_arg" == "php" ]] || [[ "$has_docker_compose_flags" == "true" ]]); then
  NEEDS_ARG_PARSING=true
  if [ "$DEBUG" ]; then echo "DEBUG: NEEDS_ARG_PARSING=true" >&2; fi
else
  NEEDS_ARG_PARSING=false
  if [ "$DEBUG" ]; then echo "DEBUG: NEEDS_ARG_PARSING=false" >&2; fi
  # Save original arguments for non-compose commands
  non_compose_args=("$@")
fi




# Only parse arguments for docker compose commands or commands with docker compose flags
if [[ "$NEEDS_ARG_PARSING" == "true" ]]; then
  i=0
  saw_first_arg=false
  
  # Special case: if first argument is 'php' OR no non-flag arguments, treat all flags as right flags
  if [ "$DEBUG" ]; then echo "DEBUG: Checking special case: args_input[0]='${args_input[0]:-}', temp_first_non_flag_arg='$temp_first_non_flag_arg'" >&2; fi
  if [[ ${#args_input[@]} -gt 0 && "${args_input[0]}" == "php" ]] || [[ "$temp_first_non_flag_arg" == "php" ]]; then
    if [ "$DEBUG" ]; then echo "DEBUG: Setting saw_first_arg=true for PHP command" >&2; fi
    saw_first_arg=true
  fi

  while [[ $i -lt ${#args_input[@]} ]]; do
    arg="${args_input[$i]}"
    next="${args_input[$((i + 1))]:-}"

    if [[ "$arg" == --*=* ]]; then
      [[ -n "${DEBUG:-}" ]] && echo "DEBUG: Found --*=* flag: $arg, saw_first_arg=$saw_first_arg" >&2
      if [[ "$saw_first_arg" == false ]]; then
        left_options+=("$arg")
      else
        right_options+=("$arg")
      fi
      i=$((i + 1))

    elif [[ "$arg" == --* && "$next" != -* && -n "$next" ]]; then
      if [[ "$saw_first_arg" == false ]]; then
        left_options+=("$arg" "$next")
      else
        right_options+=("$arg" "$next")
      fi
      i=$((i + 2))

    elif [[ "$arg" == -* ]]; then
      if [[ "$saw_first_arg" == false ]]; then
        left_flags+=("$arg")
      else
        right_flags+=("$arg")
      fi
      i=$((i + 1))

    else
      args+=("$arg")
      saw_first_arg=true
      i=$((i + 1))
    fi
  done
  # Get first non-flag argument for command detection (after args is properly set)
  first_non_flag_arg=$(get_first_non_flag_arg "${args[@]}")
else
  # For non-compose commands, set args to original arguments without parsing
  args=("${non_compose_args[@]}")
  # Get first non-flag argument for command detection (after args is properly set)
  first_non_flag_arg=$(get_first_non_flag_arg "${args[@]}")
fi

# Ensure first_non_flag_arg is always set regardless of parsing mode
if [[ -z "${first_non_flag_arg:-}" ]]; then
  first_non_flag_arg=$(get_first_non_flag_arg "${args[@]}")
fi

if [[ -n "${DEBUG:-}" ]]; then
  echo "DEBUG: first_non_flag_arg='$first_non_flag_arg', args=(${args[*]})" >&2
fi


# Resolve critical dependencies with helpful error messages
BREW_BIN=$(resolve_bin "brew")
DOCKER_BIN=$(resolve_bin "docker")

# Check docker compose specifically (it's a subcommand, not a separate binary)
if ! "$DOCKER_BIN" compose version >/dev/null 2>&1; then
  msg_error "Docker Compose not found or outdated"
  echo "   Docker Compose V2 is required (docker compose, not docker-compose)"
  echo "   Update Docker: https://docs.docker.com/compose/install/"
  echo
  msg_error "OroDC cannot continue without Docker Compose"
  exit 1
fi

# Set up Homebrew environment if needed
if [[ "$BREW_BIN" != *"/usr/local/bin/brew"* ]] && [[ "$BREW_BIN" != *"/opt/homebrew/bin/brew"* ]]; then
  # For non-standard locations, ensure environment is set up
  eval "$("$BREW_BIN" shellenv)" 2>/dev/null || true
fi

DIR=$("$BREW_BIN" --prefix docker-compose-oroplatform)/share/docker-compose-oroplatform

# Try to get rsync from Homebrew, fallback to system rsync
RSYNC_BIN="$("$BREW_BIN" --prefix rsync)/bin/rsync"
if [[ ! -x "$RSYNC_BIN" ]]; then
  RSYNC_BIN=$(resolve_bin "rsync")
fi

# Set up Docker Compose command
DOCKER_COMPOSE_BIN="$DOCKER_BIN compose"
# DOCKER_COMPOSE_BIN_CMD is the main command that gets built up with compose files  
# This variable is reused throughout the script and in the test merging logic
DOCKER_COMPOSE_BIN_CMD="$DOCKER_COMPOSE_BIN"
DOCKER_COMPOSE_VERSION=$($DOCKER_COMPOSE_BIN_CMD version | grep -E '[0-9]+\.[0-9]+\.[0-9]+' -o | head -1 |awk -F. '{ print $1 }')

# Note: Compose files sync moved to initialize_environment (libexec/orodc/lib/environment.sh)
# This ensures DC_ORO_CONFIG_DIR is properly set before rsync runs

# Setup certificates synchronization
setup_project_certificates() {
  local project_crt_dir="${PWD}/.crt"
  local build_crt_dir="${DC_ORO_CONFIG_DIR}/docker/project-php-node-symfony/.crt"
  
  # Remove old certificates directory
  rm -rf "${build_crt_dir}"
  
  # Check if project has certificates
  if [[ -d "${project_crt_dir}" ]]; then
    local cert_count=$(find "${project_crt_dir}" -type f \( -name "*.crt" -o -name "*.pem" \) 2>/dev/null | wc -l)
    
    if [[ "${cert_count}" -gt 0 ]]; then
      msg_info "Found ${cert_count} certificate(s) in ${project_crt_dir}"
      echo "   Preparing project build context with custom certificates..."
      
      # Create .crt directory in build context
      mkdir -p "${build_crt_dir}"
      
      # Copy certificates to build context
      find "${project_crt_dir}" -type f \( -name "*.crt" -o -name "*.pem" \) -exec cp {} "${build_crt_dir}/" \;
      
      msg_ok "Certificates prepared for Docker build"
    else
      msg_info ".crt directory exists but contains no certificate files"
    fi
  else
    # Skip certificate message - building standard image silently
    true
  fi
}

# Call certificates setup after compose files are synced
setup_project_certificates
# Build the compose command by adding compose files in the correct order
# This logic is reused in test merging - DO NOT duplicate this logic elsewhere
if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose.yml" ]]; then
  DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose.yml"
fi

# Profile caching functions
save_profiles() {
  local profiles=()
  local cli_profiles=()
  local i=0
  
  # Extract --profile arguments from left_flags and left_options
  while [[ $i -lt ${#left_flags[@]} ]]; do
    if [[ "${left_flags[$i]}" == --profile=* ]]; then
      local profile_value="${left_flags[$i]#--profile=}"
      if [[ "$profile_value" == "database-cli" ]] || [[ "$profile_value" == "php-cli" ]]; then
        cli_profiles+=("${left_flags[$i]}")
      else
        profiles+=("${left_flags[$i]}")
      fi
    fi
    i=$((i + 1))
  done
  
  i=0
  while [[ $i -lt ${#left_options[@]} ]]; do
    if [[ "${left_options[$i]}" == "--profile" ]]; then
      local profile_value="${left_options[$((i + 1))]}"
      if [[ "$profile_value" == "database-cli" ]] || [[ "$profile_value" == "php-cli" ]]; then
        cli_profiles+=("--profile" "$profile_value")
      else
        profiles+=("--profile" "$profile_value")
      fi
      i=$((i + 2))
    else
      i=$((i + 1))
    fi
  done
  
  # Save regular profiles to cache file
  if [[ ${#profiles[@]} -gt 0 ]]; then
    printf '%s\n' "${profiles[@]}" > "${DC_ORO_CONFIG_DIR}/.cached_profiles"
  else
    # Remove cache file if no profiles
    [[ -f "${DC_ORO_CONFIG_DIR}/.cached_profiles" ]] && rm -f "${DC_ORO_CONFIG_DIR}/.cached_profiles" || true
  fi
  
  # Save CLI profiles to separate cache file
  if [[ ${#cli_profiles[@]} -gt 0 ]]; then
    printf '%s\n' "${cli_profiles[@]}" > "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles"
  else
    # Remove CLI cache file if no CLI profiles
    [[ -f "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles" ]] && rm -f "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles" || true
  fi
  return 0
}

load_cached_profiles() {
  local cached_profiles=()
  local include_cli_profiles=false
  
  # Check if we need CLI profiles based on the command
  if [[ ${#args[@]} -gt 0 ]]; then
    # Use the actual first non-flag argument for command detection
    local cmd_to_check="$first_non_flag_arg"
    
    # Commands that always need CLI profiles (for proper cleanup)
    if [[ "$cmd_to_check" =~ ^(down|purge)$ ]]; then
      include_cli_profiles=true
    # Commands that need database-cli profile
    elif [[ "$cmd_to_check" =~ ^(mysql|psql|database-cli)$ ]] || \
       echo "$cmd_to_check" | grep -i 'import.*db\|export.*db\|dump.*db' > /dev/null; then
      include_cli_profiles=true
    # Commands that need php-cli profile (already handled by auto-redirect, but for completeness)
    elif [[ "$cmd_to_check" =~ ^(cli|php|composer|bin/)$ ]] || \
       [[ "$cmd_to_check" == *.php ]] || \
       [[ "$cmd_to_check" == -* ]]; then
      include_cli_profiles=true
    fi
  fi
  
  # Load regular profiles
  if [[ -f "${DC_ORO_CONFIG_DIR}/.cached_profiles" ]]; then
    while IFS= read -r line; do
      cached_profiles+=("$line")
    done < "${DC_ORO_CONFIG_DIR}/.cached_profiles"
    
    if [[ ${#cached_profiles[@]} -gt 0 ]]; then
      # Add cached profiles to left_options (they will be applied to DOCKER_COMPOSE_BIN_CMD)
      left_options=("${cached_profiles[@]}" "${left_options[@]}")
    fi
  fi
  
  # Load CLI profiles only when needed
  if [[ "$include_cli_profiles" == "true" ]] && [[ -f "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles" ]]; then
    local cached_cli_profiles=()
    while IFS= read -r line; do
      cached_cli_profiles+=("$line")
    done < "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles"
    
    if [[ ${#cached_cli_profiles[@]} -gt 0 ]]; then
      # Add CLI profiles to left_options
      left_options=("${cached_cli_profiles[@]}" "${left_options[@]}")
    fi
  fi
}

load_env_safe() {
  local env_file="$1"

  # if the file exists
  if [[ -f "$env_file" ]]; then
    # Read the file line by line
    while IFS= read -r line || [[ -n "$line" ]]; do
      # Trim leading/trailing whitespace (safe)
      line="${line#"${line%%[![:space:]]*}"}"
      line="${line%"${line##*[![:space:]]}"}"

      # Skip empty lines and comments
      [[ -z "$line" || "$line" == \#* ]] && continue

      # Skip lines without =
      [[ "$line" != *=* ]] && continue

      local key="${line%%=*}"
      local value="${line#*=}"

      # Trim key and value safely
      key="${key#"${key%%[![:space:]]*}"}"
      key="${key%"${key##*[![:space:]]}"}"
      value="${value#"${value%%[![:space:]]*}"}"
      value="${value%"${value##*[![:space:]]}"}"

      # Strip existing quotes from value
      value="${value%\"}"
      value="${value#\"}"
      value="${value%\'}"
      value="${value#\'}"

      # Export the variable safely
      export "$key=$value"
    done < "$env_file"
  fi
}

parse_dsn_uri() {
  local uri="$1"
  local name="$2"
  local prefix="$3"

  [[ -n "$uri" && -n "$name" ]] || return 0

  local host_alias
  host_alias=$(echo "$name" | tr '[:upper:]' '[:lower:]')

  local var_prefix=""
  if [[ -n "$prefix" ]]; then
    var_prefix="$(echo "$prefix" | tr '[:lower:]' '[:upper:]')_"
  fi
  var_prefix+=$(echo "$name" | tr '[:lower:]' '[:upper:]')_

  local schema rest
  if [[ "$uri" == *"://"* ]]; then
    schema="${uri%%://*}"
    rest="${uri#*://}"
  elif [[ "$uri" == *: ]]; then
    schema="${uri%:}"
    rest=""
  else
    schema="$uri"
    rest=""
  fi

  local query=""
  if [[ "$rest" == *\?* ]]; then
    query="${rest#*\?}"
    rest="${rest%%\?*}"
  fi

  local user="" password="" host="" port="" dbname=""

  # Special case: SQLite
  if [[ "$schema" == "sqlite" ]]; then
    if [[ "$uri" == "sqlite::memory:" ]]; then
      dbname=":memory:"
    else
      local sqlite_path="${uri#sqlite://}"
      dbname="${sqlite_path%%\?*}"
    fi

    eval "export ${var_prefix}SCHEMA=\"\$schema\""
    eval "export ${var_prefix}DBNAME=\"\$dbname\""
    eval "export ${var_prefix}QUERY=\"\$query\""
    eval "export ${var_prefix}URI=\"\$uri\""
    return
  fi

  # If rest includes @, extract user/password
  if [[ "$rest" == *@* ]]; then
    local userinfo="${rest%%@*}"
    rest="${rest#*@}"
    user="${userinfo%%:*}"
    password="${userinfo#*:}"
    [[ "$user" == "$password" ]] && password="app"
  fi

  # Extract host, port, dbname
  if [[ "$rest" == *:* ]]; then
    host="${rest%%:*}"
    port="${rest#*:}"
    if [[ "$port" == */* ]]; then
      dbname="${port#*/}"
      port="${port%%/*}"
    fi
  elif [[ "$rest" == */* ]]; then
    host="${rest%%/*}"
    dbname="${rest#*/}"
  elif [[ -n "$rest" ]]; then
    host="$rest"
  fi

  #[[ "$host" == "localhost" || "$host" == "127.0.0.1" ]] && host="$host_alias"
  # always use container host for services
  host="$host_alias"

  # Reconstruct URI only if it's not a simple scheme:
  local clean_uri=""
  if [[ "$schema" == "sqlite" && "$dbname" == ":memory:" ]]; then
    clean_uri="sqlite::memory:"
  elif [[ "$schema" == "sqlite" ]]; then
    clean_uri="sqlite://$dbname"
  elif [[ "$schema" == "dbal" && -z "$rest" ]]; then
    clean_uri="${schema}:"
  else
    clean_uri="${schema}://"
    [[ -n "$user" ]] && clean_uri+="${user}"
    [[ -n "$password" ]] && clean_uri+=":${password}"
    [[ -n "$user" || -n "$password" ]] && clean_uri+="@"
    clean_uri+="${host}"
    [[ -n "$port" ]] && clean_uri+=":${port}"
    [[ -n "$dbname" ]] && clean_uri+="/${dbname}"
    [[ -n "$query" ]] && clean_uri+="?${query}"
  fi

  # Export everything
  eval "export ${var_prefix}SCHEMA=\"\$schema\""
  eval "export ${var_prefix}USER=\"\$user\""
  eval "export ${var_prefix}PASSWORD=\"\$password\""
  eval "export ${var_prefix}HOST=\"\$host\""
  eval "export ${var_prefix}PORT=\"\$port\""
  eval "export ${var_prefix}DBNAME=\"\$dbname\""
  eval "export ${var_prefix}QUERY=\"\$query\""
  eval "export ${var_prefix}URI=\"\$clean_uri\""
}

find-up () {
  path=${2-$PWD}
  while [[ "$path" != "" && ! -e "$path/$1" ]]; do
    path=${path%/*}
  done
  echo "$path"
}

# Skip legacy initialization if environment was already initialized by modular system
# This prevents conflicts when switching environments via menu
if [[ "${DC_ORO_ENV_INITIALIZED:-}" != "1" ]]; then
  debug_log "legacy init: DC_ORO_ENV_INITIALIZED not set, running legacy initialization"
  
  # Only set DC_ORO_APPDIR if not already set (e.g., from menu switch)
  if [[ -z "${DC_ORO_APPDIR:-}" ]]; then
    export DC_ORO_APPDIR=$(find-up composer.json)
  fi

  if [[ -z "${DC_ORO_APPDIR:-}" ]]; then
    if [ -z "$(ls -A "$PWD")" ]; then
      export DC_ORO_APPDIR="$PWD"
    elif [ -f "$PWD/index.php" ]; then
      export DC_ORO_APPDIR="$PWD"
    else
      echo -e "\033[38;5;208m==> Application root folder not found, and current directory is not empty, terminating...\033[0m"
      exit 1
    fi
  fi

  if [[ ! -d "$DC_ORO_APPDIR" ]]; then
    mkdir -p "$DC_ORO_APPDIR"
  fi

  if [[ -z $DC_ORO_COMPOSER_AUTH ]] && [[ -z $COMPOSER_AUTH ]]; then
    if [[ -n "${DC_ORO_CONFIG_DIR:-}" ]] && [[ -d "${DC_ORO_CONFIG_DIR}" ]]; then
      cd "${DC_ORO_CONFIG_DIR}"
      if which php > /dev/null 2>&1 && which composer > /dev/null 2>&1; then
        COMPOSER_HOME=$(php -d display_startup_errors=0 $(which composer) config --working-dir=/tmp --no-interaction --global home 2> /dev/null) || {
          msg_info "Can't find Composer home. Try setting COMPOSER_AUTH manually."
        }
      fi

      if [[ -n ${COMPOSER_HOME} ]] && [[ -f "${COMPOSER_HOME}/auth.json" ]]; then
        DC_ORO_COMPOSER_AUTH=$(cat "${COMPOSER_HOME}/auth.json")
      fi
    fi
  fi

  cd "$DC_ORO_APPDIR"

  load_env_safe "$DC_ORO_APPDIR/.env"
  load_env_safe "$DC_ORO_APPDIR/.env-app"
  load_env_safe "$DC_ORO_APPDIR/.env-app.local"

  # Load global config before local config (global has lower priority)
  # Determine project name for global config lookup
  if [[ -n "${DC_ORO_NAME:-}" ]]; then
    project_name="${DC_ORO_NAME}"
  elif [[ -n "${DC_ORO_APPDIR:-}" ]]; then
    project_name=$(basename "$DC_ORO_APPDIR")
    if [[ "$project_name" == "$HOME" ]] || [[ -z "$project_name" ]] || [[ "$project_name" == "/" ]]; then
      project_name="default"
    fi
  else
    project_name="default"
  fi

  # Load global config first (lower priority)
  global_config_file="${HOME}/.orodc/${project_name}/.env.orodc"
  if [[ -f "$global_config_file" ]]; then
    load_env_safe "$global_config_file"
  fi

  # Load local config last (higher priority, overrides global)
  load_env_safe "$DC_ORO_APPDIR/.env.orodc"
  
  debug_log "legacy init: completed - DC_ORO_APPDIR='${DC_ORO_APPDIR:-}' DC_ORO_NAME='${DC_ORO_NAME:-}'"
else
  debug_log "legacy init: SKIPPED - DC_ORO_ENV_INITIALIZED=1, using modular initialization"
  # Still need to cd to project directory for commands to work
  if [[ -n "${DC_ORO_APPDIR:-}" ]] && [[ -d "${DC_ORO_APPDIR}" ]]; then
    cd "$DC_ORO_APPDIR"
  fi
fi

# Build complete Traefik routing rule
build_traefik_rule() {
  # Start with main host
  local traefik_rule="Host(\`${DC_ORO_NAME:-unnamed}.docker.local\`)"
  
  # Process DC_ORO_EXTRA_HOSTS - convert comma-separated hosts to Traefik rule format
  if [[ -n "${DC_ORO_EXTRA_HOSTS:-}" ]]; then
    # Split by comma and create Host() rules
    IFS=',' read -ra HOSTS <<< "$DC_ORO_EXTRA_HOSTS"
    for host in "${HOSTS[@]}"; do
      # Trim whitespace
      host=$(echo "$host" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
      if [[ -n "$host" ]]; then
        # Auto-append .docker.local if host is a single word (no dots)
        if [[ "$host" != *.* ]]; then
          host="$host.docker.local"
        fi
        traefik_rule="$traefik_rule || Host(\`$host\`)"
      fi
    done
  fi
  
  export DC_ORO_TRAEFIK_RULE="$traefik_rule"
}

# Build the complete Traefik rule
build_traefik_rule

parse_dsn_uri "$ORO_DB_URL" "database" "DC_ORO"
export DC_ORO_DATABASE_USER=${DC_ORO_DATABASE_USER:-app}
export DC_ORO_DATABASE_PASSWORD=${DC_ORO_DATABASE_PASSWORD:-app}

parse_dsn_uri "$ORO_SEARCH_URL" "search" "DC_ORO"
parse_dsn_uri "$ORO_MQ_DSN" "mq" "DC_ORO"
parse_dsn_uri "$ORO_REDIS_URL" "redis" "DC_ORO"

export DC_ORO_PORT_PREFIX=${DC_ORO_PORT_PREFIX:-"301"}

# Use batch port resolution for better performance
BATCH_PORTS=$(orodc-find_free_port --batch ${DC_ORO_NAME} $DC_ORO_CONFIG_DIR \
  nginx "${DC_ORO_PORT_PREFIX}80" \
  xhgui "${DC_ORO_PORT_PREFIX}81" \
  database "${DC_ORO_PORT_PREFIX}06" \
  database "${DC_ORO_PORT_PREFIX}32" \
  search "${DC_ORO_PORT_PREFIX}92" \
  mq "${DC_ORO_PORT_PREFIX}72" \
  redis "${DC_ORO_PORT_PREFIX}79" \
  mail "${DC_ORO_PORT_PREFIX}25" \
  ssh "${DC_ORO_PORT_PREFIX}22" \
  gotenberg "${DC_ORO_PORT_PREFIX}00")

# Parse batch results and export individual port variables
while IFS=':' read -r service port; do
  case "$service" in
    nginx)
      export DC_ORO_PORT_NGINX="$port"
      ;;
    xhgui)
      export DC_ORO_PORT_XHGUI="$port"
      ;;
    database)
      if [[ -z "$DC_ORO_PORT_MYSQL" ]]; then
        export DC_ORO_PORT_MYSQL="$port"
      else
        export DC_ORO_PORT_PGSQL="$port"
      fi
      ;;
    search)
      export DC_ORO_PORT_SEARCH="$port"
      ;;
    mq)
      export DC_ORO_PORT_MQ="$port"
      ;;
    redis)
      export DC_ORO_PORT_REDIS="$port"
      ;;
    mail)
      export DC_ORO_PORT_MAIL_WEBGUI="$port"
      ;;
    ssh)
      export DC_ORO_PORT_SSH="$port"
      ;;
    gotenberg)
      export DC_ORO_PORT_GOTENBERG="$port"
      ;;
  esac
done <<< "$BATCH_PORTS"

export COMPOSER_AUTH=$(echo ${DC_ORO_COMPOSER_AUTH:-${COMPOSER_AUTH}} | jq -c .)
export DC_ORO_COMPOSER_AUTH=${COMPOSER_AUTH}

if ${DOCKER_BIN} system info --format '{{.SecurityOptions}}' 2>/dev/null | grep "name=rootless" > /dev/null 2>&1; then
  # Use root user in the rootless mode
  export DC_ORO_USER_NAME="root"
  export DC_ORO_USER_GROUP="root"
  export DC_ORO_USER_UID=0
  export DC_ORO_USER_GID=0
else
  export DC_ORO_USER_NAME="developer"
  export DC_ORO_USER_GROUP="developer"
  export DC_ORO_USER_UID=$UID
  export DC_ORO_USER_GID=$GID
fi

export DC_ORO_PHP_USER_NAME=${DC_ORO_USER_NAME}
export DC_ORO_PHP_USER_GROUP=${DC_ORO_USER_GROUP}
export DC_ORO_PHP_USER_UID=${DC_ORO_USER_UID}
export DC_ORO_PHP_USER_GID=${DC_ORO_USER_GID}

# Export mailer configuration with defaults (tls = STARTTLS)
export ORO_MAILER_DRIVER=${ORO_MAILER_DRIVER:-smtp}
export ORO_MAILER_HOST=${ORO_MAILER_HOST:-mail}
export ORO_MAILER_PORT=${ORO_MAILER_PORT:-1025}
export ORO_MAILER_ENCRYPTION=${ORO_MAILER_ENCRYPTION:-starttls}
export ORO_MAILER_USER=${ORO_MAILER_USER:-}
export ORO_MAILER_PASSWORD=${ORO_MAILER_PASSWORD:-}

NETWORK_NAME="dc_shared_net"
# Check if the Docker network already exists
if ! docker network ls --format '{{.Name}}' | grep -qw "$NETWORK_NAME"; then
  msg_info "Creating Docker network: $NETWORK_NAME"
  docker network create "$NETWORK_NAME"
else
  # Docker network already exists - skip message
  true
fi

if [[ -z $DC_ORO_MODE ]] && [[ "$OSTYPE" == "darwin"* ]]; then
  export DC_ORO_MODE="mutagen"
elif [[ -z $DC_ORO_MODE ]]; then
  export DC_ORO_MODE="default"
fi

if [[ -z ${ORO_SSH_PUBLIC_KEY} ]]; then
  # DC_ORO_CONFIG_DIR must be set (validated by validate_project for non-excluded commands)
  # For excluded commands (init, codex, etc.), skip SSH key creation if DC_ORO_CONFIG_DIR is not set
  if [[ -z "${DC_ORO_CONFIG_DIR:-}" ]]; then
    # Skip SSH key creation for commands that don't require project initialization
    # These commands are excluded from validation and don't need SSH key
    debug_log "Skipping SSH key creation - DC_ORO_CONFIG_DIR not set (command may not require project)"
  else
    # Create config directory if it doesn't exist
    mkdir -p "${DC_ORO_CONFIG_DIR}"
    
    if [[ ! -e "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519" ]]; then
      ssh-keygen -t ed25519 -f "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519" -N "" -q
      chmod 0600 "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519"
    fi
    
    if [[ -f "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519.pub" ]]; then
      export ORO_SSH_PUBLIC_KEY=$(cat "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519.pub")
    fi
  fi
fi

# Only add compose files if DC_ORO_CONFIG_DIR is set (proxy commands don't need project compose files)
if [[ -n "${DC_ORO_CONFIG_DIR:-}" ]]; then
  if [[ "${DC_ORO_MODE}" == "default" ]] && [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-default.yml" ]]; then
    DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-default.yml"
  fi

  if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]];then
    export DC_ORO_DATABASE_PORT=${DC_ORO_DATABASE_PORT:-5432}
    if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-pgsql.yml" ]]; then
      DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-pgsql.yml"
    fi
  elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
    export DC_ORO_DATABASE_PORT=${DC_ORO_DATABASE_PORT:-3306}
    if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-mysql.yml" ]]; then
      DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-mysql.yml"
    fi
  fi

  # Include consumer service only for Oro Platform projects
  if is_oro_project && [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-consumer.yml" ]]; then
    DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-consumer.yml"
  fi

  # Include CMS-specific cron service (Ofelia)
  CMS_TYPE=$(detect_cms_type 2>/dev/null || echo "base")
  case "$CMS_TYPE" in
    oro)
      if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-cron-oro.yml" ]]; then
        DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-cron-oro.yml"
      fi
      ;;
    magento)
      if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-cron-magento.yml" ]]; then
        DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-cron-magento.yml"
      fi
      ;;
  esac
fi

# Only check for database service and user compose files if we have a project context
if [[ -n "${DC_ORO_CONFIG_DIR:-}" ]] && [[ -n "${DC_ORO_APPDIR:-}" ]]; then
  if ${DOCKER_COMPOSE_BIN_CMD} ps --services 2>/dev/null | grep database > /dev/null; then
    SERVICE_DATABASE_ID=$(${DOCKER_COMPOSE_BIN_CMD} ps -q database)
    if [[ "" != $SERVICE_DATABASE_ID ]] && ${DOCKER_BIN} inspect -f '{{ .Config.Image }}' "$SERVICE_DATABASE_ID" | grep -q 'busybox'; then
      ${DOCKER_COMPOSE_BIN_CMD} stop database
      ${DOCKER_COMPOSE_BIN_CMD} rm -f database
    fi
  fi

  if [[ -f "$DC_ORO_APPDIR/.docker-compose.user.yml" ]]; then
    msg_info "Additional ${DOCKER_BIN} compose config will be used: $DC_ORO_APPDIR/.docker-compose.user.yml"
    DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f $DC_ORO_APPDIR/.docker-compose.user.yml"
  fi
fi

# Detect if project is an Oro Platform-based project
# Checks composer.json for Oro ecosystem packages
# Returns 0 (true) if Oro project, 1 (false) otherwise
# Override with DC_ORO_IS_ORO_PROJECT environment variable (1/true or 0/false)
is_oro_project() {
  # Check for explicit override first
  if [[ -n "${DC_ORO_IS_ORO_PROJECT:-}" ]]; then
    local is_oro_lower="$(echo "${DC_ORO_IS_ORO_PROJECT}" | tr '[:upper:]' '[:lower:]')"
    case "$is_oro_lower" in
      1|true|yes)
        return 0
        ;;
      0|false|no)
        return 1
        ;;
    esac
  fi
  
  # Auto-detect from composer.json
  local composer_file="${DC_ORO_APPDIR:-$PWD}/composer.json"
  if [[ ! -f "$composer_file" ]]; then
    return 1
  fi
  
  # Check for Oro ecosystem packages in require section
  # Uses jq if available for reliable JSON parsing
  if command -v jq >/dev/null 2>&1; then
    local oro_packages
    oro_packages=$(jq -r '.require // {} | keys[]' "$composer_file" 2>/dev/null | \
      grep -E '^(oro/platform|oro/commerce|oro/crm|oro/customer-portal|marello/marello|marellocommerce/marello)$' | head -1)
    if [[ -n "$oro_packages" ]]; then
      return 0
    fi
  else
    # Fallback: grep-based detection (less reliable but works without jq)
    if grep -qE '"(oro/platform|oro/commerce|oro/crm|oro/customer-portal|marello/marello|marellocommerce/marello)"' "$composer_file" 2>/dev/null; then
      return 0
    fi
  fi
  
  return 1
}

# Auto-detect PHP version from composer.json
detect_php_version_from_composer() {
  if [[ -f "$DC_ORO_APPDIR/composer.json" ]]; then
    # Try direct PHP requirement first
    local php_constraint=$(jq -r '.require.php // empty' "$DC_ORO_APPDIR/composer.json" 2>/dev/null)
    if [[ -n "$php_constraint" ]]; then
      # Extract version from constraint (e.g., "^8.1" -> "8.1", ">=8.2" -> "8.2")
      local php_version=$(echo "$php_constraint" | sed -E 's/[^0-9.]*([0-9]+\.[0-9]+).*/\1/')
      if [[ "$php_version" =~ ^[0-9]+\.[0-9]+$ ]]; then
        echo "$php_version"
        return 0
      fi
    fi
    
    # Fallback: detect from Oro Platform version
    local oro_platform=$(jq -r '.require["oro/platform"] // empty' "$DC_ORO_APPDIR/composer.json" 2>/dev/null)
    if [[ -n "$oro_platform" ]]; then
      # Extract full Oro version (e.g., "6.0.8", "^6.1.0" -> "6.1.0")
      local oro_version=$(echo "$oro_platform" | sed -E 's/[^0-9.]*([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
      # If no patch version found, try major.minor
      if [[ ! "$oro_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        oro_version=$(echo "$oro_platform" | sed -E 's/[^0-9.]*([0-9]+\.[0-9]+).*/\1/')
      fi
      
      # Convert to comparable format and determine PHP version
      local major=$(echo "$oro_version" | cut -d. -f1)
      local minor=$(echo "$oro_version" | cut -d. -f2)
      local patch=$(echo "$oro_version" | cut -d. -f3 2>/dev/null || echo "0")
      
      # Version comparison logic
      if [[ $major -eq 6 && $minor -eq 0 ]]; then
        echo "8.3" && return 0  # Oro 6.0.x uses PHP 8.3
      elif [[ $major -eq 6 && $minor -ge 1 ]] || [[ $major -gt 6 ]]; then
        echo "8.4" && return 0  # Oro 6.1+ uses PHP 8.4
      elif [[ $major -eq 5 && $minor -eq 1 ]]; then
        echo "8.1" && return 0
      elif [[ $major -eq 5 && $minor -eq 0 ]]; then
        echo "8.1" && return 0
      elif [[ $major -eq 4 && $minor -eq 2 ]]; then
        echo "8.1" && return 0
      elif [[ $major -eq 4 && $minor -eq 1 ]]; then
        echo "8.1" && return 0
      elif [[ $major -eq 4 && $minor -eq 0 ]]; then
        echo "7.4" && return 0
      fi
    fi
  fi
  return 1
}


# Get compatible Node.js version for PHP version
get_compatible_node_version() {
  local php_version="$1"
  # Extract major.minor version only (e.g., "7.3.33" -> "7.3")
  local php_mm=$(echo "$php_version" | sed -E 's/^([0-9]+\.[0-9]+).*/\1/')
  
  case "$php_mm" in
    8.5*) echo "24" ;;
    8.4*) echo "22" ;;
    8.3*) echo "20" ;;
    8.2*) echo "20" ;;
    8.1*) echo "20" ;;
    7.4*) echo "16" ;;
    7.3*) echo "16" ;;
    *) echo "24" ;;  # Default to latest Node 24 for unknown PHP versions
  esac
}

# Auto-detect PHP version with fallback chain
if [[ -z $DC_ORO_PHP_VERSION ]]; then
  # Priority 1: .php-version file
  if [[ -f "$DC_ORO_APPDIR/.php-version" ]]; then
    export DC_ORO_PHP_VERSION=$(cat $DC_ORO_APPDIR/.php-version | head -n1)
    msg_debug "Found .php-version with following version: $DC_ORO_PHP_VERSION"
  # Priority 2: .phprc file
  elif [[ -f "$DC_ORO_APPDIR/.phprc" ]]; then
    export DC_ORO_PHP_VERSION=$(cat $DC_ORO_APPDIR/.phprc | head -n1)
    msg_info "Found .phprc with following version: $DC_ORO_PHP_VERSION"
  # Priority 3: composer.json
  elif DC_ORO_PHP_VERSION=$(detect_php_version_from_composer); then
    export DC_ORO_PHP_VERSION
    msg_debug "Detected PHP version from composer.json: $DC_ORO_PHP_VERSION"
  # Priority 4: Default to latest available version (from GitHub Actions matrix)
  else
    export DC_ORO_PHP_VERSION="8.5"
    msg_info "Using default PHP version: $DC_ORO_PHP_VERSION (latest available)"
  fi
fi

# Auto-detect Node.js version with fallback chain
if [[ -z $DC_ORO_NODE_VERSION ]]; then
  # Priority 1: .nvmrc file
  if [[ -f "$DC_ORO_APPDIR/.nvmrc" ]]; then
    export DC_ORO_NODE_VERSION=$(cat $DC_ORO_APPDIR/.nvmrc | head -n1)
    msg_debug "Found .nvmrc with following version: $DC_ORO_NODE_VERSION"
  # Priority 2: .node-version file (alternative to .nvmrc)
  elif [[ -f "$DC_ORO_APPDIR/.node-version" ]]; then
    export DC_ORO_NODE_VERSION=$(cat $DC_ORO_APPDIR/.node-version | head -n1)
    msg_info "Found .node-version with following version: $DC_ORO_NODE_VERSION"
  # Priority 3: Compatibility matrix based on detected PHP version
  elif [[ -n "$DC_ORO_PHP_VERSION" ]]; then
    export DC_ORO_NODE_VERSION=$(get_compatible_node_version "$DC_ORO_PHP_VERSION")
    msg_info "Using compatible Node.js version for PHP $DC_ORO_PHP_VERSION: $DC_ORO_NODE_VERSION"
  # Priority 4: Default to latest available version (from GitHub Actions matrix)
  else
    export DC_ORO_NODE_VERSION="24"
    msg_info "Using default Node.js version: $DC_ORO_NODE_VERSION (latest available)"
  fi
fi

# Only sync if we're in a valid Oro project
# This prevents accidentally syncing non-project directories (like home directory)
# Valid project MUST have one of: composer.json OR .env.orodc (local OR global)
if [[ "${DC_ORO_MODE}" == "mutagen" ]] || [[ "${DC_ORO_MODE}" == "ssh" ]]; then
  # Check if we're in valid project:
  # 1. DC_ORO_APPDIR is set AND DC_ORO_NAME is set (project was initialized)
  # 2. DC_ORO_APPDIR is NOT the home directory or root (prevent accidental sync)
  # 3. Has composer.json OR .env.orodc (local) OR .env.orodc (global) - REQUIRED!
  if [[ -n "${DC_ORO_APPDIR:-}" ]] && [[ -n "${DC_ORO_NAME:-}" ]] && \
     [[ "${DC_ORO_APPDIR}" != "${HOME}" ]] && [[ "${DC_ORO_APPDIR}" != "/" ]] && \
     ( [[ -f "${DC_ORO_APPDIR}/composer.json" ]] || \
       [[ -f "${DC_ORO_APPDIR}/.env.orodc" ]] || \
       [[ -f "${HOME}/.orodc/${DC_ORO_NAME}/.env.orodc" ]] ); then
    if [[ ${args[0]} != "down" ]] && [[ ${args[0]} != "purge" ]] && [[ ${args[0]} != "init" ]]; then
      ${DOCKER_BIN} volume ls | awk '{ print $2 }' | tail +2 | grep '^'${DC_ORO_NAME}'_appcode$' > /dev/null 2>&1 || {
        ${DOCKER_BIN} volume create "${DC_ORO_NAME}_appcode"  > /dev/null
        # Start SSH container silently (dependencies will start automatically)
        bash -c "${DOCKER_COMPOSE_BIN_CMD} up -d ssh" >/dev/null 2>&1 || true
        SSH_HOST=${DC_ORO_SSH_BIND_HOST:-127.0.0.1}
        SSH_PORT=$(${DOCKER_BIN} inspect $(${DOCKER_COMPOSE_BIN_CMD} ps | grep ssh | awk '{ print $1 }') | jq -r '.[0].NetworkSettings.Ports["22/tcp"][0].HostPort')
        if [[ 0 -eq $(ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o 'ForwardAgent no' -o IdentitiesOnly=yes -i "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519" -p ${SSH_PORT} ${ORO_DC_SSH_ARGS} ${DC_ORO_USER_NAME}@${SSH_HOST} sh -c 'ls "'${DC_ORO_APPDIR}'/"' 2>/dev/null | wc -l) ]]; then
          rsync_cmd="${RSYNC_BIN} --exclude var/cache --exclude vendor --exclude node_modules --links -e \"ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o 'ForwardAgent no' -o IdentitiesOnly=yes -i ${DC_ORO_CONFIG_DIR}/ssh_id_ed25519 -p ${SSH_PORT} ${ORO_DC_SSH_ARGS}\" --timeout=3 -r '${DC_ORO_APPDIR}/' ${DC_ORO_USER_NAME}@${SSH_HOST}:'${DC_ORO_APPDIR}/'"
          if [[ -n "${DEBUG:-}" ]] || [[ -n "${VERBOSE:-}" ]]; then
            msg_info "Copying source code to the '${DC_ORO_NAME}_appcode' docker volume"
            rsync_cmd="${rsync_cmd/--timeout=3/--timeout=3 --info=progress2}"
            until eval "$rsync_cmd" 2>/dev/null; do
              echo -n "."
              sleep 3
            done
            echo ""
          else
            run_with_spinner "Syncing source code to '${DC_ORO_NAME}_appcode' volume" "until $rsync_cmd 2>/dev/null; do sleep 3; done"
          fi
        fi
      }
    fi
  fi
fi

# Only setup mutagen if we're in a valid Oro project
# Valid project MUST have one of: composer.json OR .env.orodc (local OR global)
if [[ "${DC_ORO_MODE}" == "mutagen" ]] && [[ -n "${DC_ORO_APPDIR:-}" ]] && [[ -n "${DC_ORO_NAME:-}" ]] && \
   [[ "${DC_ORO_APPDIR}" != "${HOME}" ]] && [[ "${DC_ORO_APPDIR}" != "/" ]] && \
   ( [[ -f "${DC_ORO_APPDIR}/composer.json" ]] || \
     [[ -f "${DC_ORO_APPDIR}/.env.orodc" ]] || \
     [[ -f "${HOME}/.orodc/${DC_ORO_NAME}/.env.orodc" ]] ); then
  MUTAGEN_SESSION_NAME=$(echo ${DC_ORO_NAME}-appcode | awk '{print tolower($0)}' | sed 's/[^0-9a-z]/-/g')
  WAIT_SYNC="1"

  if [[ "$first_non_flag_arg" == "down" ]] || [[ "$first_non_flag_arg" == "purge" ]]; then
    if mutagen sync list | grep -i "Name: ${MUTAGEN_SESSION_NAME}" > /dev/null 2>&1; then
      mutagen sync terminate "${MUTAGEN_SESSION_NAME}"
    fi
    WAIT_SYNC=""
  elif ! echo "$first_non_flag_arg" | grep -i '^\(build\|pull\|config\|init\)' > /dev/null 2>&1; then
    if [[ "0" -eq $(${DOCKER_COMPOSE_BIN_CMD} ps -q ssh  2> /dev/null | wc -l 2> /dev/null) ]]; then
      # Start SSH container silently (dependencies will start automatically)
      bash -c "${DOCKER_COMPOSE_BIN_CMD} up -d ssh" >/dev/null 2>&1 || true
    fi
    DOCKER_CONTAINER_NAME_MUTAGEN=$(${DOCKER_BIN} inspect -f '{{.Name}}' $(bash -c "${DOCKER_COMPOSE_BIN_CMD} ps -q ssh") | cut -c2-)
    if ! mutagen sync list | grep -i "Name: ${MUTAGEN_SESSION_NAME}" > /dev/null 2>&1; then
      # Create mutagen sync session with spinner (unless verbose mode)
      mutagen_create_cmd="mutagen sync create --sync-mode=two-way-resolved \
        --scan-mode=accelerated \
        --watch-mode-alpha=portable \
        --watch-mode-beta=force-poll \
        --watch-polling-interval-beta=30 \
        --ignore='.git' \
        --ignore='.idea' \
        --ignore='.history' \
        --ignore='.mysql.initdb.d' \
        --ignore='.psql.initdb.d' \
        --ignore='var' \
        --ignore-vcs \
        --symlink-mode=ignore \
        --name='${MUTAGEN_SESSION_NAME}' \
        '${DC_ORO_APPDIR}' 'docker://${DC_ORO_USER_NAME}@${DOCKER_CONTAINER_NAME_MUTAGEN}${DC_ORO_APPDIR}'"
      if [[ -n "${DEBUG:-}" ]] || [[ -n "${VERBOSE:-}" ]]; then
        msg_info "Creating Mutagen sync session..."
        eval "$mutagen_create_cmd"
      else
        run_with_spinner "Creating Mutagen sync session" "$mutagen_create_cmd"
      fi
    else
      WAIT_SYNC=""
    fi

    if [[ "${WAIT_SYNC}" == "1" ]]; then
      # Wait for mutagen sync with spinner (unless verbose mode)
      wait_cmd="until mutagen sync list '${MUTAGEN_SESSION_NAME}' 2>/dev/null | grep 'Status:' | grep -q 'Watching for changes'; do sleep 2; done"
      if [[ -n "${DEBUG:-}" ]] || [[ -n "${VERBOSE:-}" ]]; then
        msg_info "Waiting for Mutagen file synchronization..."
        until mutagen sync list "${MUTAGEN_SESSION_NAME}" | grep 'Status:' | grep 'Watching for changes' > /dev/null 2>&1; do
          mutagen sync list "${MUTAGEN_SESSION_NAME}" | grep 'Status:' | awk -F: '{ print $2 }'
          sleep 3
        done
        msg_ok "Mutagen synchronization completed"
      else
        run_with_spinner "Synchronizing files with Mutagen" "$wait_cmd"
      fi
    fi
  fi
fi

if [[ ${DOCKER_COMPOSE_VERSION} -gt 1 ]]; then
  DOCKER_COMPOSE_RUN_CMD="${DOCKER_COMPOSE_BIN_CMD} run -i --rm"
else
  DOCKER_COMPOSE_RUN_CMD="${DOCKER_COMPOSE_BIN_CMD} run --rm"
fi

# Function to build docker compose run command with proper flag placement
build_docker_compose_run_cmd() {
  local service="$1"
  local cmd_args=("${@:2}")
  
  # Check if this is a composer command - use -T flag for non-interactive mode
  # For interactive commands, use -it (both stdin and TTY)
  local use_tty_flag="-it"
  if [[ "$first_non_flag_arg" == "composer" ]]; then
    use_tty_flag="-T"
  fi
  
  if [[ ${#left_flags[@]} -gt 0 ]] || [[ ${#left_options[@]} -gt 0 ]]; then
    # Place docker compose flags before 'run' command
    if [[ ${DOCKER_COMPOSE_VERSION} -gt 1 ]]; then
      echo "${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run ${use_tty_flag} --rm ${service} ${cmd_args[*]} ${right_flags[*]} ${right_options[*]}"
    else
      echo "${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run --rm ${service} ${cmd_args[*]} ${right_flags[*]} ${right_options[*]}"
    fi
  else
    # Use standard command without parsed flags
    # For composer commands in DOCKER_COMPOSE_VERSION > 1, replace -i with -T in DOCKER_COMPOSE_RUN_CMD
    if [[ "$first_non_flag_arg" == "composer" ]] && [[ ${DOCKER_COMPOSE_VERSION} -gt 1 ]]; then
      local composer_run_cmd="${DOCKER_COMPOSE_RUN_CMD/-i /-T }"
      echo "${composer_run_cmd} ${service} ${cmd_args[*]}"
    else
      echo "${DOCKER_COMPOSE_RUN_CMD} ${service} ${cmd_args[*]}"
    fi
  fi
}

# Function to check if a container is running
is_container_running() {
  local service="$1"
  local container_id
  
  # Get container ID for the service
  container_id=$(${DOCKER_COMPOSE_BIN_CMD} ps -q "$service" 2>/dev/null)
  
  # Check if container exists and is running
  if [[ -n "$container_id" ]] && ${DOCKER_BIN} inspect -f '{{.State.Running}}' "$container_id" 2>/dev/null | grep -q "true"; then
    return 0
  else
    return 1
  fi
}

# Function to execute command in container (use ssh if available, otherwise cli)
execute_in_container() {
  local service="$1"
  local cmd_args=("${@:2}")
  
  # Handle external PHP files for exec vs run scenarios
  local external_files=()
  local updated_cmd_args=()
  
  # Collect external PHP files from command arguments
  for arg in "${cmd_args[@]}"; do
    if [[ $arg == *.php ]]; then
      PHPFILE_PATH=$(echo $arg | grep -oE '.+\.php' | sed s~.\*=~~)
      PHPFILE_DIR=$(dirname "${PHPFILE_PATH}")
      
      # Check if file is outside project directory
      if [[ -z $DC_ORO_APPDIR ]] || [[ $PHPFILE_DIR != '.' && $PHPFILE_DIR != $DC_ORO_APPDIR && $PHPFILE_DIR != $DC_ORO_APPDIR/* ]]; then
        # Check if file exists locally
        if [[ -f "${PHPFILE_PATH}" ]]; then
          external_files+=("${PHPFILE_PATH}")
        fi
      fi
    fi
    updated_cmd_args+=("$arg")
  done
  
  # For CLI commands, prefer SSH container if it's running (much faster)
  if [[ "$service" == "cli" ]] && is_container_running "ssh"; then
    # Handle external files for SSH exec - copy to shared volume
    if [[ ${#external_files[@]} -gt 0 ]]; then
      for file in "${external_files[@]}"; do
        filename=$(basename "$file")
        # Copy external file to shared-private volume via SSH container
        if docker cp "$file" "${DC_ORO_NAME}_ssh_${DC_ORO_PHP_VERSION:-8.5}-${DC_ORO_NODE_VERSION:-24}-${DC_ORO_COMPOSER_VERSION:-2}:/private/$filename" 2>/dev/null; then
          if [ "$DEBUG" ]; then echo "DEBUG: Copied external file $file to /private/$filename" >&2; fi
          # Update command arguments to use shared volume path
          for i in "${!updated_cmd_args[@]}"; do
            if [[ "${updated_cmd_args[$i]}" == "$file" ]]; then
              updated_cmd_args[$i]="/private/$filename"
              break
            fi
          done
        else
          if [ "$DEBUG" ]; then echo "DEBUG: Failed to copy $file to SSH container, falling back to CLI run" >&2; fi
          # Fall back to CLI run with volume mount
          exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} run -it --rm -v "$(dirname "$file"):$(dirname "$file"):ro" "$service" "${cmd_args[@]}" "${right_flags[@]}" "${right_options[@]}"
        fi
      done
    fi
    
    if [ "$DEBUG" ]; then echo "DEBUG: Using SSH container for faster execution instead of CLI" >&2; fi
    exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} exec "ssh" "${updated_cmd_args[@]}" "${right_flags[@]}" "${right_options[@]}"
  elif is_container_running "$service"; then
    # Container is running, use exec for faster execution
    if [ "$DEBUG" ]; then echo "DEBUG: Using docker compose exec for service: $service" >&2; fi
    exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} exec "$service" "${updated_cmd_args[@]}" "${right_flags[@]}" "${right_options[@]}"
  else
    # Container is not running, use docker compose run with volume mounts for external files
    # Use -it for interactive mode (both stdin and TTY)
    # Check if stdin is a terminal to determine if we need TTY
    if [[ -t 0 ]]; then
      local run_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run -it --rm"
    else
      local run_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run -T --rm"
    fi
    
    # Add volume mounts for external files
    if [[ ${#external_files[@]} -gt 0 ]]; then
      for file in "${external_files[@]}"; do
        file_dir=$(dirname "${file}")
        run_cmd="$run_cmd -v ${file_dir}:${file_dir}:ro"
        if [ "$DEBUG" ]; then echo "DEBUG: Adding volume mount for external file: -v ${file_dir}:${file_dir}:ro" >&2; fi
      done
    fi
    
    run_cmd="$run_cmd $service"
    
    # Ensure appcode volume exists before starting service
    ensure_appcode_volume
    
    # Start the service in background first
    ${DOCKER_COMPOSE_BIN_CMD} up -d "$service" >/dev/null 2>&1
    
    # Wait a moment for the service to be ready
    sleep 1
    
    # Verify it's now running, if so use exec, otherwise use run
    if is_container_running "$service"; then
      if [ "$DEBUG" ]; then echo "DEBUG: Service $service started, using exec" >&2; fi
      exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} exec "$service" "${updated_cmd_args[@]}" "${right_flags[@]}" "${right_options[@]}"
    else
      # Fallback to run if start failed
      if [ "$DEBUG" ]; then echo "DEBUG: Failed to start service $service, using run with volume mounts" >&2; fi
      exec bash -c "$run_cmd ${cmd_args[*]} ${right_flags[*]} ${right_options[*]}"
    fi
  fi
}

if ${DOCKER_BIN} system info --format '{{.SecurityOptions}}' 2>/dev/null | grep "name=rootless" > /dev/null; then
  DOCKER_COMPOSE_RUN_CMD="${DOCKER_COMPOSE_RUN_CMD} --user root"
fi

# External PHP files are now handled in execute_in_container() function

# Load cached profiles for all commands except 'up' (which saves new profiles)
if [[ "$first_non_flag_arg" != "up" ]]; then
  load_cached_profiles
fi

if [[ "$first_non_flag_arg" == "up" ]]; then
  # Save profiles for future commands
  save_profiles
fi


if echo "$first_non_flag_arg" | grep -i 'import' | grep -i 'db\|database' > /dev/null 2>&1 || false; then
  if [[ -z ${args[1]} ]]; then
    >&2 echo "Data file was not provided"
    exit 1
  fi
  if [[ -r ${args[1]} ]]; then
    DB_DUMP=$(realpath ${args[1]})
  elif [[ -r "$DC_ORO_APPDIR/${args[1]}" ]]; then
    DB_DUMP=$(realpath "$DC_ORO_APPDIR/${args[1]}")
  fi

  if [[ -z "$DB_DUMP" ]] || [[ ! -r "$DB_DUMP" ]]; then
    >&2 echo "Data file '${args[1]}' does not readable"
    exit 1
  fi

  DB_DUMP_BASENAME=$(echo "${DB_DUMP##*/}")
  if [[ $DC_ORO_DATABASE_SCHEMA == "pdo_pgsql" ]] || [[ $DC_ORO_DATABASE_SCHEMA == "postgres" ]];then
    DB_IMPORT_CMD="sed -E 's/[Oo][Ww][Nn][Ee][Rr]:[[:space:]]*[a-zA-Z0-9_]+/Owner: '\$DC_ORO_DATABASE_USER'/g' | sed -E 's/[Oo][Ww][Nn][Ee][Rr][[:space:]]+[Tt][Oo][[:space:]]+[a-zA-Z0-9_]+/OWNER TO '\$DC_ORO_DATABASE_USER'/g' | sed -E 's/[Ff][Oo][Rr][[:space:]]+[Rr][Oo][Ll][Ee][[:space:]]+[a-zA-Z0-9_]+/FOR ROLE '\$DC_ORO_DATABASE_USER'/g' | sed -E 's/[Tt][Oo][[:space:]]+[a-zA-Z0-9_]+;/TO '\$DC_ORO_DATABASE_USER';/g' | sed -E '/^[[:space:]]*[Rr][Ee][Vv][Oo][Kk][Ee][[:space:]]+[Aa][Ll][Ll]/d' | sed -e '/SET transaction_timeout = 0;/d' | sed -E '/[\\]restrict|[\\]unrestrict/d' | PGPASSWORD=\$DC_ORO_DATABASE_PASSWORD psql --set ON_ERROR_STOP=on -h \$DC_ORO_DATABASE_HOST -p \$DC_ORO_DATABASE_PORT -U \$DC_ORO_DATABASE_USER -d \$DC_ORO_DATABASE_DBNAME -1 >/dev/null"
  elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "pdo_mysql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
    DB_IMPORT_CMD="sed -E 's/[Dd][Ee][Ff][Ii][Nn][Ee][Rr][ ]*=[ ]*[^*]*\*/DEFINER=CURRENT_USER \*/' | MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME"
  fi

  if echo ${DB_DUMP_BASENAME} | grep -i 'sql\.gz$' > /dev/null; then
    DB_IMPORT_CMD="zcat ${DB_DUMP_BASENAME} | sed -E 's/^[[:space:]]*[Cc][Rr][Ee][Aa][Tt][Ee][[:space:]]+[Ff][Uu][Nn][Cc][Tt][Ii][Oo][Nn]/CREATE OR REPLACE FUNCTION/g' | ${DB_IMPORT_CMD}"
  else
    DB_IMPORT_CMD="cat /${DB_DUMP_BASENAME} | sed -E 's/^[[:space:]]*[Cc][Rr][Ee][Aa][Tt][Ee][[:space:]]+[Ff][Uu][Nn][Cc][Tt][Ii][Oo][Nn]/CREATE OR REPLACE FUNCTION/g' | ${DB_IMPORT_CMD}"
  fi

  msg_info "Starting import of the database dump..."
  msg_info "From: $DB_DUMP"
  msg_info "File size: $(du -h "$DB_DUMP" | cut -f1)"
  msg_info "Database: $DC_ORO_DATABASE_HOST:$DC_ORO_DATABASE_PORT/$DC_ORO_DATABASE_DBNAME"
  
  import_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run --quiet -i --rm -v \"${DB_DUMP}:/${DB_DUMP_BASENAME}\" database-cli bash -c \"$DB_IMPORT_CMD\""
  run_with_spinner "Importing database" "$import_cmd" || exit $?
  exit 0
fi

if echo ${args[0]} | grep -i 'set\|update' | grep -i 'url\|uri' > /dev/null; then
  URL=${args[1]:-"https://${DC_ORO_NAME}.docker.local"}
  set -x
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:update oro_website.secure_url ${URL}" || true
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:update oro_ui.application_url ${URL}" || true
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:update oro_website.url ${URL}" || true
  exit 0
fi

# Cache command is now handled by cache.sh module (see case statement below)
# This ensures spinners are used for all cache operations
# Removed direct execution to route through cache.sh module

if echo "$first_non_flag_arg" | grep -i 'update' | grep -i 'platform' > /dev/null; then
  set -x
  if [[ "$NEEDS_ARG_PARSING" == "true" ]]; then
    exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} run -i --rm cli bash -c "rm -rf var/cache/* || true; php bin/console oro:platform:update --force"
  else
    exec ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "rm -rf var/cache/* || true; php bin/console oro:platform:update --force"
  fi
fi

if [[ "$first_non_flag_arg" == "platform" && "${args[1]}" == "update" ]]; then
  set -x
  if [[ "$NEEDS_ARG_PARSING" == "true" ]]; then
    exec ${DOCKER_COMPOSE_RUN_CMD} ${left_flags[@]} ${left_options[@]} cli php ./bin/console oro:platform:update --force "${args[@]:2}" "${right_flags[@]}" "${right_options[@]}"
  else
    exec ${DOCKER_COMPOSE_RUN_CMD} cli php ./bin/console oro:platform:update --force "${args[@]:2}"
  fi
fi

if echo ${args[0]} | grep -i 'composer' | grep -i 'install' > /dev/null; then
  URL=${args[1]:-"https://${DC_ORO_NAME}.docker.local"}
  # Create config/parameters.yml from dist file if not exists (prevents Incenteev interactive prompts)
  ${DOCKER_COMPOSE_BIN_CMD} run --rm cli bash -c "if [[ ! -f ${DC_ORO_APPDIR}/config/parameters.yml ]] && [[ -f ${DC_ORO_APPDIR}/config/parameters.yml.dist ]]; then cp ${DC_ORO_APPDIR}/config/parameters.yml.dist ${DC_ORO_APPDIR}/config/parameters.yml; fi" || true
  set -x
  ${DOCKER_COMPOSE_BIN_CMD} run --rm -T cli bash -c "composer install --no-interaction" || true
  exit 0
fi

if echo "$first_non_flag_arg" | grep -i 'export\|dump' | grep -i 'db\|database' > /dev/null; then
  DB_DUMP=$DC_ORO_APPDIR/database-$(date +'%Y%m%d%H%M%S').sql.gz
  DB_DUMP_BASENAME=$(echo "${DB_DUMP##*/}")
  touch "${DB_DUMP}"
  if [[ $DC_ORO_DATABASE_SCHEMA == "pgsql" ]] || [[ $DC_ORO_DATABASE_SCHEMA == "postgres" ]] || [[ $DC_ORO_DATABASE_SCHEMA == "postgresql" ]]; then
    DB_EXPORT_CMD="PGPASSWORD=\$DC_ORO_DATABASE_PASSWORD pg_dump -Fp --clean --if-exists -h \$DC_ORO_DATABASE_HOST -p \$DC_ORO_DATABASE_PORT -U \$DC_ORO_DATABASE_USER -d \$DC_ORO_DATABASE_DBNAME"
  elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
    DB_EXPORT_CMD="MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysqldump --no-tablespaces --column-statistics=0 --set-gtid-purged=OFF --quick --max-allowed-packet=16M --disable-keys --hex-blob --no-autocommit --insert-ignore --skip-lock-tables --single-transaction -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME | sed -E 's/[Dd][Ee][Ff][Ii][Nn][Ee][Rr][ ]*=[ ]*[^*]*\*/DEFINER=CURRENT_USER \*/'"
  fi

  msg_info "Starting export of the database..."
  msg_info "Database: $DC_ORO_DATABASE_HOST:$DC_ORO_DATABASE_PORT/$DC_ORO_DATABASE_DBNAME"
  msg_info "Export to: $DB_DUMP"
  
  export_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run --quiet --rm -v \"${DB_DUMP}:/${DB_DUMP_BASENAME}\" database-cli bash -c \"$DB_EXPORT_CMD | gzip > /${DB_DUMP_BASENAME}\""
  run_with_spinner "Exporting database" "$export_cmd" || exit $?
  
  msg_info "Saved to: $DB_DUMP"
  exit 0
fi



# Check if command is a special OroDC command (not PHP, not Docker Compose)
is_orodc_special_command() {
  local cmd="$1"
  case "$cmd" in
    psql|mysql|database-cli|ssh|cli|install|purge|help|man|tests|test|bash|config-refresh|refresh-config)
      return 0
      ;;
    # Database import/export commands
    importdb|exportdb|databaseimport|databaseexport|dbimport|dbexport)
      return 0
      ;;
    # Platform update commands
    platformupdate|updateplatform)
      return 0
      ;;
    *)
      # Check pattern-based commands
      if echo "$cmd" | grep -qi 'import.*\(db\|database\)'; then return 0; fi
      if echo "$cmd" | grep -qi '\(export\|dump\).*\(db\|database\)'; then return 0; fi
      if echo "$cmd" | grep -qi '\(db\|database\).*\(import\|export\)'; then return 0; fi
      if echo "$cmd" | grep -qi 'update.*platform\|platform.*update'; then return 0; fi
      if echo "$cmd" | grep -qi '^cache:'; then return 0; fi
      if echo "$cmd" | grep -qi '\(set\|update\).*\(url\|uri\)'; then return 0; fi
      if echo "$cmd" | grep -qi 'composer.*install'; then return 0; fi
      return 1
      ;;
  esac
}

# Show interactive menu when no arguments provided and in interactive terminal
# This must be checked BEFORE PHP redirect to prevent menu from being bypassed
if [[ $# -eq 0 ]] && [[ -z "${first_non_flag_arg:-}" ]] && [[ ${#args[@]} -eq 0 ]] && [[ ${#left_flags[@]} -eq 0 ]] && [[ ${#right_flags[@]} -eq 0 ]] && [[ ${#left_options[@]} -eq 0 ]] && [[ ${#right_options[@]} -eq 0 ]] && [[ -t 0 ]] && [[ -z "${DC_ORO_NO_MENU:-}" ]]; then
  # Check if current directory is an OroPlatform project
  if ! is_oroplatform_project "$PWD"; then
    # Try to switch to last used environment
    last_env=$(get_last_used_environment 2>/dev/null)
    if [[ -n "$last_env" ]] && [[ -d "$last_env" ]] && [[ "$last_env" != "$PWD" ]]; then
      msg_info "No project found in current directory."
      msg_info "Switching to last used environment: $(basename "$last_env")"
      cd "$last_env" || {
        show_interactive_menu
        exit $?
      }
      # Restart script in new directory
      unset DC_ORO_NAME
      unset DC_ORO_CONFIG_DIR
      unset COMPOSE_PROJECT_NAME
      exec "$0"
    fi
  fi
  show_interactive_menu
  exit $?
fi

# Handle PHP flags (redirect to PHP CLI when appropriate)
# Only redirect with bash -c for implicit PHP commands (flags only, no command)
# For explicit 'php' command, use direct exec for interactive mode
if [[ "$first_non_flag_arg" == "php" ]]; then
  # Explicit php command - use direct exec for interactive mode
  php_only_args=()
  for arg in "${args[@]}"; do
    if [[ "$arg" != "php" ]]; then
      php_only_args+=("$arg")
    fi
  done
  php_args=("${left_flags[@]}" "${left_options[@]}" "${php_only_args[@]}" "${right_flags[@]}" "${right_options[@]}")
  if [ "$DEBUG" ]; then echo "DEBUG: Direct PHP exec with args: ${php_args[*]}" >&2; fi
  execute_in_container "cli" "php" "${php_args[@]}"
elif [[ -z "$first_non_flag_arg" ]] && ([[ ${#left_flags[@]} -gt 0 ]] || [[ ${#right_flags[@]} -gt 0 ]] || [[ ${#right_options[@]} -gt 0 ]]); then
  # Only flags, no command - this is implicit PHP (orodc -v, orodc --version)
  # Setup logging for PHP binary usage
  setup_php_logging "$@"
  php_args=("${left_flags[@]}" "${left_options[@]}" "${args[@]}" "${right_flags[@]}" "${right_options[@]}")
  if [ "$DEBUG" ]; then echo "DEBUG: Implicit PHP redirect with args: ${php_args[*]}" >&2; fi
  execute_in_container "cli" "php" "${php_args[@]}"
fi

if echo "$first_non_flag_arg" | grep -i '^mysql' > /dev/null; then
  # Extract mysql arguments (everything after 'mysql')
  mysql_args=("${args[@]:1}")
  exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} run -i --rm -e MYSQL_PWD="$DC_ORO_DATABASE_PASSWORD" database-cli mysql -h"$DC_ORO_DATABASE_HOST" -P"$DC_ORO_DATABASE_PORT" -u"$DC_ORO_DATABASE_USER" "$DC_ORO_DATABASE_DBNAME" "${mysql_args[@]}"
fi

if echo "$first_non_flag_arg" | grep -i '^psql' > /dev/null; then
  # Extract psql arguments (everything after 'psql')
  psql_args=("${args[@]:1}")
  exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} run -i --rm -e PGPASSWORD="$DC_ORO_DATABASE_PASSWORD" database-cli psql -h "$DC_ORO_DATABASE_HOST" -p "$DC_ORO_DATABASE_PORT" -U "$DC_ORO_DATABASE_USER" -d "$DC_ORO_DATABASE_DBNAME" "${psql_args[@]}"
fi

if echo "$first_non_flag_arg" | grep -i '^database-cli' > /dev/null; then
  # Extract database-cli arguments (everything after 'database-cli')
  database_cli_args=("${args[@]:1}")
  # If no arguments provided, default to bash
  if [[ ${#database_cli_args[@]} -eq 0 ]]; then
    database_cli_args=("bash")
  fi
  exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} run -i --rm -e PGPASSWORD="$DC_ORO_DATABASE_PASSWORD" database-cli "${database_cli_args[@]}"
fi

if [ $# -eq 0 ] || [ "${args[0]}" = "ssh" ]; then
  SSH_HOST=${DC_ORO_SSH_BIND_HOST:-127.0.0.1}
  
  # Get SSH port directly (fast operation, no spinner needed)
  SSH_PORT=$(${DOCKER_BIN} inspect "$(${DOCKER_COMPOSE_BIN_CMD} ps | grep ssh | awk '{ print $1 }')" | jq -r '.[0].NetworkSettings.Ports["22/tcp"][0].HostPort')
  
  if [[ -z "$SSH_PORT" ]]; then
    msg_error "SSH service is not running. Start it with: orodc up -d"
    exit 1
  fi

  set -x
  exec ssh \
    -o SendEnv=COMPOSER_AUTH \
    -o UserKnownHostsFile=/dev/null \
    -o StrictHostKeyChecking=no \
    -o 'ForwardAgent no' \
    -o IdentitiesOnly=yes \
    -i "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519" \
    -p "${SSH_PORT}" \
    ${ORO_DC_SSH_ARGS} \
    "${DC_ORO_USER_NAME}@${SSH_HOST}" \
    "${args[@]:1}" \
    "${right_flags[@]}" \
    "${right_options[@]}"
fi

# Function to check if command is a built-in docker compose command
is_docker_compose_command() {
  local cmd="$1"
  # Get list of docker compose commands dynamically
  local compose_commands
  compose_commands=$(${DOCKER_COMPOSE_BIN} --help 2>/dev/null | grep -A 100 "Commands:" | grep "^  [a-z]" | awk '{print $1}' | tr '\n' '|')
  compose_commands="${compose_commands%|}" # remove trailing |
  
  # Check if command matches any docker compose command
  echo "$cmd" | grep -qE "^(${compose_commands})$"
}

# Function moved earlier to avoid "command not found" error

is_special_orodc_command() {
  local cmd="$1"
  case "$cmd" in
    ssh|cli|pgsql|psql|mysql|database-cli|install|purge|test|tests|bash|help|man|init|codex|gemini|cursor|agents|status|proxy|image|docker-build|compose|database|db|conf|search|cache|platform-update|doctor|exec|php|composer|env)
      return 0
      ;;
    *)
      # Check complex patterns that are handled specially
      if echo "$cmd" | grep -qi 'import.*\(db\|database\)'; then return 0; fi
      if echo "$cmd" | grep -qi '\(set\|update\).*\(url\|uri\)'; then return 0; fi
      if echo "$cmd" | grep -qi '^cache'; then return 0; fi
      if [[ "$cmd" == "platform" ]]; then return 0; fi
      if echo "$cmd" | grep -qi 'composer.*install'; then return 0; fi
      if echo "$cmd" | grep -qi '\(export\|dump\).*\(db\|database\)'; then return 0; fi
      return 1
      ;;
  esac
}


# Check if any argument is a docker compose command (will be handled at the end)
is_docker_compose_cmd=false
if [[ ${#args[@]} -gt 0 ]]; then
  for arg in "${args[@]}"; do
    if is_docker_compose_command "$arg"; then
      is_docker_compose_cmd=true
      break
    fi
  done
fi
if [[ -n "${DEBUG:-}" ]]; then
  echo "DEBUG: is_docker_compose_cmd=$is_docker_compose_cmd, args=${args[*]:-none}" >&2
  echo "DEBUG: args[0]=${args[0]:-empty}, args length=${#args[@]}" >&2
fi


# Mount external PHP files will be called after DOCKER_COMPOSE_RUN_CMD is defined

if [[ "$is_docker_compose_cmd" != "true" ]]; then
  # Check if any argument contains a .php file
  has_php_file=false
  for arg in "${args[@]}" "${right_flags[@]}" "${right_options[@]}"; do
    if [[ "$arg" == *.php ]]; then
      has_php_file=true
      break
    fi
  done

# If arguments contain .php file, redirect to PHP
if [[ "$has_php_file" == true ]]; then
  # Special handling for bash -c commands with PHP files
  if [[ "${args[0]}" == "bash" && "${right_flags[0]}" == "-c" ]]; then
    # For bash -c 'php script.php', reconstruct proper argument order
    exec ${DOCKER_COMPOSE_RUN_CLI_CMD} ${left_flags[@]} ${left_options[@]} cli bash -c "${args[@]:1}" "${right_options[@]}"
  else
    # Prepend 'php' to the command if not already present
    if [[ "${args[0]}" != "php" ]]; then
      # For PHP files, treat left_flags as PHP flags (not docker compose flags)
      # Only use actual docker compose flags from left_flags
      docker_flags=()
      php_flags=()
      for flag in "${left_flags[@]}"; do
        case "$flag" in
          -d|-e|--env|--env-file|--label|--name|--user|--workdir|--entrypoint|--platform)
            docker_flags+=("$flag")
            ;;
          *)
            php_flags+=("$flag")
            ;;
        esac
      done
      execute_in_container "cli" "php" "${php_flags[@]}" "${right_flags[@]}" "${right_options[@]}" "${args[@]}"
    else
      execute_in_container "cli" "${args[@]}" "${right_flags[@]}" "${right_options[@]}"
    fi
  fi
fi
fi

# Auto-add --no-interaction to composer install/update commands
if [[ "$first_non_flag_arg" == "composer" ]] && [[ "${args[1]}" =~ ^(install|update|require|create-project)$ ]]; then
  # Check if --no-interaction is not already present
  has_no_interaction=false
  for flag in "${right_flags[@]}" "${right_options[@]}" "${args[@]:2}"; do
    if [[ "$flag" == "--no-interaction" ]] || [[ "$flag" == "-n" ]]; then
      has_no_interaction=true
      break
    fi
  done
  
  if [[ "$has_no_interaction" == "false" ]]; then
    # Add --no-interaction flag
    right_flags+=("--no-interaction")
    if [[ -n "${DEBUG:-}" ]]; then
      echo "DEBUG: Auto-added --no-interaction to composer ${args[1]}" >&2
    fi
  fi
  
  # For composer install, create config/parameters.yml from dist file if not exists (prevents Incenteev interactive prompts)
  if [[ "${args[1]}" == "install" ]]; then
    ${DOCKER_COMPOSE_BIN_CMD} run --rm cli bash -c "if [[ ! -f ${DC_ORO_APPDIR}/config/parameters.yml ]] && [[ -f ${DC_ORO_APPDIR}/config/parameters.yml.dist ]]; then cp ${DC_ORO_APPDIR}/config/parameters.yml.dist ${DC_ORO_APPDIR}/config/parameters.yml; fi" 2>/dev/null || true
    if [[ -n "${DEBUG:-}" ]]; then
      echo "DEBUG: Prepared config/parameters.yml from dist file" >&2
    fi
  fi
fi

# If command is not a docker compose built-in command and not a special orodc command, redirect to CLI container
if [[ -n "${DEBUG:-}" ]]; then
  echo "DEBUG: Checking special commands: args[0]='${args[0]}', first_non_flag_arg='$first_non_flag_arg'" >&2
fi

if [[ ${#args[@]} -gt 0 ]] && [[ "$is_docker_compose_cmd" != "true" ]] && ! is_special_orodc_command "$first_non_flag_arg"; then
  echo "Running command in 'cli' service..."
  # Special handling for bash -c commands
  if [[ "${args[0]}" == "bash" && "${right_flags[0]}" == "-c" ]]; then
    # For bash -c 'command', reconstruct proper argument order
    exec ${DOCKER_COMPOSE_RUN_CMD} ${left_flags[@]} ${left_options[@]} cli bash -c "${args[@]:1}" "${right_options[@]}"
  else
    # Pass arguments directly to docker compose exec without additional escaping
    # Combine args with right_flags and right_options in proper order
    cli_cmd=$(build_docker_compose_run_cmd "cli" "${args[@]}")
    exec bash -c "$cli_cmd"
  fi
fi

# Note: 'cli' command is handled by router (case statement) - don't process it here

if echo ${args[0]} | grep -i '^install' | grep -i 'without' | grep -i 'demo' > /dev/null; then
  export XDEBUG_MODE=off
  
  # Get previous timing for statistics only
  prev_install_timing=$(get_previous_timing "install")
  
  # Record start time for full install
  install_start_time=$(date +%s)
  
  # Clear cache
  cache_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm cli bash -c \"[[ -d ${DC_ORO_APPDIR}/var/cache ]] && rm -rf ${DC_ORO_APPDIR}/var/cache/* || true\""
  run_with_spinner "Clearing cache" "$cache_cmd" || exit $?
  
  # Backup existing config/parameters.yml if exists, then create from dist file
  params_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm cli bash -c \"
    if [[ -f ${DC_ORO_APPDIR}/config/parameters.yml ]]; then
      BACKUP_NAME=\\\"${DC_ORO_APPDIR}/config/parameters.yml.\$(date +%Y%m%d%H%M).backup\\\"
      mv ${DC_ORO_APPDIR}/config/parameters.yml \\\"\\\${BACKUP_NAME}\\\"
      echo \\\"Backed up existing parameters.yml to \\\${BACKUP_NAME}\\\"
    fi
    if [[ -f ${DC_ORO_APPDIR}/config/parameters.yml.dist ]]; then
      cp ${DC_ORO_APPDIR}/config/parameters.yml.dist ${DC_ORO_APPDIR}/config/parameters.yml
    fi
  \""
  run_with_spinner "Preparing config files" "$params_cmd" || exit $?
  
  # Run composer install with spinner (use -T to disable pseudo-TTY for non-interactive mode)
  composer_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm -T cli bash -c \"composer install --no-interaction\""
  run_with_spinner "Running composer install" "$composer_cmd" || exit $?
  
  # Run oro:install with spinner (use -T to disable pseudo-TTY for non-interactive mode)
  install_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm -T cli bash -c \"php bin/console --env=prod --timeout=1800 oro:install --language=en --formatting-code=en_US --organization-name='Acme Inc.' --user-name=admin --user-email=admin@example.com --user-firstname=John --user-lastname=Doe --user-password='\\\$ecretPassw0rd' --application-url='https://${DC_ORO_NAME:-unnamed}.docker.local/' --sample-data=n\""
  run_with_spinner "Installing Application without demo data" "$install_cmd" || exit $?
  
  # Calculate and save total install time
  install_end_time=$(date +%s)
  install_duration=$((install_end_time - install_start_time))
  save_timing "install" "$install_duration"
  
  msg_ok "Installation completed in ${install_duration}s"
  echo "" >&2
  msg_info "To start containers, run: orodc up -d"
  echo "" >&2
  
  exit 0
elif echo ${args[0]} | grep -i '^install$' > /dev/null; then
  export XDEBUG_MODE=off
  
  # Get previous timing for statistics only
  prev_install_timing=$(get_previous_timing "install")
  
  # Record start time for full install
  install_start_time=$(date +%s)
  
  # Clear cache
  cache_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm cli bash -c \"[[ -d ${DC_ORO_APPDIR}/var/cache ]] && rm -rf ${DC_ORO_APPDIR}/var/cache/* || true\""
  run_with_spinner "Clearing cache" "$cache_cmd" || exit $?
  
  # Backup existing config/parameters.yml if exists, then create from dist file
  params_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm cli bash -c \"
    if [[ -f ${DC_ORO_APPDIR}/config/parameters.yml ]]; then
      BACKUP_NAME=\\\"${DC_ORO_APPDIR}/config/parameters.yml.\$(date +%Y%m%d%H%M).backup\\\"
      mv ${DC_ORO_APPDIR}/config/parameters.yml \\\"\\\${BACKUP_NAME}\\\"
      echo \\\"Backed up existing parameters.yml to \\\${BACKUP_NAME}\\\"
    fi
    if [[ -f ${DC_ORO_APPDIR}/config/parameters.yml.dist ]]; then
      cp ${DC_ORO_APPDIR}/config/parameters.yml.dist ${DC_ORO_APPDIR}/config/parameters.yml
    fi
  \""
  run_with_spinner "Preparing config files" "$params_cmd" || exit $?
  
  # Run composer install with spinner (use -T to disable pseudo-TTY for non-interactive mode)
  composer_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm -T cli bash -c \"composer install --no-interaction\""
  run_with_spinner "Running composer install" "$composer_cmd" || exit $?
  
  # Run oro:install with spinner (use -T to disable pseudo-TTY for non-interactive mode)
  install_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm -T cli bash -c \"php bin/console --env=prod --timeout=1800 oro:install --language=en --formatting-code=en_US --organization-name='Acme Inc.' --user-name=admin --user-email=admin@example.com --user-firstname=John --user-lastname=Doe --user-password='\\\$ecretPassw0rd' --application-url='https://${DC_ORO_NAME:-unnamed}.docker.local/' --sample-data=y\""
  run_with_spinner "Installing Application with sample data" "$install_cmd" || exit $?
  
  # Calculate and save total install time
  install_end_time=$(date +%s)
  install_duration=$((install_end_time - install_start_time))
  save_timing "install" "$install_duration"
  
  msg_ok "Installation completed in ${install_duration}s"
  echo "" >&2
  msg_info "To start containers, run: orodc up -d"
  echo "" >&2
  
  exit 0
fi


# Handle tests commands - unified entry point
if [[ "$first_non_flag_arg" == "tests" ]]; then
  # CRITICAL COMPOSE MERGING LOGIC - READ CAREFULLY BEFORE MODIFYING
  # =================================================================
  # 
  # PROBLEM: Test services in docker-compose-test.yml reference volumes (like 'appcode') 
  # that are defined in the main docker-compose.yml. Simply using docker-compose-test.yml 
  # alone causes "undefined volume" errors.
  #
  # SOLUTION: We must merge ALL compose files into a single compose.yml that contains:
  # 1. Base services and volumes from docker-compose.yml
  # 2. Database-specific services from docker-compose-{pgsql|mysql}.yml
  # 3. User customizations from .docker-compose.user.yml (if exists)
  # 4. Test services from docker-compose-test.yml
  #
  # WHY USE DOCKER_COMPOSE_BIN_CMD: This variable already contains the properly constructed
  # command with all base compose files in the correct order. We reuse this logic instead
  # of duplicating the file selection logic.
  #
  # WHY GENERATE compose.yml: The 'down' and 'purge' commands need to know about test 
  # services to stop them properly. By creating a merged compose.yml, these commands
  # can find and stop test containers even after the test session ends.
  
  # Reuse existing compose command logic and add test file
  # DOCKER_COMPOSE_BIN_CMD already contains: base + database + user compose files
  TEST_AWARE_COMPOSE_CMD="${DOCKER_COMPOSE_BIN_CMD}"
  if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-test.yml" ]]; then
    TEST_AWARE_COMPOSE_CMD="${TEST_AWARE_COMPOSE_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-test.yml"
  fi
  
  # Generate properly merged compose.yml using 'docker compose config'
  # This command merges all compose files and resolves all references (volumes, networks, etc.)
  if DC_ORO_NAME="$DC_ORO_NAME" bash -c "${TEST_AWARE_COMPOSE_CMD} config" > "${DC_ORO_CONFIG_DIR}/compose.yml" 2>/dev/null; then
    msg_info "All services merged into compose.yml for persistent management"
  else
    msg_warning "Failed to merge compose files, falling back to test-only mode"
    # Fallback: create basic merged file (this will likely cause volume errors)
    # This fallback exists for edge cases but is not the intended path
    cat > "${DC_ORO_CONFIG_DIR}/compose.yml" << 'EOF'
# Auto-generated merged compose file including test services
# This ensures test services are included in down/purge operations
# WARNING: This fallback may cause "undefined volume" errors
EOF
    if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-test.yml" ]]; then
      cat "${DC_ORO_CONFIG_DIR}/docker-compose-test.yml" >> "${DC_ORO_CONFIG_DIR}/compose.yml"
    fi
  fi
  
  # Build test-aware compose command using the merged compose.yml
  # IMPORTANT: We use the merged compose.yml file instead of multiple -f flags
  # because it already contains all services and resolved volume references
  TEST_COMPOSE_CMD="${DOCKER_COMPOSE_BIN} -f ${DC_ORO_CONFIG_DIR}/compose.yml"
  
  # Use test-cli container for test commands
  CLI_SERVICE="test-cli"
  
  # Define test-specific variables with fallbacks to main variables
  DC_ORO_TEST_DATABASE_HOST="${DC_ORO_TEST_DATABASE_HOST:-${DC_ORO_DATABASE_HOST:-database}}"
  DC_ORO_TEST_DATABASE_PORT="${DC_ORO_TEST_DATABASE_PORT:-${DC_ORO_DATABASE_PORT:-5432}}"
  DC_ORO_TEST_DATABASE_USER="${DC_ORO_TEST_DATABASE_USER:-${DC_ORO_DATABASE_USER:-oro_db_user}}"
  DC_ORO_TEST_DATABASE_PASSWORD="${DC_ORO_TEST_DATABASE_PASSWORD:-${DC_ORO_DATABASE_PASSWORD:-oro_db_pass}}"
  DC_ORO_TEST_DATABASE_DBNAME="${DC_ORO_TEST_DATABASE_DBNAME:-${DC_ORO_DATABASE_DBNAME:-oro_db}_test}"
  
  # Create test database URI using parse_dsn_uri function
  TEST_DB_URI="postgres://${DC_ORO_TEST_DATABASE_USER}:${DC_ORO_TEST_DATABASE_PASSWORD}@${DC_ORO_TEST_DATABASE_HOST}:${DC_ORO_TEST_DATABASE_PORT}/${DC_ORO_TEST_DATABASE_DBNAME}"
  parse_dsn_uri "$TEST_DB_URI" "database" "DC_ORO_TEST"
  # Function creates DC_ORO_TEST_DATABASE_URI automatically
  
  # Handle different test subcommands
  case "${args[1]}" in
    "install"|"setup")
      msg_info "Installing test environment and database..."
      # Start all required services
      ${TEST_COMPOSE_CMD} up -d >/dev/null 2>&1
      
      
      # Check if test database already exists
      DB_EXISTS=false
      if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]]; then
        # Check PostgreSQL database existence
        if ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=\$DC_ORO_DATABASE_PASSWORD psql -h \$DC_ORO_DATABASE_HOST -p \$DC_ORO_DATABASE_PORT -U \$DC_ORO_DATABASE_USER -d \$DC_ORO_DATABASE_DBNAME -c 'SELECT 1 FROM pg_database WHERE datname = '\''${DC_ORO_TEST_DATABASE_DBNAME}'\'';'" 2>/dev/null | grep -q "1 row"; then
          DB_EXISTS=true
        fi
      elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]]; then
        # Check MySQL/MariaDB database existence
        if ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME -e 'SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '\''${DC_ORO_TEST_DATABASE_DBNAME}'\'';'" 2>/dev/null | grep -q "${DC_ORO_TEST_DATABASE_DBNAME}"; then
          DB_EXISTS=true
        fi
      fi
      
      if [[ "$DB_EXISTS" == "true" ]]; then
        echo "Test database ${DC_ORO_TEST_DATABASE_DBNAME} already exists, skipping database setup..."
      else
        echo "Creating test database ${DC_ORO_TEST_DATABASE_DBNAME}..."
        if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]]; then
          # PostgreSQL commands using test-specific environment variables
          ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=${DC_ORO_TEST_DATABASE_PASSWORD} psql -h ${DC_ORO_TEST_DATABASE_HOST} -p ${DC_ORO_TEST_DATABASE_PORT} -U ${DC_ORO_TEST_DATABASE_USER} -d \$DC_ORO_DATABASE_DBNAME -c 'SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '\''${DC_ORO_TEST_DATABASE_DBNAME}'\'';'" 2>/dev/null || true
          ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=${DC_ORO_TEST_DATABASE_PASSWORD} psql -h ${DC_ORO_TEST_DATABASE_HOST} -p ${DC_ORO_TEST_DATABASE_PORT} -U ${DC_ORO_TEST_DATABASE_USER} -d \$DC_ORO_DATABASE_DBNAME -c 'DROP DATABASE IF EXISTS ${DC_ORO_TEST_DATABASE_DBNAME};'" 2>/dev/null || true
          ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=${DC_ORO_TEST_DATABASE_PASSWORD} psql -h ${DC_ORO_TEST_DATABASE_HOST} -p ${DC_ORO_TEST_DATABASE_PORT} -U ${DC_ORO_TEST_DATABASE_USER} -d \$DC_ORO_DATABASE_DBNAME -c 'CREATE DATABASE ${DC_ORO_TEST_DATABASE_DBNAME};'" || {
            echo "Failed to create test database"
            exit 1
          }
        elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]]; then
          # MySQL/MariaDB commands using environment variables like existing mysql command
          ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME -e 'DROP DATABASE IF EXISTS ${DC_ORO_TEST_DATABASE_DBNAME};'" 2>/dev/null || true
          ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME -e 'CREATE DATABASE ${DC_ORO_TEST_DATABASE_DBNAME};'" || {
            echo "Failed to create test database"
            exit 1
          }
        fi
      fi
      
      # Clear test cache and install (only if database was created)
      if [[ "$DB_EXISTS" == "false" ]]; then
        msg_info "Setting up Oro test environment..."
        echo "Running cache clear in 'test-cli' service..."
        ${TEST_COMPOSE_CMD} run --rm test-cli bash -c "rm -rf var/cache/test" 2>/dev/null || true
        echo "Running oro:install in 'test-cli' service..."
        # Run oro:install in background and monitor output for consumer messages
        ${TEST_COMPOSE_CMD} run --rm test-cli bin/console oro:install --disabled-listeners=all 2>&1 | while IFS= read -r line; do
          echo "$line"
          if [[ "$line" == *"Processing consumer messages"* ]]; then
            echo "==> Detected consumer message processing, stopping test-consumer..."
            # Wait for consumer processes to start
            for i in {1..10}; do
              if ${TEST_COMPOSE_CMD} exec -T test-cli bash -c "ps aux | grep 'oro:message-queue:consume' | grep -v grep >/dev/null 2>&1"; then
                echo "Consumer processes found, stopping them..."
                ${TEST_COMPOSE_CMD} exec -T test-cli bash -c "pids=\$(ps aux | grep 'oro:message-queue:consume' | grep -v grep | awk '{print \$2}'); [ -n \"\$pids\" ] && echo \$pids | xargs kill -9" 2>/dev/null || true
                break
              fi
              echo "Waiting for consumer processes to start... ($i/10)"
              sleep 0.5
            done
          fi
        done
      else
        echo "Oro test environment already installed, skipping oro:install..."
      fi
      
      # Warm up test environment caches
      msg_info "Warming up test environment caches..."
      echo "Warming up test cache..."
      ${TEST_COMPOSE_CMD} run --rm test-cli bin/console cache:warmup --env=test 2>/dev/null || true

      # Generate behat.yml with correct URLs for test environment
      msg_info "Generating behat.yml with test environment URLs..."
      BEHAT_DIST_FILE="${DC_ORO_APPDIR}/vendor/oro/platform/src/Oro/Bundle/TestFrameworkBundle/Resources/config/behat.yml.dist"
      BEHAT_CONFIG_FILE="${DC_ORO_APPDIR}/behat.yml"
      
      if [[ -f "$BEHAT_DIST_FILE" ]]; then
        # Copy behat.yml.dist and replace URLs with sed for test environment
        cp "$BEHAT_DIST_FILE" "$BEHAT_CONFIG_FILE"
        
        # Replace localhost:4444 with test-selenium:4444 for WebDriver host
        sed -i '' "s|localhost:4444|test-selenium:4444|g" "$BEHAT_CONFIG_FILE" 2>/dev/null || sed -i "s|localhost:4444|test-selenium:4444|g" "$BEHAT_CONFIG_FILE"
        # Replace localhost:9515 with test-selenium:9515 for ChromeDriver host  
        sed -i '' "s|localhost:9515|test-selenium:9515|g" "$BEHAT_CONFIG_FILE" 2>/dev/null || sed -i "s|localhost:9515|test-selenium:9515|g" "$BEHAT_CONFIG_FILE"
        
        # Note: OroCommerce admin panel is accessible at root path, not /admin/
        echo "Keeping base_url as root path for admin panel access"
        
        # Add necessary Chrome arguments for Docker environment to the main sessions (port 4444)
        # This fixes the "DevToolsActivePort file doesn't exist" error
        if grep -q -- '--load-extension.*chrome-extension' "$BEHAT_CONFIG_FILE"; then
          # Create temporary file with the Chrome arguments to add
          TEMP_CHROME_ARGS=$(mktemp)
          cat > "$TEMP_CHROME_ARGS" << 'EOF'
                                        - "--no-sandbox"
                                        - "--disable-gpu"
                                        - "--headless"
                                        - "--disable-dev-shm-usage"
                                        - "--no-first-run"
                                        - "--disable-extensions"
                                        - "--disable-renderer-backgrounding"
EOF
          
          # Use awk to insert the Chrome arguments after the line containing chrome-extension
          awk '
            /--load-extension.*chrome-extension/ {
              print $0
              while ((getline line < "'"$TEMP_CHROME_ARGS"'") > 0) print line
              close("'"$TEMP_CHROME_ARGS"'")
              next
            }
            { print }
          ' "$BEHAT_CONFIG_FILE" > "${BEHAT_CONFIG_FILE}.tmp" && mv "${BEHAT_CONFIG_FILE}.tmp" "$BEHAT_CONFIG_FILE"
          
          # Clean up temporary file
          rm -f "$TEMP_CHROME_ARGS"
        fi
        
        echo "Generated behat.yml with test environment URLs and Docker-compatible Chrome options"
      else
        echo "Warning: behat.yml.dist not found, skipping behat.yml generation"
      fi
      
      # Start test services including test-consumer
      ${TEST_COMPOSE_CMD} up -d test-fpm test-nginx test-selenium test-consumer
      echo "Test environment setup completed!"
      exit 0
      ;;
      
    "purge"|"destroy")
      echo "Purging test environment..."
      
      # Build compose command without test file to get list of test services
      MAIN_COMPOSE_CMD="${DOCKER_COMPOSE_BIN} -f ${DC_ORO_CONFIG_DIR}/docker-compose.yml"
      
      # Add database-specific compose file
      if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]];then
        MAIN_COMPOSE_CMD="${MAIN_COMPOSE_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-pgsql.yml"
      elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
        MAIN_COMPOSE_CMD="${MAIN_COMPOSE_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-mysql.yml"
      fi
      
      # Add user compose file if exists
      if [[ -f "$DC_ORO_APPDIR/.docker-compose.user.yml" ]]; then
        MAIN_COMPOSE_CMD="${MAIN_COMPOSE_CMD} -f $DC_ORO_APPDIR/.docker-compose.user.yml"
      fi
      
      # Get test services from docker-compose-test.yml using yq
      if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-test.yml" ]]; then
        TEST_SERVICES=$(yq e '.services | keys | .[]' "${DC_ORO_CONFIG_DIR}/docker-compose-test.yml" 2>/dev/null | tr '\n' ' ')
        if [[ -n "$TEST_SERVICES" ]]; then
          echo "Stopping test services: $TEST_SERVICES"
          ${TEST_COMPOSE_CMD} stop $TEST_SERVICES 2>/dev/null || true
          ${TEST_COMPOSE_CMD} rm -f $TEST_SERVICES 2>/dev/null || true
        fi
      fi
      
      # Drop test database using the same approach as existing database commands
      # Test database name = main database name + _test suffix
      echo "Dropping test database ${DC_ORO_TEST_DATABASE_DBNAME}..."
      
      if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]]; then
        # PostgreSQL commands using test-specific environment variables
        ${MAIN_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=${DC_ORO_TEST_DATABASE_PASSWORD} psql -h ${DC_ORO_TEST_DATABASE_HOST} -p ${DC_ORO_TEST_DATABASE_PORT} -U ${DC_ORO_TEST_DATABASE_USER} -d \$DC_ORO_DATABASE_DBNAME -c 'SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '\''${DC_ORO_TEST_DATABASE_DBNAME}'\'';'" 2>/dev/null || true
        ${MAIN_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=${DC_ORO_TEST_DATABASE_PASSWORD} psql -h ${DC_ORO_TEST_DATABASE_HOST} -p ${DC_ORO_TEST_DATABASE_PORT} -U ${DC_ORO_TEST_DATABASE_USER} -d \$DC_ORO_DATABASE_DBNAME -c 'DROP DATABASE ${DC_ORO_TEST_DATABASE_DBNAME};'" 2>/dev/null || true
      elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]]; then
        # MySQL/MariaDB commands using environment variables like existing mysql command
        ${MAIN_COMPOSE_CMD} run --rm database-cli bash -c "MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME -e 'DROP DATABASE IF EXISTS ${DC_ORO_TEST_DATABASE_DBNAME};'" 2>/dev/null || true
      fi
      
      # Remove merged compose.yml to restore original configuration
      # IMPORTANT: This cleanup prevents the merged compose.yml from interfering 
      # with normal operations. The merged file should only exist during test sessions.
      rm -f "${DC_ORO_CONFIG_DIR}/compose.yml" 2>/dev/null || true
      echo "Test environment destroyed!"
      exit 0
      ;;
      
    "status")
      echo "Test environment status:"
      ${TEST_COMPOSE_CMD} ps test-fpm test-nginx test-selenium
      echo ""
      echo "Test application: Available in Docker network (test-nginx)"
      echo "Selenium WebDriver: Available in Docker network (test-selenium:4444)"
      exit 0
      ;;
      
    "consumer-stop")
      echo "Stopping test consumer (SIGSTOP)..."
      ${TEST_COMPOSE_CMD} exec test-cli bash -c "pids=\$(pgrep -f 'oro:message-queue:consume'); [ -n \"\$pids\" ] && echo \$pids | xargs kill -STOP" 2>/dev/null || echo "Consumer process not found or already stopped"
      exit 0
      ;;
      
    "consumer-start")
      echo "Starting test consumer (SIGCONT)..."
      ${TEST_COMPOSE_CMD} exec test-cli bash -c "pids=\$(pgrep -f 'oro:message-queue:consume'); [ -n \"\$pids\" ] && echo \$pids | xargs kill -CONT" 2>/dev/null || echo "Consumer process not found"
      exit 0
      ;;
      
    "consumer-kill")
      echo "Killing test consumer (SIGKILL)..."
      ${TEST_COMPOSE_CMD} exec test-cli bash -c "pids=\$(pgrep -f 'oro:message-queue:consume'); [ -n \"\$pids\" ] && echo \$pids | xargs kill -9" 2>/dev/null || echo "Consumer process not found"
      exit 0
      ;;
      
    "consumer-status")
      echo "Test consumer status:"
      ${TEST_COMPOSE_CMD} exec test-cli bash -c "ps aux | grep -v grep | grep 'oro:message-queue:consume' || echo 'Consumer process not running'"
      exit 0
      ;;
      
    *)
      # Handle any other command by executing it in test-cli container
      # This makes 'orodc tests' a full replacement for 'orodc' but in test environment
      msg_info "Running command in 'test-cli' service..."
      ${TEST_COMPOSE_CMD} up -d >/dev/null 2>&1
      
      # For tests command, use arguments after 'tests' without parsing
      # Skip 'tests' (first argument) and use everything else as-is
      test_command_args=("${args[@]:1}")
      exec ${TEST_COMPOSE_CMD} run --rm test-cli "${test_command_args[@]}"
      ;;
  esac
  exit 0
fi

if [[ -n "${DEBUG:-}" ]]; then
  echo "DEBUG: Checking purge condition: first_non_flag_arg='$first_non_flag_arg'" >&2
fi

# Handle config-refresh command (clear cached compose files and force resync)
if [[ "$first_non_flag_arg" == "config-refresh" ]] || [[ "$first_non_flag_arg" == "refresh-config" ]]; then
  msg_info "Clearing cached compose files from ${DC_ORO_CONFIG_DIR}..."
  
  # Remove compose files from config directory
  if [[ -d "${DC_ORO_CONFIG_DIR}/compose" ]]; then
    rm -rf "${DC_ORO_CONFIG_DIR}/compose"
    msg_ok "Removed cached compose directory"
  fi
  
  if [[ -f "${DC_ORO_CONFIG_DIR}/compose.yml" ]]; then
    rm -f "${DC_ORO_CONFIG_DIR}/compose.yml"
    msg_ok "Removed cached compose.yml"
  fi
  
  # Remove docker directory
  if [[ -d "${DC_ORO_CONFIG_DIR}/docker" ]]; then
    rm -rf "${DC_ORO_CONFIG_DIR}/docker"
    msg_ok "Removed cached docker directory"
  fi
  
  # Remove cached profiles
  if [[ -f "${DC_ORO_CONFIG_DIR}/.cached_profiles" ]]; then
    rm -f "${DC_ORO_CONFIG_DIR}/.cached_profiles"
    msg_ok "Removed cached profiles"
  fi
  
  if [[ -f "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles" ]]; then
    rm -f "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles"
    msg_ok "Removed cached CLI profiles"
  fi
  
  msg_ok "Cache cleared successfully!"
  msg_info "Next orodc command will resync fresh compose files"
  exit 0
fi

# Function to get compatible Node.js versions based on PHP version (sorted newest to oldest)
get_compatible_node_versions() {
  local php_ver="$1"
  case "$php_ver" in
    7.3) echo "16" ;;
    7.4) echo "18 16" ;;
    8.1) echo "22 20 18 16" ;;
    8.2|8.3|8.4) echo "22 20 18" ;;
    8.5) echo "24 22" ;;
    *) echo "22 20 18" ;;
  esac
}

# Additional command routing case
case "$1" in
  # Tests commands - route to tests/*.sh modules
  tests)
    shift
    case "$1" in
      install)
        shift
        exec "${LIBEXEC_DIR}/tests/install.sh" "$@"
        ;;
      run)
        shift
        exec "${LIBEXEC_DIR}/tests/run.sh" "$@"
        ;;
      behat)
        shift
        exec "${LIBEXEC_DIR}/tests/behat.sh" "$@"
        ;;
      phpunit)
        shift
        exec "${LIBEXEC_DIR}/tests/phpunit.sh" "$@"
        ;;
      shell)
        shift
        exec "${LIBEXEC_DIR}/tests/shell.sh" "$@"
        ;;
      *)
        msg_error "Unknown tests command: ${1:-<none>}"
        msg_info "Available: install, run, behat, phpunit, shell"
        exit 1
        ;;
    esac
    ;;

  # Proxy commands - route to proxy/*.sh modules
  proxy)
    shift
    case "$1" in
      up)
        shift
        if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
          execute_with_menu_return "${LIBEXEC_DIR}/proxy/up.sh" "$@"
        else
          exec "${LIBEXEC_DIR}/proxy/up.sh" "$@"
        fi
        ;;
      down)
        shift
        if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
          execute_with_menu_return "${LIBEXEC_DIR}/proxy/down.sh" "$@"
        else
          exec "${LIBEXEC_DIR}/proxy/down.sh" "$@"
        fi
        ;;
      install-certs)
        shift
        if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
          execute_with_menu_return "${LIBEXEC_DIR}/proxy/install-certs.sh" "$@"
        else
          exec "${LIBEXEC_DIR}/proxy/install-certs.sh" "$@"
        fi
        ;;
      restart)
        shift
        if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
          execute_with_menu_return "${LIBEXEC_DIR}/proxy/restart.sh" "$@"
        else
          exec "${LIBEXEC_DIR}/proxy/restart.sh" "$@"
        fi
        ;;
      *)
        msg_error "Unknown proxy command: ${1:-<none>}"
        msg_info "Available: up, down, restart, install-certs"
        exit 1
        ;;
    esac
    ;;

  # Image commands - route to image/*.sh modules
  image)
    shift
    case "$1" in
      build)
        shift
        if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
          execute_with_menu_return "${LIBEXEC_DIR}/image/build.sh" "$@"
        else
          exec "${LIBEXEC_DIR}/image/build.sh" "$@"
        fi
        ;;
      *)
        msg_error "Unknown image command: ${1:-<none>}"
        msg_info "Available: build"
        exit 1
        ;;
    esac
    ;;

  # Docker build command - non-interactive image builder (not in menu)
  docker-build)
    shift
    exec "${LIBEXEC_DIR}/docker-build.sh" "$@"
    ;;

  # Single-file commands
  init)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/init.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/init.sh" "$@"
    fi
    ;;

  list)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/list.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/list.sh" "$@"
    fi
    ;;

  conf)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/conf.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/conf.sh" "$@"
    fi
    ;;

  purge)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/purge.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/purge.sh" "$@"
    fi
    ;;

  config-refresh)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/config-refresh.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/config-refresh.sh" "$@"
    fi
    ;;

  ssh)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/ssh.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/ssh.sh" "$@"
    fi
    ;;

  install)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/install.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/install.sh" "$@"
    fi
    ;;

  cache)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/cache.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/cache.sh" "$@"
    fi
    ;;

  search)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/search.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/search.sh" "$@"
    fi
    ;;

  php)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/php.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/php.sh" "$@"
    fi
    ;;

  composer)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/composer.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/composer.sh" "$@"
    fi
    ;;

  agents)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/agents.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/agents.sh" "$@"
    fi
    ;;

  exec)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/exec.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/exec.sh" "$@"
    fi
    ;;

  platform-update)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/platform-update.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/platform-update.sh" "$@"
    fi
    ;;

  doctor)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/doctor.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/doctor.sh" "$@"
    fi
    ;;

  env)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/env.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/env.sh" "$@"
    fi
    ;;

  status)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/status.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/status.sh" "$@"
    fi
    ;;

  # Convenient aliases for common Docker Compose commands
  start)
    # Alias: orodc start -> orodc compose up -d
    exec "${LIBEXEC_DIR}/compose.sh" up -d "$@"
    ;;

  stop)
    # Alias: orodc stop -> orodc compose stop
    shift
    exec "${LIBEXEC_DIR}/compose.sh" stop "$@"
    ;;

  restart)
    # Alias: orodc restart -> orodc compose restart
    shift
    exec "${LIBEXEC_DIR}/compose.sh" restart "$@"
    ;;

  up|down|logs|ps)
    # Aliases: orodc up/down/logs/ps -> orodc compose up/down/logs/ps
    cmd="$1"
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/compose.sh" "$cmd" "$@"
    else
      exec "${LIBEXEC_DIR}/compose.sh" "$cmd" "$@"
    fi
    ;;

  # Convenient aliases for database commands
  mysql)
    # Alias: orodc mysql -> orodc database mysql
    shift
    exec "${LIBEXEC_DIR}/database/mysql.sh" "$@"
    ;;

  psql)
    # Alias: orodc psql -> orodc database psql
    shift
    exec "${LIBEXEC_DIR}/database/psql.sh" "$@"
    ;;

  cli)
    # Alias: orodc cli -> orodc database cli
    shift
    exec "${LIBEXEC_DIR}/database/cli.sh" "$@"
    ;;

  codex)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/ai/codex.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/ai/codex.sh" "$@"
    fi
    ;;

  gemini)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/ai/gemini.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/ai/gemini.sh" "$@"
    fi
    ;;

  cursor)
    shift
    if [[ -n "${DC_ORO_IS_INTERACTIVE_MENU:-}" ]]; then
      execute_with_menu_return "${LIBEXEC_DIR}/ai/cursor.sh" "$@"
    else
      exec "${LIBEXEC_DIR}/ai/cursor.sh" "$@"
    fi
    ;;

  # ERROR: Old syntax for some Docker Compose commands
  # Show helpful error message with new syntax for less common commands
  # Note: 'exec' is now a separate command for CLI container, not Docker Compose exec
  build|config|cp|create|events|export|images|kill|ls|pause|port|pull|push|rm|run|scale|stats|top|unpause|volumes|wait|watch)
    msg_error "Docker Compose commands must use 'compose' prefix"
    echo ""
    msg_info "Old syntax: orodc $1 ${*:2}"
    msg_info "New syntax: orodc compose $1 ${*:2}"
    echo ""
    msg_info "Run 'orodc help' for more information"
    exit 1
    ;;

  # Unknown command
  *)
    msg_error "Unknown command: $1"
    echo ""
    msg_info "Run 'orodc help' to see available commands"
    exit 1
    ;;
esac
