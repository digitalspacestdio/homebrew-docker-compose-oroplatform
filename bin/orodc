#!/bin/bash
set -e
if [ "$DEBUG" ]; then set -x; fi

# Debug logging to file (always enabled for debugging menu issues)
DEBUG_LOG="/tmp/orodc-debug.log"
debug_log() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$DEBUG_LOG"
}

# Clear log on new session
if [[ "${ORODC_LOG_CLEARED:-}" != "1" ]]; then
  echo "=== New orodc session $(date '+%Y-%m-%d %H:%M:%S') ===" > "$DEBUG_LOG"
  export ORODC_LOG_CLEARED=1
fi

# Restore cursor visibility on exit
trap 'tput cnorm 2>/dev/null || true' EXIT

# Setup logging only when OroDC is used as PHP binary
setup_php_logging() {
  mkdir -p /tmp/.orodc
  local log_file="/tmp/.orodc/$(basename $0).$(echo "$@" | md5sum - | awk '{ print $1 }').log"
  local err_file="/tmp/.orodc/$(basename $0).$(echo "$@" | md5sum - | awk '{ print $1 }').err"
  touch "$log_file" "$err_file"
  exec 1> >(tee "$log_file")
  exec 2> >(tee "$err_file")
}

# Function to display informational messages with consistent formatting
msg_info() {
  # Always write to stderr (>&2) to keep separate from command stdout
  >&2 echo -e "\033[36m==> $1\033[0m"
}

# Function to display warning messages
msg_warning() {
  # Always write to stderr (>&2) to keep separate from command stdout
  >&2 echo -e "\033[33m==> Warning: $1\033[0m"
}

# Function to display success messages
msg_ok() {
  # Always write to stderr (>&2) to keep separate from command stdout
  >&2 echo -e "\033[32m==> $1\033[0m"
}

# Function to display error messages
msg_error() {
  # Always write to stderr (>&2) to keep separate from command stdout
  >&2 echo -e "\033[31m==> Error: $1\033[0m"
}

# Function to display header messages (bold blue)
msg_header() {
  >&2 echo -e "\033[1;34m==> $1\033[0m"
}

# Function to display highlighted text (bold white)
msg_highlight() {
  >&2 echo -e "\033[1;37m$1\033[0m"
}

# Backward compatibility aliases
echo_info() { msg_info "$*"; }
echo_ok() { msg_ok "$*"; }
echo_warn() { msg_warning "$*"; }
echo_error() { msg_error "$*"; }
echo_header() { msg_header "$*"; }

# Spinner animation for long-running commands
show_spinner() {
  local pid=$1
  local message=$2
  local spinstr='|/-\'
  local delay=0.1
  
  # Only show spinner if stderr is connected to terminal (not redirected to file/pipe)
  # This ensures spinner animation works properly in interactive sessions
  if [[ -t 2 ]]; then
    # Hide cursor during spinner animation (write to stderr)
    tput civis 2>/dev/null || true
    
    while kill -0 "$pid" 2>/dev/null; do
      local temp=${spinstr#?}
      # Spinner always writes to stderr (>&2) to avoid mixing with command output
      printf "\r\033[36m==> %s %c\033[0m" "$message" "$spinstr" >&2
      spinstr=$temp${spinstr%"$temp"}
      sleep $delay
    done
    
    # Clear spinner line (write to stderr)
    printf "\r\033[K" >&2
    # Show cursor again (write to stderr)
    tput cnorm 2>/dev/null || true
  else
    # If not in terminal, just wait silently (e.g., when output is redirected)
    while kill -0 "$pid" 2>/dev/null; do
      sleep $delay
    done
  fi
}

# Command timing functions
get_timing_log_file() {
  local timing_dir="${HOME}/.orodc"
  mkdir -p "$timing_dir"
  echo "${timing_dir}/.timing-log"
}

get_previous_timing() {
  local command=$1
  local timing_file=$(get_timing_log_file)
  
  if [[ -f "$timing_file" ]]; then
    grep "^${command}:" "$timing_file" 2>/dev/null | tail -1 | cut -d: -f2
  fi
}

save_timing() {
  local command=$1
  local duration=$2
  local timing_file=$(get_timing_log_file)
  
  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  echo "${command}:${duration}:${timestamp}" >> "$timing_file"
}

# Function to update or add environment variable in .env.orodc file
update_env_var() {
  local file="$1"
  local key="$2"
  local value="$3"
  
  if [[ -f "$file" ]]; then
    if grep -q "^${key}=" "$file"; then
      sed -i.tmp "s|^${key}=.*|${key}=${value}|" "$file"
      rm -f "${file}.tmp"
    else
      echo "${key}=${value}" >> "$file"
    fi
  else
    echo "${key}=${value}" >> "$file"
  fi
}

show_spinner_with_progress() {
  local pid=$1
  local message=$2
  local expected_duration=${3:-0}
  local spinstr='|/-\'
  local delay=1
  local elapsed=0
  
  # Only show spinner if running in terminal (not captured)
  if [[ -t 2 ]]; then
    tput civis 2>/dev/null || true
    
    while kill -0 "$pid" 2>/dev/null; do
      local temp=${spinstr#?}
      
      if [[ $expected_duration -gt 0 ]]; then
        local remaining=$((expected_duration - elapsed))
        if [[ $remaining -lt 0 ]]; then
          remaining=0
        fi
        printf "\r\033[36m==> %s %c %d sec of ~%d\033[0m" "$message" "$spinstr" "$elapsed" "$expected_duration" >&2
      else
        printf "\r\033[36m==> %s %c %d sec\033[0m" "$message" "$spinstr" "$elapsed" >&2
      fi
      
      spinstr=$temp${spinstr%"$temp"}
      sleep $delay
      elapsed=$((elapsed + 1))
    done
    
    printf "\r\033[K" >&2
    tput cnorm 2>/dev/null || true
  else
    # If not in terminal, just wait silently
    while kill -0 "$pid" 2>/dev/null; do
      sleep $delay
    done
  fi
}

# Execute command with spinner and log on error
# Usage: run_with_spinner "message" "command"
# Spinner is disabled if DEBUG=1 or VERBOSE=1 is set, or if command contains --verbose/-v flags
# Logs are written to /tmp and preserved on error for user inspection
run_with_spinner() {
  local message=$1
  shift
  local cmd="$*"
  
  # If DEBUG or VERBOSE mode is enabled, or command contains verbose flags, run directly without spinner
  if [[ -n "${DEBUG:-}" ]] || [[ -n "${VERBOSE:-}" ]] || [[ "$cmd" =~ (--verbose|-vv) ]]; then
    msg_info "$message..."  # writes to stderr
    eval "$cmd"
    return $?
  fi
  
  # Run with spinner
  local log_file
  log_file=$(mktemp /tmp/orodc-output.XXXXXX)
  local exit_code=0
  
  # Run command in background: redirect both stdout and stderr to log file
  # This keeps command output separate from spinner animation (which writes to stderr)
  eval "$cmd" > "$log_file" 2>&1 &
  local cmd_pid=$!
  
  # Show spinner in foreground (writes to stderr of parent process)
  show_spinner $cmd_pid "$message"
  
  wait $cmd_pid || exit_code=$?
  
  # Special handling for docker-compose up: check if all containers are running or exited successfully
  # Containers are OK if they are either:
  # 1. Running (Healthy or Started)
  # 2. Exited with code 0
  if [[ $exit_code -ne 0 ]] && [[ "$cmd" =~ "up" ]]; then
    # Check if there are any failed containers (not "exited (0)" and not "Healthy")
    if ! grep -qE "exited \([1-9]|Error|failed" "$log_file"; then
      # No real errors found, all containers are either Healthy or exited (0)
      exit_code=0
    fi
  fi
  
  if [[ $exit_code -ne 0 ]]; then
    msg_error "Command failed (exit code: $exit_code)"  # writes to stderr
    echo "" >&2
    
    # Show last 20 lines of the log (write to stderr for consistency)
    local line_count=$(wc -l < "$log_file")
    if [[ $line_count -gt 20 ]]; then
      msg_info "Last 20 lines of output:"  # writes to stderr
      echo "" >&2
      tail -n 20 "$log_file" >&2  # writes to stderr
      echo "" >&2
      msg_info "Full log available at: $log_file"  # writes to stderr
      msg_info "View with: cat $log_file"  # writes to stderr
    else
      # If log is 20 lines or less, show everything (write to stderr)
      cat "$log_file" >&2
      echo "" >&2
      msg_info "Full log saved at: $log_file"  # writes to stderr
    fi
    
    # Keep log file for user inspection
    return $exit_code
  fi
  
  # Remove log file on success
  rm -f "$log_file"
  msg_ok "$message completed"  # writes to stderr
  return 0
}

# Interactive selector with validation and retry
# Usage: prompt_selector "prompt text" "default" "option1:value1" "option2:value2" ...
prompt_selector() {
  local prompt="$1"
  local default="$2"
  shift 2
  local options=("$@")
  local choice=""
  
  while true; do
    read -p "$prompt" choice
    
    # Empty input - use default
    if [[ -z "$choice" ]]; then
      if [[ -n "$default" ]]; then
        echo "$default"
        return 0
      else
        msg_error "Input required"
        continue
      fi
    fi
    
    # Check if input is a number (option index)
    if [[ "$choice" =~ ^[0-9]+$ ]]; then
      local idx=$((choice - 1))
      if [[ $idx -ge 0 ]] && [[ $idx -lt ${#options[@]} ]]; then
        local option="${options[$idx]}"
        echo "${option#*:}"  # Return value part
        return 0
      fi
    fi
    
    # Check if input matches any value directly
    for option in "${options[@]}"; do
      local value="${option#*:}"
      if [[ "$choice" == "$value" ]]; then
        echo "$value"
        return 0
      fi
    done
    
    # Check if it could be a custom value (for IP address case)
    if [[ "$choice" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]] || [[ "$choice" =~ ^[a-zA-Z0-9\.\-\_]+$ ]]; then
      echo "$choice"
      return 0
    fi
    
    # Invalid input - show error and retry
    msg_error "Invalid choice: '$choice'. Please try again."
  done
}

# Prompt for port number with validation
# Usage: prompt_port "prompt text" "default_port"
prompt_port() {
  local prompt="$1"
  local default="$2"
  local choice=""
  
  while true; do
    read -p "$prompt" choice
    
    # Empty input - use default
    if [[ -z "$choice" ]]; then
      if [[ -n "$default" ]]; then
        echo "$default"
        return 0
      else
        msg_error "Port number required"
        continue
      fi
    fi
    
    # Validate port number
    if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le 65535 ]]; then
      echo "$choice"
      return 0
    else
      msg_error "Invalid port: '$choice'. Port must be a number between 1 and 65535."
    fi
  done
}

# Prompt for yes/no confirmation with validation
# Usage: confirm_yes_no "prompt text" "default" (default: yes or no)
# Returns: 0 for yes, 1 for no
confirm_yes_no() {
  local prompt="$1"
  local default="${2:-no}"
  local answer
  
  while true; do
    if [[ "$default" == "yes" ]]; then
      printf "\033[1;33m%s [Y/n]: \033[0m" "$prompt" >&2
      read -r answer </dev/tty 2>/dev/null || read -r answer
      answer="${answer:-y}"
    else
      printf "\033[1;33m%s [y/N]: \033[0m" "$prompt" >&2
      read -r answer </dev/tty 2>/dev/null || read -r answer
      answer="${answer:-n}"
    fi
    
    # Accept: y, yes, Y, YES, n, no, N, NO
    case "${answer,,}" in  # Convert to lowercase
      y|yes) return 0 ;;
      n|no) return 1 ;;
      *)
        msg_error "Invalid input: '$answer'. Please enter 'y' (yes) or 'n' (no)."
        ;;
    esac
  done
}

# Show service URLs after successful 'up' command
show_service_urls() {
  echo "" >&2
  
  # Check if proxy container is running
  local proxy_running=false
  if ${DOCKER_BIN} ps --filter "name=proxy" --filter "status=running" --format "{{.Names}}" 2>/dev/null | grep -q "^proxy$"; then
    proxy_running=true
  fi
  
  # Show domain URL if proxy is running
  if [[ "$proxy_running" == "true" ]]; then
    printf "\033[1;32m[${DC_ORO_NAME}] Application: https://${DC_ORO_NAME}.docker.local\033[0m\n"
    echo "" >&2
  fi
  
  # Always show localhost URLs
  printf "\033[0;37m[${DC_ORO_NAME}] Application: http://localhost:${DC_ORO_PORT_NGINX}\033[0m\n"
  printf "\033[0;37m[${DC_ORO_NAME}] Mailhog: http://localhost:${DC_ORO_PORT_MAIL_WEBGUI}\033[0m\n"
  printf "\033[0;37m[${DC_ORO_NAME}] Elasticsearch: http://localhost:${DC_ORO_PORT_SEARCH}\033[0m\n"
  printf "\033[0;37m[${DC_ORO_NAME}] Mq: http://localhost:${DC_ORO_PORT_MQ}\033[0m\n"
  
  if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pdo_pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]];then
    printf "\033[0;37m[${DC_ORO_NAME}] Database: 127.0.0.1:${DC_ORO_PORT_PGSQL}\033[0m\n"
  elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "pdo_mysql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
    printf "\033[0;37m[${DC_ORO_NAME}] Database: 127.0.0.1:${DC_ORO_PORT_MYSQL}\033[0m\n"
  fi

  printf "\033[0;37m[${DC_ORO_NAME}] SSH: 127.0.0.1:${DC_ORO_PORT_SSH}\033[0m\n"
  
  # Show proxy hint if not running
  if [[ "$proxy_running" == "false" ]]; then
    echo "" >&2
    msg_info "Want to use custom domains and SSL? Start the proxy:"
    msg_info "  orodc proxy up -d"
    msg_info "  orodc proxy install-certs"
    msg_info ""
    msg_info "Then access via: https://${DC_ORO_NAME}.docker.local"
  fi
}

# ============================================================================
# Interactive Menu System
# ============================================================================

# Get environment registry file path
get_environment_registry_file() {
  local registry_dir="${HOME}/.orodc"
  mkdir -p "$registry_dir"
  echo "${registry_dir}/environments.json"
}

# Read environment registry
get_environment_registry() {
  local registry_file=$(get_environment_registry_file)
  if [[ -f "$registry_file" ]]; then
    cat "$registry_file" 2>/dev/null || echo '{"environments":[]}'
  else
    echo '{"environments":[]}'
  fi
}

# Write environment registry
write_environment_registry() {
  local registry_file=$(get_environment_registry_file)
  local json_content="$1"
  echo "$json_content" > "$registry_file" 2>/dev/null || return 1
}

# Check if environment is registered
is_environment_registered() {
  local env_name="$1"

  # Check if jq is available
  if ! command -v jq >/dev/null 2>&1; then
    return 1
  fi

  local registry=$(get_environment_registry)
  local count=$(echo "$registry" | jq --arg name "$env_name" '[.environments[] | select(.name == $name)] | length')

  if [[ "$count" -gt 0 ]]; then
    return 0
  else
    return 1
  fi
}

# Clean up non-existent environments from registry
cleanup_registry() {
  if ! command -v jq >/dev/null 2>&1; then
    return 0
  fi

  local registry=$(get_environment_registry)
  local env_count=$(echo "$registry" | jq '.environments | length')
  local cleaned_registry="$registry"
  local removed_count=0

  local i=0
  while [[ $i -lt $env_count ]]; do
    local env_name=$(echo "$registry" | jq -r ".environments[$i].name")
    local env_path=$(echo "$registry" | jq -r ".environments[$i].path")
    local config_dir=$(echo "$registry" | jq -r ".environments[$i].config_dir")
    local should_remove=false

    # Check if path exists
    if [[ ! -d "$env_path" ]]; then
      debug_log "cleanup_registry: Removing '$env_name' - path does not exist: $env_path"
      should_remove=true
    fi

    # Check if config directory exists
    if [[ -n "$config_dir" ]] && [[ ! -d "$config_dir" ]]; then
      debug_log "cleanup_registry: Removing '$env_name' - config_dir does not exist: $config_dir"
      should_remove=true
    fi

    # Check if compose.yml exists in config directory
    # If compose.yml is missing, the project cannot be started and should be removed
    if [[ -n "$config_dir" ]] && [[ -d "$config_dir" ]] && [[ ! -f "${config_dir}/compose.yml" ]]; then
      debug_log "cleanup_registry: Removing '$env_name' - compose.yml missing in $config_dir"
      should_remove=true
    fi

    if [[ "$should_remove" == "true" ]]; then
      cleaned_registry=$(echo "$cleaned_registry" | jq --arg name "$env_name" '.environments = (.environments | map(select(.name != $name)))')
      removed_count=$((removed_count + 1))
    fi

    i=$((i + 1))
  done

  if [[ $removed_count -gt 0 ]]; then
    write_environment_registry "$cleaned_registry"
    debug_log "cleanup_registry: Removed $removed_count environment(s)"
  fi
}

# Register or update environment in registry
register_environment() {
  local env_name="$1"
  local env_path="$2"
  local config_dir="$3"
  
  local registry=$(get_environment_registry)
  local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  
  # Check if jq is available
  if ! command -v jq >/dev/null 2>&1; then
    msg_warning "jq not found, skipping environment registration"
    return 0
  fi
  
  # Ensure absolute path - always use realpath
  local absolute_path=$(realpath "$env_path" 2>/dev/null || echo "$env_path")
  if [[ -n "$absolute_path" ]] && [[ "$absolute_path" != "$env_path" ]]; then
    env_path="$absolute_path"
  fi
  
  # Remove existing entry if present
  registry=$(echo "$registry" | jq --arg name "$env_name" '.environments = (.environments | map(select(.name != $name)))')
  
  # Add new entry
  registry=$(echo "$registry" | jq --arg name "$env_name" \
    --arg path "$env_path" \
    --arg config "$config_dir" \
    --arg timestamp "$timestamp" \
    '.environments += [{
      "name": $name,
      "path": $path,
      "config_dir": $config,
      "last_used": $timestamp
    }]')
  
  write_environment_registry "$registry"
}

# Check if directory is an OroPlatform project
is_oroplatform_project() {
  local dir="${1:-$PWD}"
  
  # Exclude Homebrew formula/tap directories
  if [[ "$dir" == *"/Homebrew/Library/Taps/"* ]] || [[ "$dir" == *"/Cellar/"* ]] || [[ "$dir" == *"/Caskroom/"* ]]; then
    return 1
  fi
  
  # Check for common OroPlatform indicators
  if [[ -f "$dir/composer.json" ]] || [[ -f "$dir/app/config/parameters.yml" ]] || [[ -d "$dir/bin" ]] || [[ -f "$dir/bin/console" ]]; then
    return 0
  fi
  return 1
}

# Get environment status (running/stopped/uninitialized)
get_environment_status() {
  local env_name="$1"
  local check_dir="${2:-$PWD}"
  
  if [[ -z "$env_name" ]]; then
    echo "unknown"
    return
  fi
  
  # First check if this is an OroPlatform project
  if ! is_oroplatform_project "$check_dir"; then
    echo "uninitialized"
    return
  fi
  
  # Check if Docker is available
  if ! command -v docker >/dev/null 2>&1 && [[ -z "${DOCKER_BIN:-}" ]]; then
    echo "unknown"
    return
  fi
  
  local docker_cmd="${DOCKER_BIN:-docker}"
  
  # Check if any containers for this project are running
  local project_name="${env_name}"
  if ${docker_cmd} ps --filter "label=com.docker.compose.project=${project_name}" --format "{{.Names}}" 2>/dev/null | grep -q .; then
    echo "running"
  else
    echo "stopped"
  fi
}

# Scan and auto-register environments from ~/.orodc/* directories
scan_and_register_environments() {
  # DO NOT auto-register environments from ~/.orodc scanning
  # Environments are registered only when user runs init or docker compose commands
  # This prevents wrong paths from being registered
  debug_log "scan_and_register_environments: Skipped (no auto-registration)"
}

# Get real environment path from Docker mounts
get_environment_real_path() {
  local env_name="$1"
  local docker_cmd="${DOCKER_BIN:-docker}"
  
  # Try to find containers for this project
  local containers=$(${docker_cmd} ps -a --filter "label=com.docker.compose.project=${env_name}" --format "{{.Names}}" 2>/dev/null | head -1)
  
  if [[ -z "$containers" ]]; then
    echo ""
    return 1
  fi
  
  # Get mounts from the first container
  local mounts=$(${docker_cmd} inspect "$containers" --format '{{json .Mounts}}' 2>/dev/null)
  
  if [[ -z "$mounts" ]] || [[ "$mounts" == "null" ]]; then
    echo ""
    return 1
  fi
  
  # Try to find source path from mounts (look for bind mounts with application directory)
  # Check for common mount patterns: /app, /var/www, or paths containing the project name
  local real_path=$(echo "$mounts" | jq -r '.[] | select(.Type == "bind") | select(.Source != null) | .Source' 2>/dev/null | grep -E "(/app|/var/www|${env_name})" | head -1)
  
  # If not found, try to get any bind mount source that looks like a project directory
  if [[ -z "$real_path" ]]; then
    real_path=$(echo "$mounts" | jq -r '.[] | select(.Type == "bind") | select(.Source != null and (.Source | contains("/home") or contains("/Users") or contains("/var/www"))) | .Source' 2>/dev/null | head -1)
  fi
  
  # Verify the path exists and contains typical OroPlatform files
  if [[ -n "$real_path" ]] && [[ -d "$real_path" ]]; then
    # Check if it looks like an OroPlatform project
    if [[ -f "$real_path/composer.json" ]] || [[ -f "$real_path/app/config/parameters.yml" ]] || [[ -d "$real_path/bin" ]]; then
      echo "$real_path"
      return 0
    fi
  fi
  
  echo ""
  return 1
}

# List all environments and allow selection
list_environments() {
  # Clean up non-existent environments first
  cleanup_registry

  local registry=$(get_environment_registry)

  if ! command -v jq >/dev/null 2>&1; then
    msg_error "jq is required for environment listing"
    return 1
  fi

  local env_count=$(echo "$registry" | jq '.environments | length')

  echo "" >&2
  msg_header "Environments"
  echo "" >&2
  printf "%-5s %-32s %-24s %s\n" "NUM" "NAME" "STATUS" "PATH" >&2
  printf "%-5s %-32s %-24s %s\n" "---" "----" "------" "----" >&2

  local env_names=()
  local env_paths=()
  local env_config_dirs=()
  local display_count=0

  # First, add current environment if it exists and is not registered
  debug_log "list_environments: DC_ORO_NAME='${DC_ORO_NAME:-<not set>}' DC_ORO_CONFIG_DIR='${DC_ORO_CONFIG_DIR:-<not set>}'"

  if [[ -n "${DC_ORO_NAME:-}" ]] && [[ -n "${DC_ORO_CONFIG_DIR:-}" ]]; then
    debug_log "list_environments: Checking if '${DC_ORO_NAME}' is registered"

    if ! is_environment_registered "${DC_ORO_NAME}"; then
      debug_log "list_environments: '${DC_ORO_NAME}' is NOT registered"
      local current_path=$(realpath "$PWD" 2>/dev/null || echo "$PWD")
      local current_status=$(get_environment_status "${DC_ORO_NAME}" "$current_path")
      debug_log "list_environments: current_status='$current_status' current_path='$current_path'"

      # Show if it has a status (not uninitialized means it's been set up)
      if [[ "$current_status" != "uninitialized" ]] && [[ -n "$current_status" ]]; then
        debug_log "list_environments: Adding current unregistered env to list"
        env_names+=("${DC_ORO_NAME}")
        env_config_dirs+=("${DC_ORO_CONFIG_DIR}")
        env_paths+=("$current_path")

        local display_name="${DC_ORO_NAME}"
        if [[ ${#display_name} -gt 32 ]]; then
          display_name="${display_name:0:29}..."
        fi

        # Add (unregistered) to status
        local display_status="${current_status} (unregistered)"

        display_count=$((display_count + 1))
        printf "%-5s %-32s %-24s %s\n" "$display_count" "$display_name" "$display_status" "$current_path" >&2
      else
        debug_log "list_environments: Skipping - status is '$current_status'"
      fi
    else
      debug_log "list_environments: '${DC_ORO_NAME}' IS registered, skipping"
    fi
  else
    debug_log "list_environments: DC_ORO_NAME or DC_ORO_CONFIG_DIR not set"
  fi

  # Then add all registered environments
  local i=0
  while [[ $i -lt $env_count ]]; do
    local env_name=$(echo "$registry" | jq -r ".environments[$i].name")
    local config_dir=$(echo "$registry" | jq -r ".environments[$i].config_dir")
    local registry_path=$(echo "$registry" | jq -r ".environments[$i].path")

    local env_status=$(get_environment_status "$env_name")

    # Skip if uninitialized and no compose.yml (never been set up)
    if [[ "$env_status" == "uninitialized" ]] && [[ -n "$config_dir" ]] && [[ ! -f "${config_dir}/compose.yml" ]]; then
      debug_log "list_environments: Skipping '$env_name' - uninitialized and no compose.yml"
      i=$((i + 1))
      continue
    fi

    # Check if registered (should be, but double-check)
    local display_status="$env_status"
    if ! is_environment_registered "$env_name"; then
      display_status="${env_status} (unregistered)"
    fi

    # Ensure registry_path is absolute
    local absolute_registry_path=$(realpath "$registry_path" 2>/dev/null || echo "$registry_path")

    # Check if path exists, show "-" if not
    local display_path="$absolute_registry_path"
    if [[ ! -d "$absolute_registry_path" ]]; then
      display_path="-"
    fi

    env_names+=("$env_name")
    env_config_dirs+=("$config_dir")
    env_paths+=("$absolute_registry_path")

    debug_log "list_environments: Added env='$env_name' path='$absolute_registry_path' display='$display_path'"

    # Truncate name to 32 characters if longer
    local display_name="$env_name"
    if [[ ${#display_name} -gt 32 ]]; then
      display_name="${display_name:0:29}..."
    fi

    display_count=$((display_count + 1))
    printf "%-5s %-32s %-24s %s\n" "$display_count" "$display_name" "$display_status" "$display_path" >&2
    i=$((i + 1))
  done
  
  if [[ $display_count -eq 0 ]]; then
    msg_info "No valid environments found (all missing compose.yml)"
    return 0
  fi
  echo "" >&2
  
  # Allow selection
  echo -n "Select environment number to switch (or Enter to return): " >&2
  read -r selection
  
  if [[ -z "$selection" ]]; then
    return 0
  fi
  
  if [[ "$selection" =~ ^[0-9]+$ ]] && [[ $selection -ge 1 ]] && [[ $selection -le $display_count ]]; then
    local idx=$((selection - 1))
    local selected_name="${env_names[$idx]}"
    local selected_path="${env_paths[$idx]}"
    local selected_config_dir="${env_config_dirs[$idx]}"

      debug_log "list_environments: Selected idx=$idx name='$selected_name' path='$selected_path' config='$selected_config_dir'"

      # If path doesn't exist, ask user to provide it
      if [[ ! -d "$selected_path" ]]; then
        echo "" >&2
        msg_warning "Path not found: $selected_path"
        msg_info "Please enter the correct path to the project directory:"
        echo -n "> " >&2
        read -r user_path

        if [[ -z "$user_path" ]]; then
          msg_error "Path not provided"
          echo "" >&2
          echo -n "Press Enter to continue..." >&2
          read -r
          return 1
        fi

        # Expand tilde and make absolute
        user_path="${user_path/#\~/$HOME}"
        user_path=$(realpath "$user_path" 2>/dev/null || echo "$user_path")

        if [[ ! -d "$user_path" ]]; then
          msg_error "Directory does not exist: $user_path"
          echo "" >&2
          echo -n "Press Enter to continue..." >&2
          read -r
          return 1
        fi

        # Update selected_path and registry
        selected_path="$user_path"
        register_environment "$selected_name" "$selected_path" "$selected_config_dir"
        msg_ok "Path updated in registry"
      fi
      
      msg_info "Switching to environment: $selected_name"
      msg_info "Changing directory to: $selected_path"
      
      # Change directory - use realpath to ensure absolute path
      local absolute_path=$(realpath "$selected_path" 2>/dev/null || echo "$selected_path")
      
      if [[ ! -d "$absolute_path" ]]; then
        msg_error "Environment path does not exist: $absolute_path"
        echo "" >&2
        echo -n "Press Enter to continue..." >&2
        read -r
        return 1
      fi
      
      msg_info "Switching to environment: $selected_name"
      msg_info "Changing directory to: $absolute_path"
      
      # Update last_used timestamp in registry with absolute path
      register_environment "$selected_name" "$absolute_path" "$selected_config_dir"

      # Restart the entire script in the new directory
      # Export selected environment name so it's preserved after exec
      export ORODC_SELECTED_ENV_NAME="$selected_name"
      export ORODC_SELECTED_ENV_PATH="$absolute_path"
      export ORODC_SELECTED_ENV_CONFIG="$selected_config_dir"

      debug_log "list_environments: Exporting ORODC_SELECTED_ENV_NAME='$selected_name' PATH='$absolute_path' CONFIG='$selected_config_dir'"
      # Unset all environment-related variables to force recalculation
      unset DC_ORO_NAME
      unset DC_ORO_CONFIG_DIR
      unset DC_ORO_APPDIR
      unset COMPOSE_PROJECT_NAME
      
      # Change directory and exec script in new directory
      # CRITICAL: cd must happen before exec, and exec must use absolute path to script
      cd "$absolute_path" || {
        msg_error "Failed to change directory to $absolute_path"
        return 1
      }
      
      msg_ok "Successfully switched to environment: $selected_name"
      echo "" >&2
      
      # Get absolute path to script for exec (important for proper execution)
      local script_path=$(realpath "$0" 2>/dev/null || echo "$0")
      if [[ ! "$script_path" = /* ]]; then
        # If still relative, try to find it in PATH
        script_path=$(command -v "$0" 2>/dev/null || echo "$0")
      fi
      
      # This ensures all environment variables are properly reinitialized in new directory
      exec "$script_path"
  else
    msg_error "Invalid selection: $selection"
    return 1
  fi
}

# Get last used environment from registry
get_last_used_environment() {
  local registry=$(get_environment_registry)
  
  if ! command -v jq >/dev/null 2>&1; then
    return 1
  fi
  
  local env_count=$(echo "$registry" | jq '.environments | length')
  if [[ "$env_count" == "0" ]]; then
    return 1
  fi
  
  # Find environment with latest last_used timestamp that has compose.yml
  local last_env=""
  local last_timestamp=0
  
  local i=0
  while [[ $i -lt $env_count ]]; do
    local env_name=$(echo "$registry" | jq -r ".environments[$i].name")
    local env_path=$(echo "$registry" | jq -r ".environments[$i].path")
    local config_dir=$(echo "$registry" | jq -r ".environments[$i].config_dir")
    local last_used=$(echo "$registry" | jq -r ".environments[$i].last_used // \"0\"")
    
    # Skip if compose.yml doesn't exist
    if [[ -n "$config_dir" ]] && [[ ! -f "${config_dir}/compose.yml" ]]; then
      i=$((i + 1))
      continue
    fi
    
    # Convert timestamp to number for comparison
    local timestamp_num=0
    if [[ "$last_used" != "null" ]] && [[ "$last_used" != "0" ]] && [[ -n "$last_used" ]]; then
      timestamp_num=$(date -d "$last_used" +%s 2>/dev/null || echo "0")
    fi
    
    if [[ $timestamp_num -gt $last_timestamp ]] && [[ -d "$env_path" ]]; then
      last_timestamp=$timestamp_num
      last_env="$env_path"
    fi
    
    i=$((i + 1))
  done
  
  if [[ -n "$last_env" ]] && [[ -d "$last_env" ]]; then
    echo "$last_env"
    return 0
  fi
  
  return 1
}

# Detect current environment (NO auto-registration)
detect_current_environment() {
  # This function no longer auto-registers environments
  # Environments are registered only after 'init' or when compose.yml is created
  debug_log "detect_current_environment: Called (no auto-registration)"
}

# Check if we're in a project directory
# Returns 0 if in project, 1 if not
check_in_project() {
  if [[ -z "${DC_ORO_NAME:-}" ]] || [[ -z "${DC_ORO_CONFIG_DIR:-}" ]]; then
    msg_error "No project found in current directory"
    msg_info "Please navigate to a project directory or select a project from the list (option 1)"
    echo "" >&2
    return 1
  fi
  return 0
}

# Manage domains interactively
manage_domains() {
  local env_file="${DC_ORO_APPDIR}/.env.orodc"
  if [[ ! -f "$env_file" ]]; then
    env_file="${DC_ORO_CONFIG_DIR}/.env.orodc"
  fi
  
  local current_hosts=""
  if [[ -f "$env_file" ]]; then
    current_hosts=$(grep "^DC_ORO_EXTRA_HOSTS=" "$env_file" 2>/dev/null | cut -d'=' -f2- | tr -d '"' | tr -d "'" || echo "")
  fi
  
  echo "" >&2
  msg_header "Domain Management"
  echo "" >&2
  if [[ -n "$current_hosts" ]]; then
    msg_info "Current domains: $current_hosts"
  else
    msg_info "No domains currently configured"
  fi
  echo "" >&2
  
  local domains=()
  if [[ -n "$current_hosts" ]]; then
    IFS=',' read -ra domains <<< "$current_hosts"
  fi
  
  while true; do
    echo -n "Add domain (or 'remove' to delete, 'done' to finish): " >&2
    read -r input
    
    if [[ -z "$input" ]]; then
      continue
    fi
    
    if [[ "$input" == "done" ]]; then
      break
    fi
    
    if [[ "$input" == "remove" ]]; then
      if [[ ${#domains[@]} -eq 0 ]]; then
        msg_warning "No domains to remove"
        continue
      fi
      
      echo "" >&2
      msg_info "Current domains:"
      local i=0
      for domain in "${domains[@]}"; do
        echo "  $((i + 1)). $domain" >&2
        i=$((i + 1))
      done
      echo "" >&2
      echo -n "Enter domain number to remove: " >&2
      read -r num
      
      if [[ "$num" =~ ^[0-9]+$ ]] && [[ $num -ge 1 ]] && [[ $num -le ${#domains[@]} ]]; then
        local idx=$((num - 1))
        unset "domains[$idx]"
        domains=("${domains[@]}")
        msg_ok "Domain removed"
      else
        msg_error "Invalid selection"
      fi
      continue
    fi
    
    # Validate and add domain
    local domain=$(echo "$input" | xargs)  # trim whitespace
    
    # Handle short names (add .docker.local)
    if [[ ! "$domain" =~ \. ]]; then
      domain="${domain}.docker.local"
    fi
    
    # Basic validation
    if [[ "$domain" =~ ^[a-zA-Z0-9._-]+$ ]]; then
      domains+=("$domain")
      msg_ok "Domain added: $domain"
    else
      msg_error "Invalid domain format: $domain"
    fi
  done
  
  # Update .env.orodc file
  local new_hosts=$(IFS=','; echo "${domains[*]}")
  if [[ -n "$new_hosts" ]]; then
    update_env_var "$env_file" "DC_ORO_EXTRA_HOSTS" "$new_hosts"
    msg_ok "Domains updated: $new_hosts"
  else
    # Remove the line if no domains
    if [[ -f "$env_file" ]]; then
      sed -i.tmp '/^DC_ORO_EXTRA_HOSTS=/d' "$env_file"
      rm -f "${env_file}.tmp"
    fi
    msg_ok "All domains removed"
  fi
}

# List database dump files in var/backup/ directory
list_database_dumps() {
  local project_dir="${DC_ORO_APPDIR:-$PWD}"
  local backup_dir="${project_dir}/var/backup"
  local var_dir="${project_dir}/var"
  
  local dumps=()
  
  # Check backup directory first
  if [[ -d "$backup_dir" ]]; then
    while IFS= read -r -d '' file; do
      dumps+=("$file")
    done < <(find "$backup_dir" -maxdepth 1 -type f \( -name "*.sql" -o -name "*.sql.gz" \) -print0 2>/dev/null | sort -z)
  fi
  
  # Fallback to var/ directory if backup is empty
  if [[ ${#dumps[@]} -eq 0 ]] && [[ -d "$var_dir" ]]; then
    while IFS= read -r -d '' file; do
      dumps+=("$file")
    done < <(find "$var_dir" -maxdepth 1 -type f \( -name "*.sql" -o -name "*.sql.gz" \) -print0 2>/dev/null | sort -z)
  fi
  
  if [[ ${#dumps[@]} -eq 0 ]]; then
    return 1
  fi
  
  printf '%s\n' "${dumps[@]}"
}

# Export database to var/backup/ folder
export_database_interactive() {
  # Use project directory, fallback to current directory
  local project_dir="${DC_ORO_APPDIR:-$PWD}"
  local backup_dir="${project_dir}/var/backup"
  mkdir -p "$backup_dir"
  
  local default_filename="database-$(date +'%Y%m%d%H%M%S').sql.gz"
  echo -n "Enter filename [default: $default_filename]: " >&2
  read -r filename
  
  if [[ -z "$filename" ]]; then
    filename="$default_filename"
  fi
  
  # Ensure .sql.gz extension
  if [[ ! "$filename" =~ \.(sql|sql\.gz)$ ]]; then
    filename="${filename}.sql.gz"
  fi
  
  local dump_path="${backup_dir}/${filename}"
  
  # Use existing exportdb logic
  DB_DUMP="$dump_path"
  DB_DUMP_BASENAME=$(echo "${DB_DUMP##*/}")
  touch "${DB_DUMP}"
  
  if [[ $DC_ORO_DATABASE_SCHEMA == "pgsql" ]] || [[ $DC_ORO_DATABASE_SCHEMA == "postgres" ]] || [[ $DC_ORO_DATABASE_SCHEMA == "postgresql" ]]; then
    DB_EXPORT_CMD="PGPASSWORD=\$DC_ORO_DATABASE_PASSWORD pg_dump -Fp --clean --if-exists -h \$DC_ORO_DATABASE_HOST -p \$DC_ORO_DATABASE_PORT -U \$DC_ORO_DATABASE_USER -d \$DC_ORO_DATABASE_DBNAME"
  elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
    DB_EXPORT_CMD="MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysqldump --no-tablespaces --column-statistics=0 --set-gtid-purged=OFF --quick --max-allowed-packet=16M --disable-keys --hex-blob --no-autocommit --insert-ignore --skip-lock-tables --single-transaction -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME | sed -E 's/[Dd][Ee][Ff][Ii][Nn][Ee][Rr][ ]*=[ ]*[^*]*\*/DEFINER=CURRENT_USER \*/'"
  fi
  
  msg_info "Starting export of the database..."
  msg_info "Database: $DC_ORO_DATABASE_HOST:$DC_ORO_DATABASE_PORT/$DC_ORO_DATABASE_DBNAME"
  msg_info "Export to: $DB_DUMP"
  
  export_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run --quiet --rm -v \"${DB_DUMP}:/${DB_DUMP_BASENAME}\" database-cli bash -c \"$DB_EXPORT_CMD | gzip > /${DB_DUMP_BASENAME}\""
  run_with_spinner "Exporting database" "$export_cmd" || return $?
  
  msg_ok "Database exported successfully"
  msg_info "File: $DB_DUMP"
  msg_info "Size: $(du -h "$DB_DUMP" | cut -f1)"
}

# Import database from var/backup/ folder or file path
import_database_interactive() {
  # Use project directory, fallback to current directory
  local project_dir="${DC_ORO_APPDIR:-$PWD}"
  local backup_dir="${project_dir}/var/backup"
  local var_dir="${project_dir}/var"
  local dumps=()
  local dump_files=()
  
  # Get dumps using list_database_dumps (checks var/backup/ first, then var/)
  while IFS= read -r file; do
    if [[ -n "$file" ]]; then
      dumps+=("$file")
      dump_files+=("$file")
    fi
  done < <(list_database_dumps 2>/dev/null || true)
  
  local selected_file=""
  
  if [[ ${#dumps[@]} -gt 0 ]]; then
    echo "" >&2
    msg_header "Available Database Dumps"
    echo "" >&2
    local i=1
    for dump in "${dumps[@]}"; do
      local basename_dump=$(basename "$dump")
      local size=$(du -h "$dump" 2>/dev/null | cut -f1)
      printf "  %2d) %s (%s)\n" "$i" "$basename_dump" "$size" >&2
      i=$((i + 1))
    done
    echo "" >&2
    echo -n "Select dump number or enter file path: " >&2
    read -r input
    
    if [[ "$input" =~ ^[0-9]+$ ]] && [[ $input -ge 1 ]] && [[ $input -le ${#dumps[@]} ]]; then
      selected_file="${dumps[$((input - 1))]}"
    elif [[ -n "$input" ]]; then
      # Try as file path
      if [[ -r "$input" ]]; then
        selected_file=$(realpath "$input")
      elif [[ -r "${project_dir}/${input}" ]]; then
        selected_file=$(realpath "${project_dir}/${input}")
      elif [[ -r "${backup_dir}/${input}" ]]; then
        selected_file=$(realpath "${backup_dir}/${input}")
      elif [[ -r "${var_dir}/${input}" ]]; then
        selected_file=$(realpath "${var_dir}/${input}")
      else
        msg_error "File not found or not readable: $input"
        return 1
      fi
    else
      msg_error "No selection made"
      return 1
    fi
  else
    echo -n "Enter database dump file path: " >&2
    read -r input
    
    if [[ -z "$input" ]]; then
      msg_error "No file provided"
      return 1
    fi
    
    if [[ -r "$input" ]]; then
      selected_file=$(realpath "$input")
    elif [[ -r "${backup_dir}/${input}" ]]; then
      selected_file=$(realpath "${backup_dir}/${input}")
    elif [[ -r "${var_dir}/${input}" ]]; then
      selected_file=$(realpath "${var_dir}/${input}")
    elif [[ -r "${project_dir}/${input}" ]]; then
      selected_file=$(realpath "${project_dir}/${input}")
    else
      msg_error "File not found or not readable: $input"
      return 1
    fi
  fi
  
  if [[ -z "$selected_file" ]] || [[ ! -r "$selected_file" ]]; then
    msg_error "Invalid file: $selected_file"
    return 1
  fi
  
  # Use existing importdb logic
  DB_DUMP="$selected_file"
  DB_DUMP_BASENAME=$(echo "${DB_DUMP##*/}")
  
  if [[ $DC_ORO_DATABASE_SCHEMA == "pdo_pgsql" ]] || [[ $DC_ORO_DATABASE_SCHEMA == "postgres" ]];then
    DB_IMPORT_CMD="sed -E 's/[Oo][Ww][Nn][Ee][Rr]:[[:space:]]*[a-zA-Z0-9_]+/Owner: '\$DC_ORO_DATABASE_USER'/g' | sed -E 's/[Oo][Ww][Nn][Ee][Rr][[:space:]]+[Tt][Oo][[:space:]]+[a-zA-Z0-9_]+/OWNER TO '\$DC_ORO_DATABASE_USER'/g' | sed -E 's/[Ff][Oo][Rr][[:space:]]+[Rr][Oo][Ll][Ee][[:space:]]+[a-zA-Z0-9_]+/FOR ROLE '\$DC_ORO_DATABASE_USER'/g' | sed -E 's/[Tt][Oo][[:space:]]+[a-zA-Z0-9_]+;/TO '\$DC_ORO_DATABASE_USER';/g' | sed -E '/^[[:space:]]*[Rr][Ee][Vv][Oo][Kk][Ee][[:space:]]+[Aa][Ll][Ll]/d' | sed -e '/SET transaction_timeout = 0;/d' | sed -E '/[\\]restrict|[\\]unrestrict/d' | PGPASSWORD=\$DC_ORO_DATABASE_PASSWORD psql --set ON_ERROR_STOP=on -h \$DC_ORO_DATABASE_HOST -p \$DC_ORO_DATABASE_PORT -U \$DC_ORO_DATABASE_USER -d \$DC_ORO_DATABASE_DBNAME -1 >/dev/null"
  elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "pdo_mysql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
    DB_IMPORT_CMD="sed -E 's/[Dd][Ee][Ff][Ii][Nn][Ee][Rr][ ]*=[ ]*[^*]*\*/DEFINER=CURRENT_USER \*/' | MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME"
  fi
  
  if echo ${DB_DUMP_BASENAME} | grep -i 'sql\.gz$' > /dev/null; then
    DB_IMPORT_CMD="zcat ${DB_DUMP_BASENAME} | sed -E 's/^[[:space:]]*[Cc][Rr][Ee][Aa][Tt][Ee][[:space:]]+[Ff][Uu][Nn][Cc][Tt][Ii][Oo][Nn]/CREATE OR REPLACE FUNCTION/g' | ${DB_IMPORT_CMD}"
  else
    DB_IMPORT_CMD="cat /${DB_DUMP_BASENAME} | sed -E 's/^[[:space:]]*[Cc][Rr][Ee][Aa][Tt][Ee][[:space:]]+[Ff][Uu][Nn][Cc][Tt][Ii][Oo][Nn]/CREATE OR REPLACE FUNCTION/g' | ${DB_IMPORT_CMD}"
  fi
  
  msg_info "Starting import of the database dump..."
  msg_info "From: $DB_DUMP"
  msg_info "File size: $(du -h "$DB_DUMP" | cut -f1)"
  msg_info "Database: $DC_ORO_DATABASE_HOST:$DC_ORO_DATABASE_PORT/$DC_ORO_DATABASE_DBNAME"
  
  import_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run --quiet -i --rm -v \"${DB_DUMP}:/${DB_DUMP_BASENAME}\" database-cli bash -c \"$DB_IMPORT_CMD\""
  run_with_spinner "Importing database" "$import_cmd" || return $?
  
  msg_ok "Database imported successfully"
}

# Configure application URL interactively
configure_url_interactive() {
  local current_url="https://${DC_ORO_NAME}.docker.local"
  
  # Try to get current URL from Oro config
  if command -v jq >/dev/null 2>&1; then
    local url_from_config=$(${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:get oro_website.secure_url" 2>/dev/null | grep -v "^\s*$" | tail -1 | xargs || echo "")
    if [[ -n "$url_from_config" ]] && [[ "$url_from_config" != "null" ]]; then
      current_url="$url_from_config"
    fi
  fi
  
  echo "" >&2
  msg_header "Configure Application URL"
  echo "" >&2
  msg_info "Current URL: $current_url"
  echo "" >&2
  echo -n "Enter new application URL [default: https://${DC_ORO_NAME}.docker.local]: " >&2
  read -r new_url
  
  if [[ -z "$new_url" ]]; then
    new_url="https://${DC_ORO_NAME}.docker.local"
  fi
  
  # Validate URL format
  if [[ ! "$new_url" =~ ^https?:// ]]; then
    msg_error "URL must start with http:// or https://"
    return 1
  fi
  
  # Use existing updateurl logic
  URL="$new_url"
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:update oro_website.secure_url ${URL}" || true
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:update oro_ui.application_url ${URL}" || true
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:update oro_website.url ${URL}" || true
  
  msg_ok "Application URL updated to: $new_url"
}

# Platform update with service management
platform_update_interactive() {
  msg_header "Platform Update"
  echo "" >&2
  msg_info "Stopping application services..."
  
  # Stop application services but keep dependencies
  # Services to stop: fpm, nginx, websocket, consumer
  # Services to keep: database, redis, elasticsearch, rabbitmq
  local services_to_stop=("fpm" "nginx" "websocket" "consumer")
  for service in "${services_to_stop[@]}"; do
    ${DOCKER_COMPOSE_BIN_CMD} stop "$service" >/dev/null 2>&1 || true
  done
  
  msg_info "Running platform update..."
  
  # Clear cache and run update
  local update_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm cli bash -c \"rm -rf var/cache/* || true; php bin/console oro:platform:update --force\""
  run_with_spinner "Updating platform" "$update_cmd" || return $?
  
  msg_ok "Platform update completed"
  echo "" >&2
  
  if confirm_yes_no "Restart services?" "yes"; then
    msg_info "Restarting services..."
    ${DOCKER_COMPOSE_BIN_CMD} up -d >/dev/null 2>&1
    msg_ok "Services restarted"
  fi
}

# Run command and ask to return to menu
run_command_with_menu_return() {
  local cmd=("$@")

  # Run command
  "$0" "${cmd[@]}"
  local exit_code=$?

  echo "" >&2
  # Ask to return to menu
  if confirm_yes_no "Return to menu?" "yes"; then
    show_interactive_menu
  else
    exit $exit_code
  fi
}

# Show interactive menu
show_interactive_menu() {
  # Handle Ctrl+C gracefully
  trap 'echo ""; echo ""; msg_info "Goodbye!"; exit 0' SIGINT

  # Debug output
  if [[ -n "${DEBUG:-}" ]]; then
    echo "[DEBUG show_interactive_menu] PWD: $PWD" >&2
    echo "[DEBUG show_interactive_menu] DC_ORO_NAME: ${DC_ORO_NAME:-<not set>}" >&2
    echo "[DEBUG show_interactive_menu] DC_ORO_APPDIR: ${DC_ORO_APPDIR:-<not set>}" >&2
    echo "[DEBUG show_interactive_menu] DC_ORO_CONFIG_DIR: ${DC_ORO_CONFIG_DIR:-<not set>}" >&2
  fi

  # Auto-register current environment
  detect_current_environment

  # Scan and register other environments
  scan_and_register_environments

  # Clean up non-existent environments from registry
  cleanup_registry

  # Initialize Docker Compose variables for menu functions
  BREW_BIN=$(resolve_bin "brew")
  DOCKER_BIN=$(resolve_bin "docker")
  DOCKER_COMPOSE_BIN="$DOCKER_BIN compose"
  DOCKER_COMPOSE_BIN_CMD="$DOCKER_COMPOSE_BIN"

  # Initialize argument arrays as empty for menu functions
  left_flags=()
  left_options=()
  right_flags=()
  right_options=()

  # Get DIR for any operations that need it
  DIR=$("$BREW_BIN" --prefix docker-compose-oroplatform)/share/docker-compose-oroplatform

  # Build compose command with config files (needed for menu functions)
  if [[ -n "${DC_ORO_CONFIG_DIR:-}" ]] && [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose.yml" ]]; then
    DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose.yml"
  fi

  # Set DOCKER_COMPOSE_RUN_CMD after compose files are added
  DOCKER_COMPOSE_RUN_CMD="${DOCKER_COMPOSE_BIN_CMD} run --rm"

  local current_status=$(get_environment_status "${DC_ORO_NAME}" "$PWD")
  local status_display=""
  local is_registered=false

  # Check if environment is registered
  if [[ -n "${DC_ORO_NAME:-}" ]] && is_environment_registered "${DC_ORO_NAME}"; then
    is_registered=true
  fi

  if [[ "$current_status" == "running" ]]; then
    if [[ "$is_registered" == "true" ]]; then
      status_display="\033[32mrunning\033[0m"
    else
      status_display="\033[32mrunning\033[0m \033[33m(unregistered)\033[0m"
    fi
  elif [[ "$current_status" == "uninitialized" ]]; then
    status_display="\033[33muninitialized\033[0m"
  else
    if [[ "$is_registered" == "true" ]]; then
      status_display="\033[31mstopped\033[0m"
    else
      status_display="\033[31mstopped\033[0m \033[33m(unregistered)\033[0m"
    fi
  fi
  
  clear
  echo -e "\033[1;34m========================================\033[0m" >&2
  echo -e "\033[1;34m    OroDC Interactive Menu\033[0m" >&2
  echo -e "\033[1;34m========================================\033[0m" >&2
  echo "" >&2
  msg_info "Welcome to OroDC Interactive Menu!"
  msg_info "Manage your Application development environments easily."
  echo "" >&2
  echo "Select an option:" >&2
  echo "" >&2
  
  # Get terminal width, default to 80 if not available
  local term_width=${COLUMNS:-80}
  local use_two_columns=false
  if [[ $term_width -ge 100 ]]; then
    use_two_columns=true
  fi
  
  if [[ "$use_two_columns" == "true" ]]; then
    # Two column layout
    printf "  \033[1;36m%-30s\033[0m  \033[1;33m%-30s\033[0m\n" "Environment Management:" "Configuration:" >&2
    printf "  %-30s  %-30s\n" "  1) List all environments" "  7) Add/Manage domains" >&2
    printf "  %-30s  %-30s\n" "  2) Initialize environment" "  8) Configure URL" >&2
    printf "  %-30s  %-30s\n" "  3) Start environment" "" >&2
    printf "  %-30s  %-30s\n" "  4) Stop environment" "" >&2
    printf "  %-30s  %-30s\n" "  5) Delete environment" "" >&2
    printf "  %-30s  %-30s\n" "  6) Connect via SSH" "" >&2
    echo "" >&2
    printf "  \033[1;35m%-30s\033[0m  \033[1;32m%-30s\033[0m\n" "Database:" "Maintenance:" >&2
    printf "  %-30s  %-30s\n" "  9)  Export database" "  11) Clear cache" >&2
    printf "  %-30s  %-30s\n" "  10) Import database" "  12) Platform update" >&2
    printf "  %-30s  %-30s\n" "" "  13) Run doctor" >&2
    echo "" >&2
    printf "  \033[1;37m%-30s\033[0m  \033[1;31m%-30s\033[0m\n" "Other:" "Installation:" >&2
    printf "  %-30s  %-30s\n" "  14) Image build" "  17) Install with demo" >&2
    printf "  %-30s  %-30s\n" "  15) Start proxy" "  18) Install without demo" >&2
    printf "  %-30s  %-30s\n" "  16) Stop proxy" "" >&2
  else
    # Single column layout (original)
    echo -e "\033[1;36mEnvironment Management:\033[0m" >&2
    echo "  1)  List all environments" >&2
    echo "  2)  Initialize environment and determine versions" >&2
    echo "  3)  Start environment in current folder" >&2
    echo "  4)  Stop environment" >&2
    echo "  5)  Delete environment" >&2
    echo "  6)  Connect via SSH" >&2
    echo "" >&2
    echo -e "\033[1;33mConfiguration:\033[0m" >&2
    echo "  7)  Add/Manage domains" >&2
    echo "  8)  Configure application URL" >&2
    echo "" >&2
    echo -e "\033[1;35mDatabase:\033[0m" >&2
    echo "  9)  Export database" >&2
    echo "  10) Import database" >&2
    echo "" >&2
    echo -e "\033[1;32mMaintenance:\033[0m" >&2
    echo "  11) Clear cache" >&2
    echo "  12) Platform update" >&2
    echo "  13) Run doctor (show ps)" >&2
    echo "" >&2
    echo -e "\033[1;37mOther:\033[0m" >&2
    echo "  14) Image build" >&2
    echo "  15) Start proxy" >&2
    echo "  16) Stop proxy" >&2
    echo "" >&2
    echo -e "\033[1;31mInstallation:\033[0m" >&2
    echo "  17) Install with demo data" >&2
    echo "  18) Install without demo data" >&2
  fi
  
  echo "" >&2
  # Show current environment or "-" if not in a project
  local env_display="${DC_ORO_NAME:--}"
  if [[ "$env_display" != "-" ]]; then
    echo -e "Current Environment: \033[1m${env_display}\033[0m ($status_display)" >&2
  else
    echo -e "Current Environment: \033[1m-\033[0m (\033[33mnot in project\033[0m)" >&2
  fi

  # Use DC_ORO_APPDIR if set, otherwise PWD if in project, otherwise "-"
  local display_dir="${DC_ORO_APPDIR:-}"
  if [[ -z "$display_dir" ]]; then
    if [[ -n "${DC_ORO_NAME:-}" ]]; then
      # We're in a project but DC_ORO_APPDIR not set yet, use PWD
      display_dir="$(realpath "$(pwd)" 2>/dev/null || pwd)"
    else
      display_dir="-"
    fi
  fi

  if [[ "$display_dir" == "-" ]]; then
    echo -e "Current Directory: \033[2m-\033[0m" >&2
  else
    echo -e "Current Directory: $display_dir" >&2
  fi
  echo "" >&2
  echo -n "Enter option [1-18] or 'q' to quit: " >&2
  read -r choice
  
  case "$choice" in
    1)
      list_environments
      local list_result=$?
      # If list_environments switched directory, it will exec the script itself
      # So we only get here if no switch happened
      if [[ $list_result -ne 2 ]]; then
        echo "" >&2
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
      fi
      ;;
    2)
      echo "" >&2
      # Call init command
      run_command_with_menu_return init
      ;;
    3)
      echo "" >&2
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      # Call up command
      run_command_with_menu_return up -d
      ;;
    4)
      echo "" >&2
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      # Call down command
      run_command_with_menu_return down
      ;;
    5)
      echo "" >&2
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      if confirm_yes_no "Are you sure you want to delete this environment? This will purge all data and remove config directory." "no"; then
        run_command_with_menu_return purge --yes
        echo "" >&2
        
        # Remove config directory
        if [[ -n "${DC_ORO_CONFIG_DIR:-}" ]] && [[ -d "${DC_ORO_CONFIG_DIR}" ]]; then
          msg_info "Removing config directory: ${DC_ORO_CONFIG_DIR}"
          rm -rf "${DC_ORO_CONFIG_DIR}" 2>/dev/null && msg_ok "Config directory removed" || msg_warning "Failed to remove config directory"
        fi
        
        msg_ok "Environment deleted successfully"
        echo "" >&2
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
      else
        show_interactive_menu
      fi
      ;;
    6)
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      # Call ssh command
      run_command_with_menu_return ssh
      ;;
    7)
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      manage_domains
      echo "" >&2
      if confirm_yes_no "Return to menu?" "yes"; then
        show_interactive_menu
      else
        exit 0
      fi
      ;;
    8)
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      configure_url_interactive
      echo "" >&2
      if confirm_yes_no "Return to menu?" "yes"; then
        show_interactive_menu
      else
        exit 0
      fi
      ;;
    9)
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      export_database_interactive
      echo "" >&2
      if confirm_yes_no "Return to menu?" "yes"; then
        show_interactive_menu
      else
        exit 0
      fi
      ;;
    10)
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      import_database_interactive
      echo "" >&2
      if confirm_yes_no "Return to menu?" "yes"; then
        show_interactive_menu
      else
        exit 0
      fi
      ;;
    11)
      echo "" >&2
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      # Call cache clear command
      run_command_with_menu_return cache clear
      ;;
    12)
      if ! check_in_project; then
        echo -n "Press Enter to continue..." >&2
        read -r
        show_interactive_menu
        exit
      fi
      platform_update_interactive
      echo "" >&2
      if confirm_yes_no "Return to menu?" "yes"; then
        show_interactive_menu
      else
        exit 0
      fi
      ;;
    13)
      echo "" >&2
      msg_header "Environment Status"
      echo "" >&2
      # Initialize required environment variables to avoid warnings
      export DC_ORO_PORT_PREFIX=${DC_ORO_PORT_PREFIX:-"301"}
      # Build Traefik rule if not set
      if [[ -z "${DC_ORO_TRAEFIK_RULE:-}" ]]; then
        local traefik_rule="Host(\`${DC_ORO_NAME:-unnamed}.docker.local\`)"
        if [[ -n "${DC_ORO_EXTRA_HOSTS:-}" ]]; then
          IFS=',' read -ra HOSTS <<< "$DC_ORO_EXTRA_HOSTS"
          for host in "${HOSTS[@]}"; do
            host=$(echo "$host" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            if [[ -n "$host" ]]; then
              if [[ "$host" != *.* ]]; then
                host="$host.docker.local"
              fi
              traefik_rule="$traefik_rule || Host(\`$host\`)"
            fi
          done
        fi
        export DC_ORO_TRAEFIK_RULE="$traefik_rule"
      fi
      # Ensure Docker Compose command is initialized
      local docker_cmd="${DOCKER_BIN:-docker}"
      local compose_cmd="${docker_cmd} compose"

      # Show only container name and status
      printf "%-40s %-15s\n" "CONTAINER" "STATUS" >&2
      printf "%-40s %-15s\n" "----------------------------------------" "---------------" >&2

      local output_file=$(mktemp)

      # Build compose command
      local compose_ps_cmd="${compose_cmd}"
      if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose.yml" ]]; then
        compose_ps_cmd="${compose_ps_cmd} -f ${DC_ORO_CONFIG_DIR}/docker-compose.yml"
      fi
      compose_ps_cmd="${compose_ps_cmd} -p ${DC_ORO_NAME}"

      # Try JSON format first (more reliable)
      local ps_output=$(${compose_ps_cmd} ps --format json 2>&1 | grep -v "WARN\[0000\]" || true)

      if command -v jq >/dev/null 2>&1 && echo "$ps_output" | jq -e '. | length > 0' >/dev/null 2>&1; then
        # Parse JSON output and write to file
        echo "$ps_output" | jq -r '.[] | "\(.Name)\t\(.State)"' 2>/dev/null > "$output_file"
      else
        # Fallback: use table format
        ${compose_ps_cmd} ps --format "table {{.Name}}\t{{.State}}" 2>&1 | grep -v "WARN\[0000\]" | tail -n +2 > "$output_file" || true
      fi

      # Display results from file
      local has_output=false
      if [[ -s "$output_file" ]]; then
        while IFS=$'\t' read -r name state; do
          if [[ -n "$name" ]] && [[ "$name" != "NAME" ]] && [[ "$name" != "null" ]] && [[ "$name" != "" ]]; then
            printf "%-40s %-15s\n" "$name" "$state" >&2
            has_output=true
          fi
        done < "$output_file"
      fi

      rm -f "$output_file"

      if [[ "$has_output" == "false" ]]; then
        msg_info "No containers found for this environment."
        msg_info "Start the environment with option 3 to see containers here."
      fi

      echo "" >&2
      echo -n "Press Enter to continue..." >&2
      read -r
      show_interactive_menu
      ;;
    14)
      echo "" >&2
      msg_info "Image build - rebuild or pull PHP images"
      echo "" >&2
      if confirm_yes_no "Build images with cache?" "yes"; then
        run_command_with_menu_return image build
      else
        if confirm_yes_no "Build images without cache (full rebuild)?" "no"; then
          run_command_with_menu_return image build --no-cache
        else
          show_interactive_menu
        fi
      fi
      ;;
    15)
      echo "" >&2
      msg_info "Starting proxy..."
      run_command_with_menu_return proxy up -d
      ;;
    16)
      echo "" >&2
      if confirm_yes_no "Are you sure you want to stop the proxy?" "no"; then
        msg_info "Stopping proxy..."
        run_command_with_menu_return proxy down
      else
        show_interactive_menu
      fi
      ;;
    17)
      echo "" >&2
      msg_warning "WARNING: This will PURGE all existing data (database, cache, volumes) and reinstall!"
      echo "" >&2
      if confirm_yes_no "Install Application WITH demo data? (purge + install)" "no"; then
        msg_info "Starting fresh installation with demo data..."
        msg_info "Step 1: Purging existing environment..."
        echo "" >&2
        "$0" purge --yes 2>&1 || true
        echo "" >&2
        msg_info "Step 2: Running installation (this may take 5-30 minutes depending on hardware)..."
        echo "" >&2
        run_command_with_menu_return install with demo
      else
        show_interactive_menu
      fi
      ;;
    18)
      echo "" >&2
      msg_warning "WARNING: This will PURGE all existing data (database, cache, volumes) and reinstall!"
      echo "" >&2
      if confirm_yes_no "Install Application WITHOUT demo data? (purge + install)" "no"; then
        msg_info "Starting fresh installation without demo data..."
        msg_info "Step 1: Purging existing environment..."
        echo "" >&2
        "$0" purge --yes 2>&1 || true
        echo "" >&2
        msg_info "Step 2: Running installation (this may take 5-30 minutes depending on hardware)..."
        echo "" >&2
        run_command_with_menu_return install without demo
      else
        show_interactive_menu
      fi
      ;;
    q|Q)
      echo "" >&2
      msg_info "Goodbye!"
      exit 0
      ;;
    *)
      echo "" >&2
      msg_error "Invalid option: $choice"
      echo "" >&2
      echo -n "Press Enter to continue..." >&2
      read -r
      show_interactive_menu
      ;;
  esac
}

# Function to resolve binary location with error handling
# Usage: resolve_bin "binary_name" ["install_instructions"]
resolve_bin() {
  local bin_name="$1"
  local install_msg="${2:-}"
  local found_path=""
  
  # Try PATH first
  if command -v "$bin_name" >/dev/null 2>&1; then
    found_path=$(command -v "$bin_name")
    if [ "$DEBUG" ]; then echo "DEBUG: Found $bin_name in PATH: $found_path" >&2; fi
    echo "$found_path"
    return 0
  fi
  
  # Try common locations for specific binaries
  case "$bin_name" in
    "brew")
      local brew_paths=("/opt/homebrew/bin/brew" "/usr/local/bin/brew" "/home/linuxbrew/.linuxbrew/bin/brew")
      for brew_path in "${brew_paths[@]}"; do
        if [[ -x "$brew_path" ]]; then
          found_path="$brew_path"
          msg_warning "$bin_name found at $found_path but not in PATH"
          echo "   Add to PATH: export PATH=\"$(dirname "$found_path"):\$PATH\"" >&2
          echo "$found_path"
          return 0
        fi
      done
      ;;
    "docker")
      local docker_paths=("/usr/bin/docker" "/usr/local/bin/docker" "/snap/bin/docker")
      for docker_path in "${docker_paths[@]}"; do
        if [[ -x "$docker_path" ]]; then
          found_path="$docker_path"
          msg_warning "$bin_name found at $found_path but not in PATH"
          echo "$found_path"
          return 0
        fi
      done
      ;;
  esac
  
  # Not found - show error and exit
  msg_error "$bin_name not found in PATH or common locations"
  
  if [[ -n "$install_msg" ]]; then
    echo "   $install_msg"
  else
    # Default install instructions
    case "$bin_name" in
      "docker")
        echo "   Install: curl -fsSL https://get.docker.com | sh"
        echo "   Or visit: https://docs.docker.com/engine/install/"
        ;;
      "brew")
        echo "   Install: /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
        echo "   Then add to PATH: export PATH=\"/home/linuxbrew/.linuxbrew/bin:\$PATH\""
        ;;
      "rsync")
        echo "   Install: sudo apt-get install rsync  # Ubuntu/Debian"
        echo "   Or: brew install rsync"
        ;;
      "jq")
        echo "   Install: sudo apt-get install jq  # Ubuntu/Debian"
        echo "   Or: brew install jq"
        ;;
      *)
        echo "   Please install $bin_name and ensure it's in your PATH"
        ;;
    esac
  fi
  
  echo
  msg_error "OroDC cannot continue without $bin_name"
  exit 1
}
echo_highlight() { msg_highlight "$*"; }

# Save original arguments before any processing
original_args=("$@")

left_flags=()
right_flags=()
left_options=()
right_options=()
args=()

args_input=("$@")

# Save and load XDEBUG_MODE* environment variables
# Use realpath to ensure we have absolute path (important after menu switch)
export PWD=$(realpath "$(pwd)" 2>/dev/null || pwd)
# Use selected environment name if available (from menu switch), otherwise use basename
# Compare using realpath to handle symlinks and relative paths
current_pwd=$(realpath "$(pwd)" 2>/dev/null || pwd)
selected_path_normalized=$(realpath "${ORODC_SELECTED_ENV_PATH:-}" 2>/dev/null || echo "${ORODC_SELECTED_ENV_PATH:-}")

debug_log "Script start: PWD='$PWD' current_pwd='$current_pwd'"
debug_log "Script start: ORODC_SELECTED_ENV_NAME='${ORODC_SELECTED_ENV_NAME:-<not set>}' PATH='${ORODC_SELECTED_ENV_PATH:-<not set>}' CONFIG='${ORODC_SELECTED_ENV_CONFIG:-<not set>}'"

if [[ -n "${ORODC_SELECTED_ENV_NAME:-}" ]] && [[ -n "${ORODC_SELECTED_ENV_PATH:-}" ]]; then
  debug_log "Script start: Processing ORODC_SELECTED_ENV_* variables"

  # Debug output if DEBUG is set
  if [[ -n "${DEBUG:-}" ]]; then
    echo "[DEBUG] ORODC_SELECTED_ENV_NAME: ${ORODC_SELECTED_ENV_NAME}" >&2
    echo "[DEBUG] ORODC_SELECTED_ENV_PATH: ${ORODC_SELECTED_ENV_PATH}" >&2
    echo "[DEBUG] current_pwd: $current_pwd" >&2
    echo "[DEBUG] selected_path_normalized: $selected_path_normalized" >&2
    echo "[DEBUG] Comparison: '$current_pwd' == '$selected_path_normalized'" >&2
  fi
  
  # Check if we're in the selected directory (with tolerance for path variations)
  if [[ "$current_pwd" == "$selected_path_normalized" ]]; then
    debug_log "Script start: Paths match - setting DC_ORO_NAME='${ORODC_SELECTED_ENV_NAME}' DC_ORO_APPDIR='${ORODC_SELECTED_ENV_PATH}'"
    export DC_ORO_NAME="${ORODC_SELECTED_ENV_NAME}"
    if [[ -n "${ORODC_SELECTED_ENV_CONFIG:-}" ]]; then
      export DC_ORO_CONFIG_DIR="${ORODC_SELECTED_ENV_CONFIG}"
    else
      export DC_ORO_CONFIG_DIR="$HOME/.$(basename $0)/${DC_ORO_NAME}"
    fi
    # Set DC_ORO_APPDIR to the selected path to ensure correct project directory
    export DC_ORO_APPDIR="${ORODC_SELECTED_ENV_PATH}"
    # Clear selection variables after use
    unset ORODC_SELECTED_ENV_NAME
    unset ORODC_SELECTED_ENV_PATH
    unset ORODC_SELECTED_ENV_CONFIG
  else
    # If paths don't match, we might need to cd first
    # This can happen if exec didn't preserve the directory change
    if [[ -d "$selected_path_normalized" ]]; then
      debug_log "Script start: Paths don't match - cd to '$selected_path_normalized'"
      if [[ -n "${DEBUG:-}" ]]; then
        echo "[DEBUG] Paths don't match, changing directory to: $selected_path_normalized" >&2
      fi
      cd "$selected_path_normalized" || true
      export PWD=$(realpath "$(pwd)" 2>/dev/null || pwd)
      debug_log "Script start: After cd - PWD='$PWD' setting DC_ORO_NAME='${ORODC_SELECTED_ENV_NAME}' DC_ORO_APPDIR='${ORODC_SELECTED_ENV_PATH}'"
      export DC_ORO_NAME="${ORODC_SELECTED_ENV_NAME}"
      if [[ -n "${ORODC_SELECTED_ENV_CONFIG:-}" ]]; then
        export DC_ORO_CONFIG_DIR="${ORODC_SELECTED_ENV_CONFIG}"
      else
        export DC_ORO_CONFIG_DIR="$HOME/.$(basename $0)/${DC_ORO_NAME}"
      fi
      export DC_ORO_APPDIR="${ORODC_SELECTED_ENV_PATH}"
      # Clear selection variables after use
      unset ORODC_SELECTED_ENV_NAME
      unset ORODC_SELECTED_ENV_PATH
      unset ORODC_SELECTED_ENV_CONFIG
    fi
  fi
else
  # Always recalculate DC_ORO_NAME from current directory to ensure it's correct after switching
  export DC_ORO_NAME=$(basename $(pwd))
  # Allow override of config directory via environment variable
  if [[ -z "${DC_ORO_CONFIG_DIR}" ]]; then
    export DC_ORO_CONFIG_DIR="$HOME/.$(basename $0)/${DC_ORO_NAME}"
  fi
fi
# CRITICAL: Set Docker Compose project name to match OroDC project name
# This ensures volumes and networks use consistent naming with DC_ORO_NAME
export COMPOSE_PROJECT_NAME="$DC_ORO_NAME"

if [[ ! -d "${DC_ORO_CONFIG_DIR}" ]]; then
    mkdir -p "${DC_ORO_CONFIG_DIR}"
fi

XDEBUG_ENV_FILE="${DC_ORO_CONFIG_DIR}/.xdebug_env"

# Save XDEBUG_MODE* variables if they exist in environment
if [[ -n "${XDEBUG_MODE:-}" ]] || [[ -n "${XDEBUG_MODE_CLI:-}" ]] || [[ -n "${XDEBUG_MODE_FPM:-}" ]] || [[ -n "${XDEBUG_MODE_CONSUMER:-}" ]]; then
  {
    [[ -n "${XDEBUG_MODE:-}" ]] && echo "export XDEBUG_MODE=\"${XDEBUG_MODE}\""
    [[ -n "${XDEBUG_MODE_CLI:-}" ]] && echo "export XDEBUG_MODE_CLI=\"${XDEBUG_MODE_CLI}\""
    [[ -n "${XDEBUG_MODE_FPM:-}" ]] && echo "export XDEBUG_MODE_FPM=\"${XDEBUG_MODE_FPM}\""
    [[ -n "${XDEBUG_MODE_CONSUMER:-}" ]] && echo "export XDEBUG_MODE_CONSUMER=\"${XDEBUG_MODE_CONSUMER}\""
  } > "${XDEBUG_ENV_FILE}"
fi

# Load XDEBUG_MODE* variables from file if they don't exist in environment
if [[ -f "${XDEBUG_ENV_FILE}" ]]; then
  source "${XDEBUG_ENV_FILE}"
fi

# Set default value for XDEBUG_MODE if not set
[[ -z "${XDEBUG_MODE:-}" ]] && export XDEBUG_MODE="off"

# Set fallback values for XDEBUG_MODE_* variables if not set but XDEBUG_MODE exists
if [[ -n "${XDEBUG_MODE:-}" ]]; then
  [[ -z "${XDEBUG_MODE_CLI:-}" ]] && export XDEBUG_MODE_CLI="${XDEBUG_MODE}"
  [[ -z "${XDEBUG_MODE_FPM:-}" ]] && export XDEBUG_MODE_FPM="${XDEBUG_MODE}"
  [[ -z "${XDEBUG_MODE_CONSUMER:-}" ]] && export XDEBUG_MODE_CONSUMER="${XDEBUG_MODE}"
fi

# Handle version command (only "version", not --version)
if [[ "$1" == "version" ]]; then
  # Try to find and read version from Formula file
  FORMULA_VERSION=""
  FORMULA_FILE=""
  
  # Use find to locate Formula file, starting from script directory and going up
  SCRIPT_DIR="$(dirname "$0")"
  FORMULA_FILE=$(find "$SCRIPT_DIR" -name "docker-compose-oroplatform.rb" -type f 2>/dev/null | head -1)
  
  # If not found relative to script, try brew repository
  if [[ -z "$FORMULA_FILE" ]] && command -v brew >/dev/null 2>&1; then
    BREW_REPO=$(brew --repository 2>/dev/null)
    if [[ -n "$BREW_REPO" ]]; then
      FORMULA_FILE=$(find "$BREW_REPO" -name "docker-compose-oroplatform.rb" -type f 2>/dev/null | head -1)
    fi
  fi
  
  # Extract version from Formula file
  if [[ -n "$FORMULA_FILE" && -f "$FORMULA_FILE" ]]; then
    FORMULA_VERSION=$(grep -o 'version "[^"]*"' "$FORMULA_FILE" 2>/dev/null | sed 's/version "\(.*\)"/\1/')
  fi
  
  # Output version or fallback
  if [[ -n "$FORMULA_VERSION" ]]; then
    echo "orodc version $FORMULA_VERSION"
  else
    echo "orodc version 0.8.3 (fallback)"
  fi
  exit 0
fi

# Handle help/man command
if [[ "$1" == "help" ]] || [[ "$1" == "man" ]]; then
  # Try to find README.md file
  README_FILE=""
  SCRIPT_DIR="$(dirname "$0")"
  
  # Look for README.md in various locations
  # 1. Relative to script directory (development)
  if [[ -f "$SCRIPT_DIR/../README.md" ]]; then
    README_FILE="$SCRIPT_DIR/../README.md"
  elif [[ -f "$SCRIPT_DIR/README.md" ]]; then
    README_FILE="$SCRIPT_DIR/README.md"
  elif [[ -f "$SCRIPT_DIR/../../README.md" ]]; then
    README_FILE="$SCRIPT_DIR/../../README.md"
  fi
  
  # 2. Try to find in Homebrew tap directory
  if [[ -z "$README_FILE" ]] && command -v brew >/dev/null 2>&1; then
    BREW_REPO=$(brew --repository 2>/dev/null)
    if [[ -n "$BREW_REPO" ]]; then
      TAP_README="$BREW_REPO/Library/Taps/digitalspacestdio/homebrew-docker-compose-oroplatform/README.md"
      if [[ -f "$TAP_README" ]]; then
        README_FILE="$TAP_README"
      fi
    fi
  fi
  
  # If README found, display it without pager (always use cat)
  if [[ -n "$README_FILE" && -f "$README_FILE" ]]; then
    echo "==> OroDC Documentation"
    echo
    cat "$README_FILE"
  else
    echo "==> OroDC Help"
    echo
    msg_highlight "Documentation not found locally. Please visit:"
    echo "   https://github.com/digitalspacestdio/homebrew-docker-compose-oroplatform"
    echo
    msg_highlight "Quick Commands:"
    echo "   orodc version                    # Show version"
    echo "   orodc install && orodc up -d     # Setup and start"
    echo "   orodc --version                  # Check PHP version"
    echo "   orodc psql -l                    # List databases"
    echo "   orodc tests install              # Setup test environment"
    echo "   orodc config-refresh             # Clear cached configs and force resync"
    echo
    echo " For full documentation, run: brew info docker-compose-oroplatform"
  fi
  exit 0
fi

# Show interactive menu when no arguments provided and in interactive terminal
# This must be checked VERY EARLY, before any argument parsing
if [[ $# -eq 0 ]] && [[ -t 0 ]] && [[ -z "${ORODC_NO_MENU:-}" ]]; then
  # Check if current directory is an OroPlatform project
  if ! is_oroplatform_project "$PWD"; then
    # Try to switch to last used environment
    last_env=$(get_last_used_environment 2>/dev/null)
    if [[ -n "$last_env" ]] && [[ -d "$last_env" ]] && [[ "$last_env" != "$PWD" ]]; then
      msg_info "No project found in current directory."
      msg_info "Switching to last used environment: $(basename "$last_env")"
      cd "$last_env" || {
        show_interactive_menu
        exit $?
      }
      # Restart script in new directory
      unset DC_ORO_NAME
      unset DC_ORO_CONFIG_DIR
      unset COMPOSE_PROJECT_NAME
      exec "$0"
    fi
  fi
  show_interactive_menu
  exit $?
fi

# Function to get first non-flag argument
get_first_non_flag_arg() {
  local args=("$@")
  for arg in "${args[@]}"; do
    if [[ "$arg" != -* ]]; then
      echo "$arg"
      return 0
    fi
  done
  echo "php"
  return 0
}

# Check if first argument is a docker compose command
# Only docker compose commands need left/right argument parsing
is_compose_command() {
  local cmd="$1"
  local compose_commands="build|config|cp|create|down|events|exec|export|images|kill|logs|ls|pause|port|ps|pull|push|restart|rm|run|scale|start|stats|stop|top|unpause|up|version|volumes|wait|watch"
  echo "$cmd" | grep -qE "^($compose_commands)$"
}

# Find first non-flag argument to determine parsing needs
temp_first_non_flag_arg=""
if [[ $# -gt 0 ]]; then
  for arg in "$@"; do
    if [[ "$arg" != -* ]]; then
      temp_first_non_flag_arg="$arg"
      break
    fi
  done
fi

# If no command found (only flags), treat as PHP command
if [[ -z "$temp_first_non_flag_arg" && $# -gt 0 ]]; then
  temp_first_non_flag_arg="php"
fi

# Handle proxy commands early - they don't require project initialization
if [[ "$temp_first_non_flag_arg" == "proxy" ]]; then
  # Initialize minimal dependencies for proxy commands
  DOCKER_BIN=$(resolve_bin "docker" "Docker is required. Install from https://docs.docker.com/get-docker/")
  DOCKER_COMPOSE_BIN="$DOCKER_BIN compose"
  
  # Get OroDC install directory
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  
  # Get Homebrew prefix dynamically (works on macOS and Linux)
  BREW_PREFIX="$(brew --prefix 2>/dev/null || echo "/home/linuxbrew/.linuxbrew")"
  
  # Try multiple paths in order:
  # 1. Development path (tap directory)
  # 2. Homebrew installed path (pkgshare)
  # 3. Relative to script location
  if [[ -d "${BREW_PREFIX}/Homebrew/Library/Taps/digitalspacestdio/homebrew-docker-compose-oroplatform/compose" ]]; then
    DC_ORO_COMPOSE_DIR="${BREW_PREFIX}/Homebrew/Library/Taps/digitalspacestdio/homebrew-docker-compose-oroplatform/compose"
  elif [[ -d "${BREW_PREFIX}/share/docker-compose-oroplatform/compose" ]]; then
    DC_ORO_COMPOSE_DIR="${BREW_PREFIX}/share/docker-compose-oroplatform/compose"
  elif [[ -d "$SCRIPT_DIR/../compose" ]]; then
    DC_ORO_COMPOSE_DIR="$SCRIPT_DIR/../compose"
  elif [[ -d "$SCRIPT_DIR/../share/docker-compose-oroplatform/compose" ]]; then
    DC_ORO_COMPOSE_DIR="$SCRIPT_DIR/../share/docker-compose-oroplatform/compose"
  else
    msg_error "Could not find OroDC compose directory"
    exit 1
  fi
  
  PROXY_COMPOSE_FILE="${DC_ORO_COMPOSE_DIR}/docker-compose-proxy.yml"
  
  if [[ ! -f "$PROXY_COMPOSE_FILE" ]]; then
    msg_error "Proxy compose file not found: $PROXY_COMPOSE_FILE"
    exit 1
  fi
  
  # Get proxy subcommand
  PROXY_CMD="${2:-}"
  shift 2 2>/dev/null || shift 1 2>/dev/null || true
  
  # Function to install CA certificates
  install_proxy_certs() {
    msg_info "Installing CA certificate to system trust store..."
    
    # Check if proxy container is running
    if ! ${DOCKER_BIN} ps --filter "name=proxy" --format "{{.Names}}" | grep -q "^proxy$"; then
      msg_error "Proxy container is not running. Start it first with: orodc proxy up -d"
      exit 1
    fi
    
    # Wait for container to be healthy
    msg_info "Waiting for proxy container to be healthy..."
    for i in {1..30}; do
      if ${DOCKER_BIN} ps --filter "name=proxy" --filter "health=healthy" --format "{{.Names}}" | grep -q "^proxy$"; then
        break
      fi
      sleep 1
    done
    
    INSTALL_DATE=$(date +%Y%m%d_%H%M%S)
    CERT_OUTPUT_PATH="${HOME}/root_ca_docker_local_${INSTALL_DATE}.crt"
    
    # Export certificate content (not symlink)
    ${DOCKER_BIN} exec proxy cat /certs/ca.crt > "${CERT_OUTPUT_PATH}" 2>/dev/null
    
    if [[ ! -f "${CERT_OUTPUT_PATH}" ]] || [[ ! -s "${CERT_OUTPUT_PATH}" ]]; then
      msg_error "Failed to export certificate from proxy container"
      exit 1
    fi
    
    msg_info "CA certificate exported to: ${CERT_OUTPUT_PATH}"
    
    # Detect OS
    IS_WSL=false
    if grep -qi microsoft /proc/version 2>/dev/null || grep -qi wsl /proc/version 2>/dev/null; then
      IS_WSL=true
    fi
    
    # Install certificate based on OS
    if [[ "$OSTYPE" == "darwin"* ]]; then
      # macOS
      msg_info "Installing certificate to macOS System Keychain..."
      if sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain "${CERT_OUTPUT_PATH}" 2>/dev/null; then
        msg_ok "Certificate installed to macOS System Keychain"
        rm -f "${CERT_OUTPUT_PATH}"
      else
        msg_warning "Failed to install certificate automatically. Manual installation required:"
        msg_info "  sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain ${CERT_OUTPUT_PATH}"
      fi
      
    elif [[ "$IS_WSL" == "true" ]]; then
      # WSL2 - install to Linux and show Windows instructions
      msg_info "Installing certificate to Linux (WSL)..."
      
      if [[ -f "/etc/debian_version" ]]; then
        # Debian/Ubuntu
        sudo cp "${CERT_OUTPUT_PATH}" /usr/local/share/ca-certificates/ 2>/dev/null && \
        sudo update-ca-certificates 2>/dev/null && \
        msg_ok "Certificate installed to Linux trust store"
      fi
      
      # NSS database for Chrome/Node.js
      if command -v certutil >/dev/null 2>&1; then
        msg_info "Installing certificate to NSS database (Chrome/Node.js)..."
        mkdir -p "${HOME}/.pki/nssdb" 2>/dev/null
        certutil -d sql:"${HOME}/.pki/nssdb" -A -t "C,," -n "OroDC Docker Local CA" -i "${CERT_OUTPUT_PATH}" 2>/dev/null && \
        msg_ok "Certificate installed to NSS database"
      else
        msg_info "For Chrome/Node.js support, install libnss3-tools:"
        msg_info "  sudo apt install libnss3-tools"
        msg_info "  mkdir -p \$HOME/.pki/nssdb"
        msg_info "  certutil -d sql:\$HOME/.pki/nssdb -N"
        msg_info "  certutil -d sql:\$HOME/.pki/nssdb -A -t \"C,,\" -n \"OroDC Docker Local CA\" -i ${CERT_OUTPUT_PATH}"
      fi
      
      msg_warning "WSL2 detected. Certificate saved to: ${CERT_OUTPUT_PATH}"
      msg_info ""
      msg_info "To trust HTTPS in Windows host:"
      msg_info "  1. Copy certificate to Windows: ${CERT_OUTPUT_PATH}"
      msg_info "  2. Double-click the .crt file in Windows Explorer"
      msg_info "  3. Click 'Install Certificate'"
      msg_info "  4. Select 'Local Machine' and click Next"
      msg_info "  5. Select 'Place all certificates in the following store'"
      msg_info "  6. Click 'Browse' and select 'Trusted Root Certification Authorities'"
      msg_info "  7. Click Next and Finish"
      msg_info ""
      
    else
      # Linux (non-WSL)
      msg_info "Installing certificate to Linux trust store..."
      
      if [[ -f "/etc/debian_version" ]]; then
        # Debian/Ubuntu
        if sudo cp "${CERT_OUTPUT_PATH}" /usr/local/share/ca-certificates/ 2>/dev/null && \
           sudo update-ca-certificates 2>/dev/null; then
          msg_ok "Certificate installed to system trust store"
          rm -f "${CERT_OUTPUT_PATH}"
        else
          msg_warning "Failed to install certificate automatically. Manual installation required:"
          msg_info "  sudo cp ${CERT_OUTPUT_PATH} /usr/local/share/ca-certificates/"
          msg_info "  sudo update-ca-certificates"
        fi
      elif [[ -f "/etc/redhat-release" ]]; then
        # RHEL/CentOS/Fedora
        if sudo cp "${CERT_OUTPUT_PATH}" /etc/pki/ca-trust/source/anchors/ 2>/dev/null && \
           sudo update-ca-trust 2>/dev/null; then
          msg_ok "Certificate installed to system trust store"
          rm -f "${CERT_OUTPUT_PATH}"
        else
          msg_warning "Failed to install certificate automatically. Manual installation required:"
          msg_info "  sudo cp ${CERT_OUTPUT_PATH} /etc/pki/ca-trust/source/anchors/"
          msg_info "  sudo update-ca-trust"
        fi
      fi
      
      # NSS database for Chrome/Node.js
      if command -v certutil >/dev/null 2>&1; then
        msg_info "Installing certificate to NSS database (Chrome/Node.js)..."
        mkdir -p "${HOME}/.pki/nssdb" 2>/dev/null
        
        # Initialize NSS DB if it doesn't exist
        if [[ ! -f "${HOME}/.pki/nssdb/cert9.db" ]]; then
          certutil -d sql:"${HOME}/.pki/nssdb" -N --empty-password 2>/dev/null
        fi
        
        if certutil -d sql:"${HOME}/.pki/nssdb" -A -t "C,," -n "OroDC Docker Local CA" -i "${CERT_OUTPUT_PATH}" 2>/dev/null; then
          msg_ok "Certificate installed to NSS database"
          rm -f "${CERT_OUTPUT_PATH}"
        fi
      else
        msg_info "For Chrome/Node.js support, install libnss3-tools:"
        msg_info "  sudo apt install libnss3-tools"
        msg_info "  mkdir -p \$HOME/.pki/nssdb"
        msg_info "  certutil -d sql:\$HOME/.pki/nssdb -N"
        msg_info "  certutil -d sql:\$HOME/.pki/nssdb -A -t \"C,,\" -n \"OroDC Docker Local CA\" -i ${CERT_OUTPUT_PATH}"
      fi
    fi
    
    msg_ok "Certificate installation complete!"
  }
  
  # Handle proxy subcommands
  case "$PROXY_CMD" in
    up)
      msg_info "Starting proxy services..."
      
      # Create shared network if it doesn't exist
      if ! ${DOCKER_BIN} network inspect dc_shared_net >/dev/null 2>&1; then
        msg_info "Creating dc_shared_net network..."
        ${DOCKER_BIN} network create dc_shared_net || {
          msg_error "Failed to create dc_shared_net network"
          exit 1
        }
      fi
      
      # Configure Traefik bind address if not set
      if [[ -z "${TRAEFIK_BIND_ADDRESS:-}" ]]; then
        # Auto-detect environment and suggest default
        IS_WSL=false
        IS_LIMA=false
        DETECTED_ENV=""
        
        # Check WSL
        if grep -qi microsoft /proc/version 2>/dev/null || grep -qi wsl /proc/version 2>/dev/null; then
          IS_WSL=true
          DETECTED_ENV="Windows WSL2"
        fi
        
        # Check Lima VM
        if [[ -d "/lima" ]] || [[ -n "${LIMA_INSTANCE:-}" ]]; then
          IS_LIMA=true
          DETECTED_ENV="Lima VM"
        fi
        
        # Determine default based on environment
        if [[ "$IS_WSL" == "true" ]] || [[ "$IS_LIMA" == "true" ]]; then
          # WSL or Lima VM - need to bind to all interfaces for host access
          SUGGESTED_BIND="0.0.0.0"
          SUGGESTED_REASON="VM/WSL detected - bind to all interfaces for host access"
        else
          # Native Docker (macOS or Linux) or unknown - bind to localhost only
          SUGGESTED_BIND="127.0.0.1"
          SUGGESTED_REASON="Native Docker - bind to localhost only (secure)"
        fi
        
        # Check if running in non-interactive mode (CI/CD or piped)
        if [[ ! -t 0 ]]; then
          # Non-interactive: use suggested default
          export TRAEFIK_BIND_ADDRESS="$SUGGESTED_BIND"
          msg_info "Non-interactive mode: using default bind address: ${SUGGESTED_BIND}"
        else
          # Interactive mode: show prompts
          msg_info ""
          msg_info "Proxy Network Configuration"
          msg_info "============================"
          msg_info ""
          
          msg_info "Choose proxy bind address (affects HTTP, HTTPS, SOCKS5):"
          msg_info ""
          msg_info "  1) 127.0.0.1 (localhost only)"
          msg_info "     - Most secure: Only accessible from this machine"
          msg_info "     - Use for: Native Docker on macOS/Linux"
          msg_info ""
          msg_info "  2) 0.0.0.0 (all interfaces)"
          msg_info "     - Allows access from: VM host + network"
          msg_info "     - Use for: WSL2, Lima VM, remote access"
          msg_info ""
          
          if [[ -n "$DETECTED_ENV" ]]; then
            msg_info "Detected: ${DETECTED_ENV}"
            msg_info "Suggested: ${SUGGESTED_BIND} (${SUGGESTED_REASON})"
          else
            msg_info "Could not detect environment"
            msg_info "Suggested: ${SUGGESTED_BIND} (safe default)"
          fi
          
          msg_info ""
          
          # Interactive prompt with validation
          BIND_CHOICE=$(prompt_selector "Enter choice [1-2], IP address, or press Enter for suggested (${SUGGESTED_BIND}): " "$SUGGESTED_BIND" "1:127.0.0.1" "2:0.0.0.0")
          
          export TRAEFIK_BIND_ADDRESS="$BIND_CHOICE"
          
          case "$BIND_CHOICE" in
            "127.0.0.1")
              msg_ok "Using 127.0.0.1 (localhost only)"
              ;;
            "0.0.0.0")
              msg_ok "Using 0.0.0.0 (all interfaces)"
              msg_warning "Make sure your firewall is properly configured!"
              ;;
            "$SUGGESTED_BIND")
              msg_ok "Using suggested: ${SUGGESTED_BIND}"
              ;;
            *)
              msg_ok "Using custom bind address: ${BIND_CHOICE}"
              ;;
          esac
          
          msg_info ""
          msg_info "To skip this prompt next time, set:"
          msg_info "  export TRAEFIK_BIND_ADDRESS=${TRAEFIK_BIND_ADDRESS}"
          msg_info "Or add to .env.orodc:"
          msg_info "  echo 'TRAEFIK_BIND_ADDRESS=${TRAEFIK_BIND_ADDRESS}' >> .env.orodc"
          msg_info ""
        fi
      else
        msg_info "Using bind address: ${TRAEFIK_BIND_ADDRESS} (from environment)"
      fi
      
      # Configure SOCKS5 port if not set
      if [[ -z "${DC_PROXY_SOCKS5_PORT:-}" ]]; then
        # Check if running in non-interactive mode (CI/CD or piped)
        if [[ ! -t 0 ]]; then
          # Non-interactive: use default port
          export DC_PROXY_SOCKS5_PORT="1080"
          msg_info "Non-interactive mode: using default SOCKS5 port: 1080"
        else
          # Interactive mode: show prompts
          msg_info ""
          msg_info "SOCKS5 Proxy Port Configuration"
          msg_info "================================"
          msg_info ""
          msg_info "Choose SOCKS5 proxy port:"
          msg_info "  - Default: 1080 (standard SOCKS5 port)"
          msg_info "  - Custom: any available port (e.g., 9999)"
          msg_info ""
          
          # Interactive prompt with validation
          PORT_CHOICE=$(prompt_port "Enter SOCKS5 port (press Enter for default: 1080): " "1080")
          
          export DC_PROXY_SOCKS5_PORT="$PORT_CHOICE"
          
          if [[ "$PORT_CHOICE" == "1080" ]]; then
            msg_ok "Using default port: 1080"
          else
            msg_ok "Using custom port: ${PORT_CHOICE}"
          fi
          
          msg_info ""
          msg_info "To skip this prompt next time, set:"
          msg_info "  export DC_PROXY_SOCKS5_PORT=${DC_PROXY_SOCKS5_PORT}"
          msg_info "Or add to .env.orodc:"
          msg_info "  echo 'DC_PROXY_SOCKS5_PORT=${DC_PROXY_SOCKS5_PORT}' >> .env.orodc"
          msg_info ""
        fi
      else
        msg_info "Using SOCKS5 port: ${DC_PROXY_SOCKS5_PORT} (from environment)"
      fi
      
      # Set log level based on DEBUG environment variable
      if [[ "${DEBUG:-}" == "1" ]]; then
        export TRAEFIK_LOG_LEVEL="DEBUG"
      else
        export TRAEFIK_LOG_LEVEL="WARNING"
      fi
      
      # Pass all remaining arguments to docker compose up
      proxy_cmd="${DOCKER_COMPOSE_BIN} -p proxy -f \"$PROXY_COMPOSE_FILE\" up $*"
      
      # Use spinner for detached mode
      if [[ "$*" == *"-d"* ]]; then
        run_with_spinner "Starting proxy services" "$proxy_cmd" || {
          msg_error "Failed to start proxy services"
          exit 1
        }
        
        msg_info ""
        msg_info "Bind address: ${TRAEFIK_BIND_ADDRESS:-127.0.0.1}"
        msg_info "Dashboard:    http://${TRAEFIK_BIND_ADDRESS:-127.0.0.1}:8880/traefik/dashboard/"
        msg_info "Proxy HTTP:   http://${TRAEFIK_BIND_ADDRESS:-127.0.0.1}:8880"
        msg_info "Proxy HTTPS:  https://${TRAEFIK_BIND_ADDRESS:-127.0.0.1}:8443"
        msg_info "SOCKS5:       ${TRAEFIK_BIND_ADDRESS:-127.0.0.1}:${DC_PROXY_SOCKS5_PORT:-1080}"
        msg_info ""
        msg_warning "To enable HTTPS for *.docker.local domains, install CA certificate:"
        msg_info ""
        msg_info "  orodc proxy install-certs"
        msg_info ""
      else
        # Foreground mode - show full output
        ${DOCKER_COMPOSE_BIN} -p proxy -f "$PROXY_COMPOSE_FILE" up "$@" || {
          msg_error "Failed to start proxy services"
          exit 1
        }
      fi
      
      exit 0
      ;;
    
    down)
      proxy_down_cmd="${DOCKER_COMPOSE_BIN} -p proxy -f \"$PROXY_COMPOSE_FILE\" down $*"
      
      run_with_spinner "Stopping proxy services" "$proxy_down_cmd" || {
        msg_error "Failed to stop proxy services"
        exit 1
      }
      exit 0
      ;;
    
    purge)
      proxy_purge_cmd="${DOCKER_COMPOSE_BIN} -p proxy -f \"$PROXY_COMPOSE_FILE\" down -v $*"
      
      run_with_spinner "Removing proxy services and volumes" "$proxy_purge_cmd" || {
        msg_error "Failed to remove proxy services"
        exit 1
      }
      exit 0
      ;;
    
    install-certs)
      install_proxy_certs
      exit 0
      ;;
    
    *)
      msg_error "Unknown proxy command: ${PROXY_CMD}"
      msg_info ""
      msg_info "Available proxy commands:"
      msg_info "  orodc proxy up [-d]       - Start proxy (use -d for detached mode)"
      msg_info "  orodc proxy down          - Stop proxy (keeps volumes)"
      msg_info "  orodc proxy purge         - Remove proxy and volumes"
      msg_info "  orodc proxy install-certs - Install CA certificates to system"
      msg_info ""
      exit 1
      ;;
  esac
fi

# Handle image commands early - they don't require project initialization
if [[ "$temp_first_non_flag_arg" == "image" ]]; then
  # Initialize minimal dependencies for image commands
  DOCKER_BIN=$(resolve_bin "docker" "Docker is required. Install from https://docs.docker.com/get-docker/")
  
  # Get OroDC install directory
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  
  # Get Homebrew prefix dynamically (works on macOS and Linux)
  BREW_PREFIX="$(brew --prefix 2>/dev/null || echo "/home/linuxbrew/.linuxbrew")"
  
  # Try multiple paths in order:
  # 1. Development path (tap directory)
  # 2. Homebrew installed path (pkgshare)
  # 3. Relative to script location
  if [[ -d "${BREW_PREFIX}/Homebrew/Library/Taps/digitalspacestdio/homebrew-docker-compose-oroplatform/compose" ]]; then
    DC_ORO_COMPOSE_DIR="${BREW_PREFIX}/Homebrew/Library/Taps/digitalspacestdio/homebrew-docker-compose-oroplatform/compose"
  elif [[ -d "${BREW_PREFIX}/share/docker-compose-oroplatform/compose" ]]; then
    DC_ORO_COMPOSE_DIR="${BREW_PREFIX}/share/docker-compose-oroplatform/compose"
  elif [[ -d "$SCRIPT_DIR/../compose" ]]; then
    DC_ORO_COMPOSE_DIR="$SCRIPT_DIR/../compose"
  elif [[ -d "$SCRIPT_DIR/../share/docker-compose-oroplatform/compose" ]]; then
    DC_ORO_COMPOSE_DIR="$SCRIPT_DIR/../share/docker-compose-oroplatform/compose"
  else
    msg_error "Could not find OroDC compose directory"
    exit 1
  fi
  
  DOCKER_DIR="${DC_ORO_COMPOSE_DIR}/docker"
  
  if [[ ! -d "$DOCKER_DIR" ]]; then
    msg_error "Docker directory not found: $DOCKER_DIR"
    exit 1
  fi
  
  # Get image subcommand (second argument)
  IMAGE_CMD="${2:-}"
  
  if [[ -z "$IMAGE_CMD" ]]; then
    msg_error "No image command specified"
    msg_info ""
    msg_info "Available image commands:"
    msg_info "  orodc image build [--no-cache]  - Build PHP+Node.js images locally"
    msg_info ""
    exit 1
  fi
  
  case "$IMAGE_CMD" in
    build)
      msg_header "OroDC Image Builder"
      msg_info ""
      
      # Check for --no-cache flag
      NO_CACHE_FLAG=""
      if [[ "${3:-}" == "--no-cache" ]] || [[ "${@}" =~ --no-cache ]]; then
        NO_CACHE_FLAG="--no-cache"
        msg_info "Build mode: No cache (full rebuild)"
      else
        msg_info "Build mode: Using cache (faster)"
      fi
      msg_info ""
      
      # Load environment from .env.orodc if it exists
      if [[ -f ".env.orodc" ]]; then
        msg_info "Loading configuration from .env.orodc"
        set -a
        source ".env.orodc"
        set +a
      fi
      
      # Detect PHP version
      DC_ORO_PHP_VERSION="${DC_ORO_PHP_VERSION:-8.4}"
      DC_ORO_NODE_VERSION="${DC_ORO_NODE_VERSION:-22}"
      DC_ORO_COMPOSER_VERSION="${DC_ORO_COMPOSER_VERSION:-2}"
      DC_ORO_PHP_DIST="${DC_ORO_PHP_DIST:-alpine}"
      
      msg_ok "Configuration detected:"
      msg_info "  PHP Version:      ${DC_ORO_PHP_VERSION}"
      msg_info "  Node.js Version:  ${DC_ORO_NODE_VERSION}"
      msg_info "  Composer Version: ${DC_ORO_COMPOSER_VERSION}"
      msg_info "  PHP Distribution: ${DC_ORO_PHP_DIST}"
      msg_info ""
      
      # Check available disk space (need at least 5GB)
      msg_info "Checking available disk space..."
      AVAILABLE_SPACE_KB=$(df -k . | tail -1 | awk '{print $4}')
      AVAILABLE_SPACE_GB=$((AVAILABLE_SPACE_KB / 1024 / 1024))
      
      if [[ $AVAILABLE_SPACE_GB -lt 5 ]]; then
        msg_warning "Low disk space detected: ${AVAILABLE_SPACE_GB}GB available"
        msg_warning "Docker image builds require at least 5GB of free space"
        msg_warning "Build may fail if disk space runs out"
        msg_info ""
        
        # Prompt for confirmation in interactive mode
        if [[ -t 0 ]]; then
          read -p "Continue anyway? (y/N): " -n 1 -r
          echo
          if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            msg_info "Build cancelled"
            exit 0
          fi
        fi
      else
        msg_ok "Disk space: ${AVAILABLE_SPACE_GB}GB available"
      fi
      msg_info ""
      
      # Define image tags with full registry path
      PHP_BASE_TAG="ghcr.io/digitalspacestdio/orodc-php:${DC_ORO_PHP_VERSION}-${DC_ORO_PHP_DIST}"
      PHP_FINAL_TAG="ghcr.io/digitalspacestdio/orodc-php-node-symfony:${DC_ORO_PHP_VERSION}-node${DC_ORO_NODE_VERSION}-composer${DC_ORO_COMPOSER_VERSION}-${DC_ORO_PHP_DIST}"
      
      # Check if Dockerfiles exist
      PHP_DOCKERFILE="${DOCKER_DIR}/php/Dockerfile.${DC_ORO_PHP_VERSION}.${DC_ORO_PHP_DIST}"
      PHP_NODE_DOCKERFILE="${DOCKER_DIR}/php-node-symfony/${DC_ORO_PHP_VERSION}/Dockerfile"
      
      if [[ ! -f "$PHP_DOCKERFILE" ]]; then
        msg_error "PHP Dockerfile not found: $PHP_DOCKERFILE"
        msg_info ""
        msg_info "Available PHP versions:"
        for dockerfile in "${DOCKER_DIR}"/php/Dockerfile.*.${DC_ORO_PHP_DIST}; do
          if [[ -f "$dockerfile" ]]; then
            version=$(basename "$dockerfile" | sed "s/Dockerfile\.\(.*\)\.${DC_ORO_PHP_DIST}/\1/")
            msg_info "  - PHP ${version}"
          fi
        done
        msg_info ""
        msg_info "Set DC_ORO_PHP_VERSION in .env.orodc to use a different version"
        exit 1
      fi
      
      if [[ ! -f "$PHP_NODE_DOCKERFILE" ]]; then
        msg_error "PHP+Node.js Dockerfile not found: $PHP_NODE_DOCKERFILE"
        msg_info ""
        msg_info "Available PHP+Node.js versions:"
        for dockerfile_dir in "${DOCKER_DIR}"/php-node-symfony/*/; do
          if [[ -d "$dockerfile_dir" ]] && [[ -f "${dockerfile_dir}Dockerfile" ]]; then
            version=$(basename "$dockerfile_dir")
            msg_info "  - PHP ${version}"
          fi
        done
        msg_info ""
        msg_info "Set DC_ORO_PHP_VERSION in .env.orodc to use a different version"
        exit 1
      fi
      
      # Stage 1: Build PHP base image
      msg_header "Stage 1/2: PHP ${DC_ORO_PHP_VERSION} base image"
      msg_info ""
      
      # Check if image exists locally
      if ${DOCKER_BIN} images -q "${PHP_BASE_TAG}" 2>/dev/null | grep -q .; then
        msg_ok "Image exists locally: ${PHP_BASE_TAG}"
        IMAGE_SIZE=$(${DOCKER_BIN} images "${PHP_BASE_TAG}" --format "{{.Size}}")
        msg_info "Image size: ${IMAGE_SIZE}"
      else
        msg_info "Image not found locally: ${PHP_BASE_TAG}"
      fi
      
      msg_info ""
      
      # Always ask user what to do
      SHOULD_PULL=false
      SHOULD_FORCE_PULL=false
      SHOULD_BUILD=false
      
      if [[ -t 0 ]]; then
        msg_info "Choose action:"
        msg_info "  1) Pull from registry"
        msg_info "  2) Force Pull (remove local + pull)"
        msg_info "  3) Build locally"
        msg_info "  4) Skip"
        msg_info ""
        read -p "Your choice (1/2/3/4): " -n 1 -r
        echo
        
        case $REPLY in
          1)
            SHOULD_PULL=true
            ;;
          2)
            SHOULD_FORCE_PULL=true
            ;;
          3)
            SHOULD_BUILD=true
            ;;
          4)
            msg_info "Skipping PHP base image"
            ;;
          *)
            msg_warning "Invalid choice, skipping"
            ;;
        esac
      else
        # Non-interactive: build by default
        SHOULD_BUILD=true
      fi
      
      if [[ "$SHOULD_PULL" == "true" ]]; then
        msg_info "Attempting to pull from registry..."
        if ${DOCKER_BIN} pull "${PHP_BASE_TAG}" 2>/dev/null; then
          msg_ok "Successfully pulled from registry: ${PHP_BASE_TAG}"
          IMAGE_SIZE=$(${DOCKER_BIN} images "${PHP_BASE_TAG}" --format "{{.Size}}")
          msg_info "Image size: ${IMAGE_SIZE}"
        else
          msg_error "Failed to pull from registry"
          msg_info ""
          read -p "Build locally instead? (Y/n): " -n 1 -r
          echo
          if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            SHOULD_BUILD=true
          fi
        fi
      fi

      if [[ "$SHOULD_FORCE_PULL" == "true" ]]; then
        msg_info "Force Pull selected: removing local image (if present) and pulling from registry..."
        ${DOCKER_BIN} rmi -f "${PHP_BASE_TAG}" >/dev/null 2>&1 || true
        if ${DOCKER_BIN} pull "${PHP_BASE_TAG}" 2>/dev/null; then
          msg_ok "Successfully force pulled from registry: ${PHP_BASE_TAG}"
          IMAGE_SIZE=$(${DOCKER_BIN} images "${PHP_BASE_TAG}" --format "{{.Size}}")
          msg_info "Image size: ${IMAGE_SIZE}"
        else
          msg_error "Failed to pull from registry"
          msg_info ""
          read -p "Build locally instead? (Y/n): " -n 1 -r
          echo
          if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            SHOULD_BUILD=true
          fi
        fi
      fi
      
      if [[ "$SHOULD_BUILD" == "true" ]]; then
        msg_info "Building locally: ${PHP_BASE_TAG}"
        msg_info "Dockerfile: ${PHP_DOCKERFILE}"
        msg_info "This may take 5-10 minutes..."
        msg_info ""
        
        # Build PHP base image
        BUILD_START=$(date +%s)
        if ${DOCKER_BIN} build ${NO_CACHE_FLAG} \
          -f "${PHP_DOCKERFILE}" \
          -t "${PHP_BASE_TAG}" \
          "${DOCKER_DIR}/php/"; then
          BUILD_END=$(date +%s)
          BUILD_DURATION=$((BUILD_END - BUILD_START))
          msg_ok "PHP base image built successfully in ${BUILD_DURATION}s"
          
          # Verify image exists and get size
          IMAGE_SIZE=$(${DOCKER_BIN} images "${PHP_BASE_TAG}" --format "{{.Size}}")
          msg_info "Image size: ${IMAGE_SIZE}"
        else
          msg_error "PHP base image build failed"
          msg_info ""
          msg_info "Troubleshooting:"
          msg_info "  - Check Docker daemon is running: docker ps"
          msg_info "  - Check internet connectivity for package downloads"
          msg_info "  - Try rebuilding without cache: orodc image build --no-cache"
          msg_info "  - Check Docker logs for more details"
          exit 1
        fi
      fi
      
      msg_info ""
      
      # Stage 2: Build PHP+Node.js final image
      msg_header "Stage 2/2: PHP+Node.js final image"
      msg_info ""
      
      # Check if image exists locally
      if ${DOCKER_BIN} images -q "${PHP_FINAL_TAG}" 2>/dev/null | grep -q .; then
        msg_ok "Image exists locally: ${PHP_FINAL_TAG}"
        IMAGE_SIZE=$(${DOCKER_BIN} images "${PHP_FINAL_TAG}" --format "{{.Size}}")
        msg_info "Image size: ${IMAGE_SIZE}"
      else
        msg_info "Image not found locally: ${PHP_FINAL_TAG}"
      fi
      
      msg_info ""
      
      # Always ask user what to do
      SHOULD_PULL_FINAL=false
      SHOULD_FORCE_PULL_FINAL=false
      SHOULD_BUILD_FINAL=false
      
      if [[ -t 0 ]]; then
        msg_info "Choose action:"
        msg_info "  1) Pull from registry"
        msg_info "  2) Force Pull (remove local + pull)"
        msg_info "  3) Build locally"
        msg_info "  4) Skip"
        msg_info ""
        read -p "Your choice (1/2/3/4): " -n 1 -r
        echo
        
        case $REPLY in
          1)
            SHOULD_PULL_FINAL=true
            ;;
          2)
            SHOULD_FORCE_PULL_FINAL=true
            ;;
          3)
            SHOULD_BUILD_FINAL=true
            ;;
          4)
            msg_info "Skipping PHP+Node.js final image"
            ;;
          *)
            msg_warning "Invalid choice, skipping"
            ;;
        esac
      else
        # Non-interactive: build by default
        SHOULD_BUILD_FINAL=true
      fi
      
      if [[ "$SHOULD_PULL_FINAL" == "true" ]]; then
        msg_info "Attempting to pull from registry..."
        if ${DOCKER_BIN} pull "${PHP_FINAL_TAG}" 2>/dev/null; then
          msg_ok "Successfully pulled from registry: ${PHP_FINAL_TAG}"
          IMAGE_SIZE=$(${DOCKER_BIN} images "${PHP_FINAL_TAG}" --format "{{.Size}}")
          msg_info "Image size: ${IMAGE_SIZE}"
        else
          msg_error "Failed to pull from registry"
          msg_info ""
          read -p "Build locally instead? (Y/n): " -n 1 -r
          echo
          if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            SHOULD_BUILD_FINAL=true
          fi
        fi
      fi

      if [[ "$SHOULD_FORCE_PULL_FINAL" == "true" ]]; then
        msg_info "Force Pull selected: removing local image (if present) and pulling from registry..."
        ${DOCKER_BIN} rmi -f "${PHP_FINAL_TAG}" >/dev/null 2>&1 || true
        if ${DOCKER_BIN} pull "${PHP_FINAL_TAG}" 2>/dev/null; then
          msg_ok "Successfully force pulled from registry: ${PHP_FINAL_TAG}"
          IMAGE_SIZE=$(${DOCKER_BIN} images "${PHP_FINAL_TAG}" --format "{{.Size}}")
          msg_info "Image size: ${IMAGE_SIZE}"
        else
          msg_error "Failed to pull from registry"
          msg_info ""
          read -p "Build locally instead? (Y/n): " -n 1 -r
          echo
          if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            SHOULD_BUILD_FINAL=true
          fi
        fi
      fi
      
      if [[ "$SHOULD_BUILD_FINAL" == "true" ]]; then
        msg_info "Building locally: ${PHP_FINAL_TAG}"
        msg_info "Dockerfile: ${PHP_NODE_DOCKERFILE}"
        msg_info "This may take 5-10 minutes..."
        msg_info ""
        
        # Build PHP+Node.js final image
        BUILD_START=$(date +%s)
        if ${DOCKER_BIN} build ${NO_CACHE_FLAG} \
          --build-arg PHP_VERSION="${DC_ORO_PHP_VERSION}" \
          --build-arg NODE_VERSION="${DC_ORO_NODE_VERSION}" \
          --build-arg COMPOSER_VERSION="${DC_ORO_COMPOSER_VERSION}" \
          --build-arg PHP_IMAGE="${PHP_BASE_TAG}" \
          -f "${DOCKER_DIR}/php-node-symfony/${DC_ORO_PHP_VERSION}/Dockerfile" \
          -t "${PHP_FINAL_TAG}" \
          "${DOCKER_DIR}/php-node-symfony/"; then
          BUILD_END=$(date +%s)
          BUILD_DURATION=$((BUILD_END - BUILD_START))
          msg_ok "PHP+Node.js final image built successfully in ${BUILD_DURATION}s"
          
          # Verify image exists and get size
          IMAGE_SIZE=$(${DOCKER_BIN} images "${PHP_FINAL_TAG}" --format "{{.Size}}")
          msg_info "Image size: ${IMAGE_SIZE}"
        else
          msg_error "PHP+Node.js final image build failed"
          msg_info ""
          msg_info "Troubleshooting:"
          msg_info "  - Check Docker daemon is running: docker ps"
          msg_info "  - Check internet connectivity for package downloads"
          msg_info "  - Try rebuilding without cache: orodc image build --no-cache"
          msg_info "  - Check Docker logs for more details"
          exit 1
        fi
      fi
      
      msg_info ""
      msg_header "Build Complete!"
      msg_ok "Built images:"
      msg_info "  - ${PHP_BASE_TAG}"
      msg_info "  - ${PHP_FINAL_TAG}"
      msg_info ""
      msg_header "Usage"
      msg_info "Images are built with full registry path and ready to use."
      msg_info "They can be used in FROM statements and pushed to registry."
      msg_info ""
      
      exit 0
      ;;
    
    *)
      msg_error "Unknown image command: ${IMAGE_CMD}"
      msg_info ""
      msg_info "Available image commands:"
      msg_info "  orodc image build [--no-cache]  - Build PHP+Node.js images locally"
      msg_info ""
      exit 1
      ;;
  esac
fi

# Check if we need argument parsing
# Parse for docker compose commands OR commands with docker compose flags
has_docker_compose_flags=false
for arg in "$@"; do
  if [[ "$arg" =~ ^--profile(=.*)?$ ]] || [[ "$arg" =~ ^--env-file(=.*)?$ ]] || [[ "$arg" =~ ^--project-name(=.*)?$ ]] || [[ "$arg" =~ ^--file(=.*)?$ ]] || [[ "$arg" =~ ^-f$ ]]; then
    has_docker_compose_flags=true
    if [ "$DEBUG" ]; then echo "DEBUG: Found docker compose flag: $arg" >&2; fi
    break
  fi
done

if [ "$DEBUG" ]; then echo "DEBUG: has_docker_compose_flags=$has_docker_compose_flags, temp_first_non_flag_arg=$temp_first_non_flag_arg" >&2; fi

if [[ $# -gt 0 ]] && (is_compose_command "$temp_first_non_flag_arg" || [[ "$temp_first_non_flag_arg" == "purge" ]] || [[ "$temp_first_non_flag_arg" == "php" ]] || [[ "$has_docker_compose_flags" == "true" ]]); then
  NEEDS_ARG_PARSING=true
  if [ "$DEBUG" ]; then echo "DEBUG: NEEDS_ARG_PARSING=true" >&2; fi
else
  NEEDS_ARG_PARSING=false
  if [ "$DEBUG" ]; then echo "DEBUG: NEEDS_ARG_PARSING=false" >&2; fi
  # Save original arguments for non-compose commands
  non_compose_args=("$@")
fi




# Only parse arguments for docker compose commands or commands with docker compose flags
if [[ "$NEEDS_ARG_PARSING" == "true" ]]; then
  i=0
  saw_first_arg=false
  
  # Special case: if first argument is 'php' OR no non-flag arguments, treat all flags as right flags
  if [ "$DEBUG" ]; then echo "DEBUG: Checking special case: args_input[0]='${args_input[0]:-}', temp_first_non_flag_arg='$temp_first_non_flag_arg'" >&2; fi
  if [[ ${#args_input[@]} -gt 0 && "${args_input[0]}" == "php" ]] || [[ "$temp_first_non_flag_arg" == "php" ]]; then
    if [ "$DEBUG" ]; then echo "DEBUG: Setting saw_first_arg=true for PHP command" >&2; fi
    saw_first_arg=true
  fi

  while [[ $i -lt ${#args_input[@]} ]]; do
    arg="${args_input[$i]}"
    next="${args_input[$((i + 1))]:-}"

    if [[ "$arg" == --*=* ]]; then
      [[ -n "${DEBUG:-}" ]] && echo "DEBUG: Found --*=* flag: $arg, saw_first_arg=$saw_first_arg" >&2
      if [[ "$saw_first_arg" == false ]]; then
        left_options+=("$arg")
      else
        right_options+=("$arg")
      fi
      i=$((i + 1))

    elif [[ "$arg" == --* && "$next" != -* && -n "$next" ]]; then
      if [[ "$saw_first_arg" == false ]]; then
        left_options+=("$arg" "$next")
      else
        right_options+=("$arg" "$next")
      fi
      i=$((i + 2))

    elif [[ "$arg" == -* ]]; then
      if [[ "$saw_first_arg" == false ]]; then
        left_flags+=("$arg")
      else
        right_flags+=("$arg")
      fi
      i=$((i + 1))

    else
      args+=("$arg")
      saw_first_arg=true
      i=$((i + 1))
    fi
  done
  # Get first non-flag argument for command detection (after args is properly set)
  first_non_flag_arg=$(get_first_non_flag_arg "${args[@]}")
else
  # For non-compose commands, set args to original arguments without parsing
  args=("${non_compose_args[@]}")
  # Get first non-flag argument for command detection (after args is properly set)
  first_non_flag_arg=$(get_first_non_flag_arg "${args[@]}")
fi

# Ensure first_non_flag_arg is always set regardless of parsing mode
if [[ -z "${first_non_flag_arg:-}" ]]; then
  first_non_flag_arg=$(get_first_non_flag_arg "${args[@]}")
fi

if [[ -n "${DEBUG:-}" ]]; then
  echo "DEBUG: first_non_flag_arg='$first_non_flag_arg', args=(${args[*]})" >&2
fi


# Resolve critical dependencies with helpful error messages
BREW_BIN=$(resolve_bin "brew")
DOCKER_BIN=$(resolve_bin "docker")

# Check docker compose specifically (it's a subcommand, not a separate binary)
if ! "$DOCKER_BIN" compose version >/dev/null 2>&1; then
  msg_error "Docker Compose not found or outdated"
  echo "   Docker Compose V2 is required (docker compose, not docker-compose)"
  echo "   Update Docker: https://docs.docker.com/compose/install/"
  echo
  msg_error "OroDC cannot continue without Docker Compose"
  exit 1
fi

# Set up Homebrew environment if needed
if [[ "$BREW_BIN" != *"/usr/local/bin/brew"* ]] && [[ "$BREW_BIN" != *"/opt/homebrew/bin/brew"* ]]; then
  # For non-standard locations, ensure environment is set up
  eval "$("$BREW_BIN" shellenv)" 2>/dev/null || true
fi

DIR=$("$BREW_BIN" --prefix docker-compose-oroplatform)/share/docker-compose-oroplatform

# Try to get rsync from Homebrew, fallback to system rsync
RSYNC_BIN="$("$BREW_BIN" --prefix rsync)/bin/rsync"
if [[ ! -x "$RSYNC_BIN" ]]; then
  RSYNC_BIN=$(resolve_bin "rsync")
fi

# Set up Docker Compose command
DOCKER_COMPOSE_BIN="$DOCKER_BIN compose"
# DOCKER_COMPOSE_BIN_CMD is the main command that gets built up with compose files  
# This variable is reused throughout the script and in the test merging logic
DOCKER_COMPOSE_BIN_CMD="$DOCKER_COMPOSE_BIN"
DOCKER_COMPOSE_VERSION=$($DOCKER_COMPOSE_BIN_CMD version | grep -E '[0-9]+\.[0-9]+\.[0-9]+' -o | head -1 |awk -F. '{ print $1 }')
# Sync compose files with --delete to remove outdated cached configs
# Exclude SSH keys, cached profiles, and generated compose.yml
${RSYNC_BIN} -r --delete \
  --exclude='ssh_id_*' \
  --exclude='.cached_*' \
  --exclude='compose.yml' \
  --exclude='.xdebug_env' \
  "${DIR}/compose/" "${DC_ORO_CONFIG_DIR}/"

# Setup certificates synchronization
setup_project_certificates() {
  local project_crt_dir="${PWD}/.crt"
  local build_crt_dir="${DC_ORO_CONFIG_DIR}/docker/project-php-node-symfony/.crt"
  
  # Remove old certificates directory
  rm -rf "${build_crt_dir}"
  
  # Check if project has certificates
  if [[ -d "${project_crt_dir}" ]]; then
    local cert_count=$(find "${project_crt_dir}" -type f \( -name "*.crt" -o -name "*.pem" \) 2>/dev/null | wc -l)
    
    if [[ "${cert_count}" -gt 0 ]]; then
      msg_info "Found ${cert_count} certificate(s) in ${project_crt_dir}"
      echo "   Preparing project build context with custom certificates..."
      
      # Create .crt directory in build context
      mkdir -p "${build_crt_dir}"
      
      # Copy certificates to build context
      find "${project_crt_dir}" -type f \( -name "*.crt" -o -name "*.pem" \) -exec cp {} "${build_crt_dir}/" \;
      
      msg_ok "Certificates prepared for Docker build"
    else
      msg_info ".crt directory exists but contains no certificate files"
    fi
  else
    # Skip certificate message - building standard image silently
    true
  fi
}

# Call certificates setup after compose files are synced
setup_project_certificates
# Build the compose command by adding compose files in the correct order
# This logic is reused in test merging - DO NOT duplicate this logic elsewhere
if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose.yml" ]]; then
  DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose.yml"
fi

# Profile caching functions
save_profiles() {
  local profiles=()
  local cli_profiles=()
  local i=0
  
  # Extract --profile arguments from left_flags and left_options
  while [[ $i -lt ${#left_flags[@]} ]]; do
    if [[ "${left_flags[$i]}" == --profile=* ]]; then
      local profile_value="${left_flags[$i]#--profile=}"
      if [[ "$profile_value" == "database-cli" ]] || [[ "$profile_value" == "php-cli" ]]; then
        cli_profiles+=("${left_flags[$i]}")
      else
        profiles+=("${left_flags[$i]}")
      fi
    fi
    i=$((i + 1))
  done
  
  i=0
  while [[ $i -lt ${#left_options[@]} ]]; do
    if [[ "${left_options[$i]}" == "--profile" ]]; then
      local profile_value="${left_options[$((i + 1))]}"
      if [[ "$profile_value" == "database-cli" ]] || [[ "$profile_value" == "php-cli" ]]; then
        cli_profiles+=("--profile" "$profile_value")
      else
        profiles+=("--profile" "$profile_value")
      fi
      i=$((i + 2))
    else
      i=$((i + 1))
    fi
  done
  
  # Save regular profiles to cache file
  if [[ ${#profiles[@]} -gt 0 ]]; then
    printf '%s\n' "${profiles[@]}" > "${DC_ORO_CONFIG_DIR}/.cached_profiles"
  else
    # Remove cache file if no profiles
    [[ -f "${DC_ORO_CONFIG_DIR}/.cached_profiles" ]] && rm -f "${DC_ORO_CONFIG_DIR}/.cached_profiles" || true
  fi
  
  # Save CLI profiles to separate cache file
  if [[ ${#cli_profiles[@]} -gt 0 ]]; then
    printf '%s\n' "${cli_profiles[@]}" > "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles"
  else
    # Remove CLI cache file if no CLI profiles
    [[ -f "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles" ]] && rm -f "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles" || true
  fi
  return 0
}

load_cached_profiles() {
  local cached_profiles=()
  local include_cli_profiles=false
  
  # Check if we need CLI profiles based on the command
  if [[ ${#args[@]} -gt 0 ]]; then
    # Use the actual first non-flag argument for command detection
    local cmd_to_check="$first_non_flag_arg"
    
    # Commands that always need CLI profiles (for proper cleanup)
    if [[ "$cmd_to_check" =~ ^(down|purge)$ ]]; then
      include_cli_profiles=true
    # Commands that need database-cli profile
    elif [[ "$cmd_to_check" =~ ^(mysql|psql|database-cli)$ ]] || \
       echo "$cmd_to_check" | grep -i 'import.*db\|export.*db\|dump.*db' > /dev/null; then
      include_cli_profiles=true
    # Commands that need php-cli profile (already handled by auto-redirect, but for completeness)
    elif [[ "$cmd_to_check" =~ ^(cli|php|composer|bin/)$ ]] || \
       [[ "$cmd_to_check" == *.php ]] || \
       [[ "$cmd_to_check" == -* ]]; then
      include_cli_profiles=true
    fi
  fi
  
  # Load regular profiles
  if [[ -f "${DC_ORO_CONFIG_DIR}/.cached_profiles" ]]; then
    while IFS= read -r line; do
      cached_profiles+=("$line")
    done < "${DC_ORO_CONFIG_DIR}/.cached_profiles"
    
    if [[ ${#cached_profiles[@]} -gt 0 ]]; then
      # Add cached profiles to left_options (they will be applied to DOCKER_COMPOSE_BIN_CMD)
      left_options=("${cached_profiles[@]}" "${left_options[@]}")
    fi
  fi
  
  # Load CLI profiles only when needed
  if [[ "$include_cli_profiles" == "true" ]] && [[ -f "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles" ]]; then
    local cached_cli_profiles=()
    while IFS= read -r line; do
      cached_cli_profiles+=("$line")
    done < "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles"
    
    if [[ ${#cached_cli_profiles[@]} -gt 0 ]]; then
      # Add CLI profiles to left_options
      left_options=("${cached_cli_profiles[@]}" "${left_options[@]}")
    fi
  fi
}

load_env_safe() {
  local env_file="$1"

  # if the file exists
  if [[ -f "$env_file" ]]; then
    # Read the file line by line
    while IFS= read -r line || [[ -n "$line" ]]; do
      # Trim leading/trailing whitespace (safe)
      line="${line#"${line%%[![:space:]]*}"}"
      line="${line%"${line##*[![:space:]]}"}"

      # Skip empty lines and comments
      [[ -z "$line" || "$line" == \#* ]] && continue

      # Skip lines without =
      [[ "$line" != *=* ]] && continue

      local key="${line%%=*}"
      local value="${line#*=}"

      # Trim key and value safely
      key="${key#"${key%%[![:space:]]*}"}"
      key="${key%"${key##*[![:space:]]}"}"
      value="${value#"${value%%[![:space:]]*}"}"
      value="${value%"${value##*[![:space:]]}"}"

      # Strip existing quotes from value
      value="${value%\"}"
      value="${value#\"}"
      value="${value%\'}"
      value="${value#\'}"

      # Export the variable safely
      export "$key=$value"
    done < "$env_file"
  fi
}

parse_dsn_uri() {
  local uri="$1"
  local name="$2"
  local prefix="$3"

  [[ -n "$uri" && -n "$name" ]] || return 0

  local host_alias
  host_alias=$(echo "$name" | tr '[:upper:]' '[:lower:]')

  local var_prefix=""
  if [[ -n "$prefix" ]]; then
    var_prefix="$(echo "$prefix" | tr '[:lower:]' '[:upper:]')_"
  fi
  var_prefix+=$(echo "$name" | tr '[:lower:]' '[:upper:]')_

  local schema rest
  if [[ "$uri" == *"://"* ]]; then
    schema="${uri%%://*}"
    rest="${uri#*://}"
  elif [[ "$uri" == *: ]]; then
    schema="${uri%:}"
    rest=""
  else
    schema="$uri"
    rest=""
  fi

  local query=""
  if [[ "$rest" == *\?* ]]; then
    query="${rest#*\?}"
    rest="${rest%%\?*}"
  fi

  local user="" password="" host="" port="" dbname=""

  # Special case: SQLite
  if [[ "$schema" == "sqlite" ]]; then
    if [[ "$uri" == "sqlite::memory:" ]]; then
      dbname=":memory:"
    else
      local sqlite_path="${uri#sqlite://}"
      dbname="${sqlite_path%%\?*}"
    fi

    eval "export ${var_prefix}SCHEMA=\"\$schema\""
    eval "export ${var_prefix}DBNAME=\"\$dbname\""
    eval "export ${var_prefix}QUERY=\"\$query\""
    eval "export ${var_prefix}URI=\"\$uri\""
    return
  fi

  # If rest includes @, extract user/password
  if [[ "$rest" == *@* ]]; then
    local userinfo="${rest%%@*}"
    rest="${rest#*@}"
    user="${userinfo%%:*}"
    password="${userinfo#*:}"
    [[ "$user" == "$password" ]] && password="app"
  fi

  # Extract host, port, dbname
  if [[ "$rest" == *:* ]]; then
    host="${rest%%:*}"
    port="${rest#*:}"
    if [[ "$port" == */* ]]; then
      dbname="${port#*/}"
      port="${port%%/*}"
    fi
  elif [[ "$rest" == */* ]]; then
    host="${rest%%/*}"
    dbname="${rest#*/}"
  elif [[ -n "$rest" ]]; then
    host="$rest"
  fi

  #[[ "$host" == "localhost" || "$host" == "127.0.0.1" ]] && host="$host_alias"
  # always use container host for services
  host="$host_alias"

  # Reconstruct URI only if it's not a simple scheme:
  local clean_uri=""
  if [[ "$schema" == "sqlite" && "$dbname" == ":memory:" ]]; then
    clean_uri="sqlite::memory:"
  elif [[ "$schema" == "sqlite" ]]; then
    clean_uri="sqlite://$dbname"
  elif [[ "$schema" == "dbal" && -z "$rest" ]]; then
    clean_uri="${schema}:"
  else
    clean_uri="${schema}://"
    [[ -n "$user" ]] && clean_uri+="${user}"
    [[ -n "$password" ]] && clean_uri+=":${password}"
    [[ -n "$user" || -n "$password" ]] && clean_uri+="@"
    clean_uri+="${host}"
    [[ -n "$port" ]] && clean_uri+=":${port}"
    [[ -n "$dbname" ]] && clean_uri+="/${dbname}"
    [[ -n "$query" ]] && clean_uri+="?${query}"
  fi

  # Export everything
  eval "export ${var_prefix}SCHEMA=\"\$schema\""
  eval "export ${var_prefix}USER=\"\$user\""
  eval "export ${var_prefix}PASSWORD=\"\$password\""
  eval "export ${var_prefix}HOST=\"\$host\""
  eval "export ${var_prefix}PORT=\"\$port\""
  eval "export ${var_prefix}DBNAME=\"\$dbname\""
  eval "export ${var_prefix}QUERY=\"\$query\""
  eval "export ${var_prefix}URI=\"\$clean_uri\""
}

find-up () {
  path=${2-$PWD}
  while [[ "$path" != "" && ! -e "$path/$1" ]]; do
    path=${path%/*}
  done
  echo "$path"
}

# Only set DC_ORO_APPDIR if not already set (e.g., from menu switch)
if [[ -z "${DC_ORO_APPDIR:-}" ]]; then
  export DC_ORO_APPDIR=$(find-up composer.json)
fi

if [[ -z "${DC_ORO_APPDIR:-}" ]]; then
  if [ -z "$(ls -A "$PWD")" ]; then
    export DC_ORO_APPDIR="$PWD"
  else
    echo -e "\033[38;5;208m==> Application root folder not found, and current directory is not empty, terminating...\033[0m"
    exit 1
  fi
fi

if [[ ! -d "$DC_ORO_APPDIR" ]]; then
  mkdir -p "$DC_ORO_APPDIR"
fi

if [[ -z $DC_ORO_COMPOSER_AUTH ]] && [[ -z $COMPOSER_AUTH ]]; then
  cd "${DC_ORO_CONFIG_DIR}"
  if which php > /dev/null 2>&1 && which composer > /dev/null 2>&1; then
    COMPOSER_HOME=$(php -d display_startup_errors=0 $(which composer) config --working-dir=/tmp --no-interaction --global home 2> /dev/null) || {
      msg_info "Can't find Composer home. Try setting COMPOSER_AUTH manually."
    }
  fi

  if [[ -n ${COMPOSER_HOME} ]] && [[ -f "${COMPOSER_HOME}/auth.json" ]]; then
    DC_ORO_COMPOSER_AUTH=$(cat "${COMPOSER_HOME}/auth.json")
  fi
fi

cd "$DC_ORO_APPDIR"

load_env_safe "$DC_ORO_APPDIR/.env"
load_env_safe "$DC_ORO_APPDIR/.env-app"
load_env_safe "$DC_ORO_APPDIR/.env-app.local"
load_env_safe "$DC_ORO_APPDIR/.env.orodc"

# Build complete Traefik routing rule
build_traefik_rule() {
  # Start with main host
  local traefik_rule="Host(\`${DC_ORO_NAME:-unnamed}.docker.local\`)"
  
  # Process DC_ORO_EXTRA_HOSTS - convert comma-separated hosts to Traefik rule format
  if [[ -n "${DC_ORO_EXTRA_HOSTS:-}" ]]; then
    # Split by comma and create Host() rules
    IFS=',' read -ra HOSTS <<< "$DC_ORO_EXTRA_HOSTS"
    for host in "${HOSTS[@]}"; do
      # Trim whitespace
      host=$(echo "$host" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
      if [[ -n "$host" ]]; then
        # Auto-append .docker.local if host is a single word (no dots)
        if [[ "$host" != *.* ]]; then
          host="$host.docker.local"
        fi
        traefik_rule="$traefik_rule || Host(\`$host\`)"
      fi
    done
  fi
  
  export DC_ORO_TRAEFIK_RULE="$traefik_rule"
}

# Build the complete Traefik rule
build_traefik_rule

parse_dsn_uri "$ORO_DB_URL" "database" "DC_ORO"
export DC_ORO_DATABASE_USER=${DC_ORO_DATABASE_USER:-app}
export DC_ORO_DATABASE_PASSWORD=${DC_ORO_DATABASE_PASSWORD:-app}

parse_dsn_uri "$ORO_SEARCH_URL" "search" "DC_ORO"
parse_dsn_uri "$ORO_MQ_DSN" "mq" "DC_ORO"
parse_dsn_uri "$ORO_REDIS_URL" "redis" "DC_ORO"

export DC_ORO_PORT_PREFIX=${DC_ORO_PORT_PREFIX:-"301"}

# Use batch port resolution for better performance
BATCH_PORTS=$(orodc-find_free_port --batch ${DC_ORO_NAME} $DC_ORO_CONFIG_DIR \
  nginx "${DC_ORO_PORT_PREFIX}80" \
  xhgui "${DC_ORO_PORT_PREFIX}81" \
  database "${DC_ORO_PORT_PREFIX}06" \
  database "${DC_ORO_PORT_PREFIX}32" \
  search "${DC_ORO_PORT_PREFIX}92" \
  mq "${DC_ORO_PORT_PREFIX}72" \
  redis "${DC_ORO_PORT_PREFIX}79" \
  mail "${DC_ORO_PORT_PREFIX}25" \
  ssh "${DC_ORO_PORT_PREFIX}22")

# Parse batch results and export individual port variables
while IFS=':' read -r service port; do
  case "$service" in
    nginx)
      export DC_ORO_PORT_NGINX="$port"
      ;;
    xhgui)
      export DC_ORO_PORT_XHGUI="$port"
      ;;
    database)
      if [[ -z "$DC_ORO_PORT_MYSQL" ]]; then
        export DC_ORO_PORT_MYSQL="$port"
      else
        export DC_ORO_PORT_PGSQL="$port"
      fi
      ;;
    search)
      export DC_ORO_PORT_SEARCH="$port"
      ;;
    mq)
      export DC_ORO_PORT_MQ="$port"
      ;;
    redis)
      export DC_ORO_PORT_REDIS="$port"
      ;;
    mail)
      export DC_ORO_PORT_MAIL_WEBGUI="$port"
      ;;
    ssh)
      export DC_ORO_PORT_SSH="$port"
      ;;
  esac
done <<< "$BATCH_PORTS"

export COMPOSER_AUTH=$(echo ${DC_ORO_COMPOSER_AUTH:-${COMPOSER_AUTH}} | jq -c .)
export DC_ORO_COMPOSER_AUTH=${COMPOSER_AUTH}

if ${DOCKER_BIN} system info --format '{{.SecurityOptions}}' 2>/dev/null | grep "name=rootless" > /dev/null 2>&1; then
  # Use root user in the rootless mode
  export DC_ORO_USER_NAME="root"
  export DC_ORO_USER_GROUP="root"
  export DC_ORO_USER_UID=0
  export DC_ORO_USER_GID=0
else
  export DC_ORO_USER_NAME="developer"
  export DC_ORO_USER_GROUP="developer"
  export DC_ORO_USER_UID=$UID
  export DC_ORO_USER_GID=$GID
fi

export DC_ORO_PHP_USER_NAME=${DC_ORO_USER_NAME}
export DC_ORO_PHP_USER_GROUP=${DC_ORO_USER_GROUP}
export DC_ORO_PHP_USER_UID=${DC_ORO_USER_UID}
export DC_ORO_PHP_USER_GID=${DC_ORO_USER_GID}

# Export mailer configuration with defaults (tls = STARTTLS)
export ORO_MAILER_DRIVER=${ORO_MAILER_DRIVER:-smtp}
export ORO_MAILER_HOST=${ORO_MAILER_HOST:-mail}
export ORO_MAILER_PORT=${ORO_MAILER_PORT:-1025}
export ORO_MAILER_ENCRYPTION=${ORO_MAILER_ENCRYPTION:-tls}
export ORO_MAILER_USER=${ORO_MAILER_USER:-}
export ORO_MAILER_PASSWORD=${ORO_MAILER_PASSWORD:-}

NETWORK_NAME="dc_shared_net"
# Check if the Docker network already exists
if ! docker network ls --format '{{.Name}}' | grep -qw "$NETWORK_NAME"; then
  msg_info "Creating Docker network: $NETWORK_NAME"
  docker network create "$NETWORK_NAME"
else
  # Docker network already exists - skip message
  true
fi

if [[ -z $DC_ORO_MODE ]] && [[ "$OSTYPE" == "darwin"* ]]; then
  export DC_ORO_MODE="mutagen"
elif [[ -z $DC_ORO_MODE ]]; then
  export DC_ORO_MODE="default"
fi

if [[ -z ${ORO_SSH_PUBLIC_KEY} ]]; then
  if [[ ! -e "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519" ]]; then
    ssh-keygen -t ed25519 -f "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519" -N "" -q
    chmod 0600 "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519"
  fi
  
  export ORO_SSH_PUBLIC_KEY=$(cat "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519.pub")
fi

if [[ "${DC_ORO_MODE}" == "default" ]] && [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-default.yml" ]]; then
  DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-default.yml"
fi

if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]];then
  export DC_ORO_DATABASE_PORT=${DC_ORO_DATABASE_PORT:-5432}
  DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-pgsql.yml"
elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
  export DC_ORO_DATABASE_PORT=${DC_ORO_DATABASE_PORT:-3306}
  DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-mysql.yml"
fi
if ${DOCKER_COMPOSE_BIN_CMD} ps --services 2>/dev/null | grep database > /dev/null; then
  SERVICE_DATABASE_ID=$(${DOCKER_COMPOSE_BIN_CMD} ps -q database)
  if [[ "" != $SERVICE_DATABASE_ID ]] && ${DOCKER_BIN} inspect -f '{{ .Config.Image }}' "$SERVICE_DATABASE_ID" | grep -q 'busybox'; then
    ${DOCKER_COMPOSE_BIN_CMD} stop database
    ${DOCKER_COMPOSE_BIN_CMD} rm -f database
  fi
fi

if [[ -f "$DC_ORO_APPDIR/.docker-compose.user.yml" ]]; then
  msg_info "Additional ${DOCKER_BIN} compose config will be used: $DC_ORO_APPDIR/.docker-compose.user.yml"
  DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f $DC_ORO_APPDIR/.docker-compose.user.yml"
fi

# Auto-detect PHP version from composer.json
detect_php_version_from_composer() {
  if [[ -f "$DC_ORO_APPDIR/composer.json" ]]; then
    # Try direct PHP requirement first
    local php_constraint=$(jq -r '.require.php // empty' "$DC_ORO_APPDIR/composer.json" 2>/dev/null)
    if [[ -n "$php_constraint" ]]; then
      # Extract version from constraint (e.g., "^8.1" -> "8.1", ">=8.2" -> "8.2")
      local php_version=$(echo "$php_constraint" | sed -E 's/[^0-9.]*([0-9]+\.[0-9]+).*/\1/')
      if [[ "$php_version" =~ ^[0-9]+\.[0-9]+$ ]]; then
        echo "$php_version"
        return 0
      fi
    fi
    
    # Fallback: detect from Oro Platform version
    local oro_platform=$(jq -r '.require["oro/platform"] // empty' "$DC_ORO_APPDIR/composer.json" 2>/dev/null)
    if [[ -n "$oro_platform" ]]; then
      # Extract full Oro version (e.g., "6.0.8", "^6.1.0" -> "6.1.0")
      local oro_version=$(echo "$oro_platform" | sed -E 's/[^0-9.]*([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
      # If no patch version found, try major.minor
      if [[ ! "$oro_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        oro_version=$(echo "$oro_platform" | sed -E 's/[^0-9.]*([0-9]+\.[0-9]+).*/\1/')
      fi
      
      # Convert to comparable format and determine PHP version
      local major=$(echo "$oro_version" | cut -d. -f1)
      local minor=$(echo "$oro_version" | cut -d. -f2)
      local patch=$(echo "$oro_version" | cut -d. -f3 2>/dev/null || echo "0")
      
      # Version comparison logic
      if [[ $major -eq 6 && $minor -eq 0 ]]; then
        echo "8.3" && return 0  # Oro 6.0.x uses PHP 8.3
      elif [[ $major -eq 6 && $minor -ge 1 ]] || [[ $major -gt 6 ]]; then
        echo "8.4" && return 0  # Oro 6.1+ uses PHP 8.4
      elif [[ $major -eq 5 && $minor -eq 1 ]]; then
        echo "8.1" && return 0
      elif [[ $major -eq 5 && $minor -eq 0 ]]; then
        echo "8.1" && return 0
      elif [[ $major -eq 4 && $minor -eq 2 ]]; then
        echo "8.1" && return 0
      elif [[ $major -eq 4 && $minor -eq 1 ]]; then
        echo "8.1" && return 0
      elif [[ $major -eq 4 && $minor -eq 0 ]]; then
        echo "7.4" && return 0
      fi
    fi
  fi
  return 1
}


# Get compatible Node.js version for PHP version
get_compatible_node_version() {
  local php_version="$1"
  # Extract major.minor version only (e.g., "7.3.33" -> "7.3")
  local php_mm=$(echo "$php_version" | sed -E 's/^([0-9]+\.[0-9]+).*/\1/')
  
  case "$php_mm" in
    8.5*) echo "24" ;;
    8.4*) echo "22" ;;
    8.3*) echo "20" ;;
    8.2*) echo "20" ;;
    8.1*) echo "20" ;;
    7.4*) echo "16" ;;
    7.3*) echo "16" ;;
    *) echo "24" ;;  # Default to latest Node 24 for unknown PHP versions
  esac
}

# Auto-detect PHP version with fallback chain
if [[ -z $DC_ORO_PHP_VERSION ]]; then
  # Priority 1: .php-version file
  if [[ -f "$DC_ORO_APPDIR/.php-version" ]]; then
    export DC_ORO_PHP_VERSION=$(cat $DC_ORO_APPDIR/.php-version | head -n1)
    msg_info "Found .php-version with following version: $DC_ORO_PHP_VERSION"
  # Priority 2: .phprc file
  elif [[ -f "$DC_ORO_APPDIR/.phprc" ]]; then
    export DC_ORO_PHP_VERSION=$(cat $DC_ORO_APPDIR/.phprc | head -n1)
    msg_info "Found .phprc with following version: $DC_ORO_PHP_VERSION"
  # Priority 3: composer.json
  elif DC_ORO_PHP_VERSION=$(detect_php_version_from_composer); then
    export DC_ORO_PHP_VERSION
    msg_info "Detected PHP version from composer.json: $DC_ORO_PHP_VERSION"
  # Priority 4: Default to latest available version (from GitHub Actions matrix)
  else
    export DC_ORO_PHP_VERSION="8.5"
    msg_info "Using default PHP version: $DC_ORO_PHP_VERSION (latest available)"
  fi
fi

# Auto-detect Node.js version with fallback chain
if [[ -z $DC_ORO_NODE_VERSION ]]; then
  # Priority 1: .nvmrc file
  if [[ -f "$DC_ORO_APPDIR/.nvmrc" ]]; then
    export DC_ORO_NODE_VERSION=$(cat $DC_ORO_APPDIR/.nvmrc | head -n1)
    msg_info "Found .nvmrc with following version: $DC_ORO_NODE_VERSION"
  # Priority 2: .node-version file (alternative to .nvmrc)
  elif [[ -f "$DC_ORO_APPDIR/.node-version" ]]; then
    export DC_ORO_NODE_VERSION=$(cat $DC_ORO_APPDIR/.node-version | head -n1)
    msg_info "Found .node-version with following version: $DC_ORO_NODE_VERSION"
  # Priority 3: Compatibility matrix based on detected PHP version
  elif [[ -n "$DC_ORO_PHP_VERSION" ]]; then
    export DC_ORO_NODE_VERSION=$(get_compatible_node_version "$DC_ORO_PHP_VERSION")
    msg_info "Using compatible Node.js version for PHP $DC_ORO_PHP_VERSION: $DC_ORO_NODE_VERSION"
  # Priority 4: Default to latest available version (from GitHub Actions matrix)
  else
    export DC_ORO_NODE_VERSION="24"
    msg_info "Using default Node.js version: $DC_ORO_NODE_VERSION (latest available)"
  fi
fi

if [[ "${DC_ORO_MODE}" == "mutagen" ]] || [[ "${DC_ORO_MODE}" == "ssh" ]]; then
  if [[ ${args[0]} != "down" ]] && [[ ${args[0]} != "purge" ]]; then
    ${DOCKER_BIN} volume ls | awk '{ print $2 }' | tail +2 | grep '^'${DC_ORO_NAME}'_appcode$' > /dev/null 2>&1 || {
      ${DOCKER_BIN} volume create "${DC_ORO_NAME}_appcode"  > /dev/null
      msg_info "Copying source code to the '${DC_ORO_NAME}_appcode' docker volume"
      bash -c "${DOCKER_COMPOSE_BIN_CMD} up -d ssh"
      SSH_HOST=${DC_ORO_SSH_BIND_HOST:-127.0.0.1}
      SSH_PORT=$(${DOCKER_BIN} inspect $(${DOCKER_COMPOSE_BIN_CMD} ps | grep ssh | awk '{ print $1 }') | jq -r '.[0].NetworkSettings.Ports["22/tcp"][0].HostPort')
      if [[ 0 -eq $(ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o 'ForwardAgent no' -o IdentitiesOnly=yes -i "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519" -p ${SSH_PORT} ${ORO_DC_SSH_ARGS} ${DC_ORO_USER_NAME}@${SSH_HOST} sh -c 'ls "'${DC_ORO_APPDIR}'/"' | wc -l) ]]; then
        until ${RSYNC_BIN} --exclude var/cache --exclude vendor --exclude node_modules --links -e "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o 'ForwardAgent no' -o IdentitiesOnly=yes -i ${DC_ORO_CONFIG_DIR}/ssh_id_ed25519 -p ${SSH_PORT} ${ORO_DC_SSH_ARGS}" --timeout=3 --info=progress2 -r "${DC_ORO_APPDIR}/" ${DC_ORO_USER_NAME}@${SSH_HOST}:"${DC_ORO_APPDIR}/" 2> /dev/null; do
          echo -n ".";
          sleep 3
        done
        echo "";
      fi
    }
  fi
fi

if [[ "${DC_ORO_MODE}" == "mutagen" ]]; then
  MUTAGEN_SESSION_NAME=$(echo ${DC_ORO_NAME}-appcode | awk '{print tolower($0)}' | sed 's/[^0-9a-z]/-/g')
  WAIT_SYNC="1"

  if [[ "$first_non_flag_arg" == "down" ]] || [[ "$first_non_flag_arg" == "purge" ]]; then
    if mutagen sync list | grep -i "Name: ${MUTAGEN_SESSION_NAME}" > /dev/null 2>&1; then
      mutagen sync terminate "${MUTAGEN_SESSION_NAME}"
    fi
    WAIT_SYNC=""
  elif ! echo "$first_non_flag_arg" | grep -i '^\(build\|pull\|config\)' > /dev/null 2>&1; then
    if [[ "0" -eq $(${DOCKER_COMPOSE_BIN_CMD} ps -q ssh  2> /dev/null | wc -l 2> /dev/null) ]]; then
      bash -c "${DOCKER_COMPOSE_BIN_CMD} up -d ssh"
    fi
    DOCKER_CONTAINER_NAME_MUTAGEN=$(${DOCKER_BIN} inspect -f '{{.Name}}' $(bash -c "${DOCKER_COMPOSE_BIN_CMD} ps -q ssh") | cut -c2-)
    if ! mutagen sync list | grep -i "Name: ${MUTAGEN_SESSION_NAME}" > /dev/null 2>&1; then
      mutagen sync create --sync-mode=two-way-resolved \
      --scan-mode=accelerated \
      --watch-mode-alpha=portable \
      --watch-mode-beta=force-poll \
      --watch-polling-interval-beta=30 \
      --ignore=".git" \
      --ignore=".idea" \
      --ignore=".history" \
      --ignore=".mysql.initdb.d" \
      --ignore=".psql.initdb.d" \
      --ignore="var" \
      --ignore-vcs \
      --symlink-mode=ignore \
      --name=${MUTAGEN_SESSION_NAME} \
      "$DC_ORO_APPDIR" docker://${DC_ORO_USER_NAME}@${DOCKER_CONTAINER_NAME_MUTAGEN}${DC_ORO_APPDIR}
    else
      WAIT_SYNC=""
    fi

    if [[ "${WAIT_SYNC}" == "1" ]]; then
      until mutagen sync list "${MUTAGEN_SESSION_NAME}" | grep 'Status:' | grep 'Watching for changes' > /dev/null 2>&1; do
        if which tput > /dev/null 2>&1; then
          tput cuu 1 && tput el
        fi
        mutagen sync list "${MUTAGEN_SESSION_NAME}" | grep 'Status:' | echo $(awk -F: '{ print $2 }')
        sleep 3
      done
    fi
  fi
fi

if [[ ${DOCKER_COMPOSE_VERSION} -gt 1 ]]; then
  DOCKER_COMPOSE_RUN_CMD="${DOCKER_COMPOSE_BIN_CMD} run -i --rm"
else
  DOCKER_COMPOSE_RUN_CMD="${DOCKER_COMPOSE_BIN_CMD} run --rm"
fi

# Function to build docker compose run command with proper flag placement
build_docker_compose_run_cmd() {
  local service="$1"
  local cmd_args=("${@:2}")
  
  # Check if this is a composer command - use -T flag for non-interactive mode
  local use_tty_flag="-i"
  if [[ "$first_non_flag_arg" == "composer" ]]; then
    use_tty_flag="-T"
  fi
  
  if [[ ${#left_flags[@]} -gt 0 ]] || [[ ${#left_options[@]} -gt 0 ]]; then
    # Place docker compose flags before 'run' command
    if [[ ${DOCKER_COMPOSE_VERSION} -gt 1 ]]; then
      echo "${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run ${use_tty_flag} --rm ${service} ${cmd_args[*]} ${right_flags[*]} ${right_options[*]}"
    else
      echo "${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run --rm ${service} ${cmd_args[*]} ${right_flags[*]} ${right_options[*]}"
    fi
  else
    # Use standard command without parsed flags
    # For composer commands in DOCKER_COMPOSE_VERSION > 1, replace -i with -T in DOCKER_COMPOSE_RUN_CMD
    if [[ "$first_non_flag_arg" == "composer" ]] && [[ ${DOCKER_COMPOSE_VERSION} -gt 1 ]]; then
      local composer_run_cmd="${DOCKER_COMPOSE_RUN_CMD/-i /-T }"
      echo "${composer_run_cmd} ${service} ${cmd_args[*]}"
    else
      echo "${DOCKER_COMPOSE_RUN_CMD} ${service} ${cmd_args[*]}"
    fi
  fi
}

# Function to check if a container is running
is_container_running() {
  local service="$1"
  local container_id
  
  # Get container ID for the service
  container_id=$(${DOCKER_COMPOSE_BIN_CMD} ps -q "$service" 2>/dev/null)
  
  # Check if container exists and is running
  if [[ -n "$container_id" ]] && ${DOCKER_BIN} inspect -f '{{.State.Running}}' "$container_id" 2>/dev/null | grep -q "true"; then
    return 0
  else
    return 1
  fi
}

# Function to execute command in container (use ssh if available, otherwise cli)
execute_in_container() {
  local service="$1"
  local cmd_args=("${@:2}")
  
  # Handle external PHP files for exec vs run scenarios
  local external_files=()
  local updated_cmd_args=()
  
  # Collect external PHP files from command arguments
  for arg in "${cmd_args[@]}"; do
    if [[ $arg == *.php ]]; then
      PHPFILE_PATH=$(echo $arg | grep -oE '.+\.php' | sed s~.\*=~~)
      PHPFILE_DIR=$(dirname "${PHPFILE_PATH}")
      
      # Check if file is outside project directory
      if [[ -z $DC_ORO_APPDIR ]] || [[ $PHPFILE_DIR != '.' && $PHPFILE_DIR != $DC_ORO_APPDIR && $PHPFILE_DIR != $DC_ORO_APPDIR/* ]]; then
        # Check if file exists locally
        if [[ -f "${PHPFILE_PATH}" ]]; then
          external_files+=("${PHPFILE_PATH}")
        fi
      fi
    fi
    updated_cmd_args+=("$arg")
  done
  
  # For CLI commands, prefer SSH container if it's running (much faster)
  if [[ "$service" == "cli" ]] && is_container_running "ssh"; then
    # Handle external files for SSH exec - copy to shared volume
    if [[ ${#external_files[@]} -gt 0 ]]; then
      for file in "${external_files[@]}"; do
        filename=$(basename "$file")
        # Copy external file to shared-private volume via SSH container
        if docker cp "$file" "${DC_ORO_NAME}_ssh_${DC_ORO_PHP_VERSION:-8.5}-${DC_ORO_NODE_VERSION:-24}-${DC_ORO_COMPOSER_VERSION:-2}:/private/$filename" 2>/dev/null; then
          if [ "$DEBUG" ]; then echo "DEBUG: Copied external file $file to /private/$filename" >&2; fi
          # Update command arguments to use shared volume path
          for i in "${!updated_cmd_args[@]}"; do
            if [[ "${updated_cmd_args[$i]}" == "$file" ]]; then
              updated_cmd_args[$i]="/private/$filename"
              break
            fi
          done
        else
          if [ "$DEBUG" ]; then echo "DEBUG: Failed to copy $file to SSH container, falling back to CLI run" >&2; fi
          # Fall back to CLI run with volume mount
          exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} run -i --rm -v "$(dirname "$file"):$(dirname "$file"):ro" "$service" "${cmd_args[@]}" "${right_flags[@]}" "${right_options[@]}"
        fi
      done
    fi
    
    if [ "$DEBUG" ]; then echo "DEBUG: Using SSH container for faster execution instead of CLI" >&2; fi
    exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} exec "ssh" "${updated_cmd_args[@]}" "${right_flags[@]}" "${right_options[@]}"
  elif is_container_running "$service"; then
    # Container is running, use exec for faster execution
    if [ "$DEBUG" ]; then echo "DEBUG: Using docker compose exec for service: $service" >&2; fi
    exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} exec "$service" "${updated_cmd_args[@]}" "${right_flags[@]}" "${right_options[@]}"
  else
    # Container is not running, use docker compose run with volume mounts for external files
    local run_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run -i --rm"
    
    # Add volume mounts for external files
    if [[ ${#external_files[@]} -gt 0 ]]; then
      for file in "${external_files[@]}"; do
        file_dir=$(dirname "${file}")
        run_cmd="$run_cmd -v ${file_dir}:${file_dir}:ro"
        if [ "$DEBUG" ]; then echo "DEBUG: Adding volume mount for external file: -v ${file_dir}:${file_dir}:ro" >&2; fi
      done
    fi
    
    run_cmd="$run_cmd $service"
    
    # Start the service in background first
    ${DOCKER_COMPOSE_BIN_CMD} up -d "$service" >/dev/null 2>&1
    
    # Wait a moment for the service to be ready
    sleep 1
    
    # Verify it's now running, if so use exec, otherwise use run
    if is_container_running "$service"; then
      if [ "$DEBUG" ]; then echo "DEBUG: Service $service started, using exec" >&2; fi
      exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} exec "$service" "${updated_cmd_args[@]}" "${right_flags[@]}" "${right_options[@]}"
    else
      # Fallback to run if start failed
      if [ "$DEBUG" ]; then echo "DEBUG: Failed to start service $service, using run with volume mounts" >&2; fi
      exec bash -c "$run_cmd ${cmd_args[*]} ${right_flags[*]} ${right_options[*]}"
    fi
  fi
}

if ${DOCKER_BIN} system info --format '{{.SecurityOptions}}' 2>/dev/null | grep "name=rootless" > /dev/null; then
  DOCKER_COMPOSE_RUN_CMD="${DOCKER_COMPOSE_RUN_CMD} --user root"
fi

# External PHP files are now handled in execute_in_container() function

# Load cached profiles for all commands except 'up' (which saves new profiles)
if [[ "$first_non_flag_arg" != "up" ]]; then
  load_cached_profiles
fi

if [[ "$first_non_flag_arg" == "up" ]]; then
  # Save profiles for future commands
  save_profiles
fi


if echo "$first_non_flag_arg" | grep -i 'import' | grep -i 'db\|database' > /dev/null 2>&1 || false; then
  if [[ -z ${args[1]} ]]; then
    >&2 echo "Data file was not provided"
    exit 1
  fi
  if [[ -r ${args[1]} ]]; then
    DB_DUMP=$(realpath ${args[1]})
  elif [[ -r "$DC_ORO_APPDIR/${args[1]}" ]]; then
    DB_DUMP=$(realpath "$DC_ORO_APPDIR/${args[1]}")
  fi

  if [[ -z "$DB_DUMP" ]] || [[ ! -r "$DB_DUMP" ]]; then
    >&2 echo "Data file '${args[1]}' does not readable"
    exit 1
  fi

  DB_DUMP_BASENAME=$(echo "${DB_DUMP##*/}")
  if [[ $DC_ORO_DATABASE_SCHEMA == "pdo_pgsql" ]] || [[ $DC_ORO_DATABASE_SCHEMA == "postgres" ]];then
    DB_IMPORT_CMD="sed -E 's/[Oo][Ww][Nn][Ee][Rr]:[[:space:]]*[a-zA-Z0-9_]+/Owner: '\$DC_ORO_DATABASE_USER'/g' | sed -E 's/[Oo][Ww][Nn][Ee][Rr][[:space:]]+[Tt][Oo][[:space:]]+[a-zA-Z0-9_]+/OWNER TO '\$DC_ORO_DATABASE_USER'/g' | sed -E 's/[Ff][Oo][Rr][[:space:]]+[Rr][Oo][Ll][Ee][[:space:]]+[a-zA-Z0-9_]+/FOR ROLE '\$DC_ORO_DATABASE_USER'/g' | sed -E 's/[Tt][Oo][[:space:]]+[a-zA-Z0-9_]+;/TO '\$DC_ORO_DATABASE_USER';/g' | sed -E '/^[[:space:]]*[Rr][Ee][Vv][Oo][Kk][Ee][[:space:]]+[Aa][Ll][Ll]/d' | sed -e '/SET transaction_timeout = 0;/d' | sed -E '/[\\]restrict|[\\]unrestrict/d' | PGPASSWORD=\$DC_ORO_DATABASE_PASSWORD psql --set ON_ERROR_STOP=on -h \$DC_ORO_DATABASE_HOST -p \$DC_ORO_DATABASE_PORT -U \$DC_ORO_DATABASE_USER -d \$DC_ORO_DATABASE_DBNAME -1 >/dev/null"
  elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "pdo_mysql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
    DB_IMPORT_CMD="sed -E 's/[Dd][Ee][Ff][Ii][Nn][Ee][Rr][ ]*=[ ]*[^*]*\*/DEFINER=CURRENT_USER \*/' | MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME"
  fi

  if echo ${DB_DUMP_BASENAME} | grep -i 'sql\.gz$' > /dev/null; then
    DB_IMPORT_CMD="zcat ${DB_DUMP_BASENAME} | sed -E 's/^[[:space:]]*[Cc][Rr][Ee][Aa][Tt][Ee][[:space:]]+[Ff][Uu][Nn][Cc][Tt][Ii][Oo][Nn]/CREATE OR REPLACE FUNCTION/g' | ${DB_IMPORT_CMD}"
  else
    DB_IMPORT_CMD="cat /${DB_DUMP_BASENAME} | sed -E 's/^[[:space:]]*[Cc][Rr][Ee][Aa][Tt][Ee][[:space:]]+[Ff][Uu][Nn][Cc][Tt][Ii][Oo][Nn]/CREATE OR REPLACE FUNCTION/g' | ${DB_IMPORT_CMD}"
  fi

  msg_info "Starting import of the database dump..."
  msg_info "From: $DB_DUMP"
  msg_info "File size: $(du -h "$DB_DUMP" | cut -f1)"
  msg_info "Database: $DC_ORO_DATABASE_HOST:$DC_ORO_DATABASE_PORT/$DC_ORO_DATABASE_DBNAME"
  
  import_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run --quiet -i --rm -v \"${DB_DUMP}:/${DB_DUMP_BASENAME}\" database-cli bash -c \"$DB_IMPORT_CMD\""
  run_with_spinner "Importing database" "$import_cmd" || exit $?
  exit 0
fi

if echo ${args[0]} | grep -i 'set\|update' | grep -i 'url\|uri' > /dev/null; then
  URL=${args[1]:-"https://${DC_ORO_NAME}.docker.local"}
  set -x
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:update oro_website.secure_url ${URL}" || true
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:update oro_ui.application_url ${URL}" || true
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:update oro_website.url ${URL}" || true
  exit 0
fi

if [[ "$first_non_flag_arg" == "cache" ]]; then
  # Use second argument as cache subcommand, default to 'clear'
  cache_cmd="${args[1]:-clear}"
  
  set -x
  if [[ "$NEEDS_ARG_PARSING" == "true" ]]; then
    cache_cmd_exec=$(build_docker_compose_run_cmd "cli" "php" "./bin/console" "cache:${cache_cmd}" "${args[@]:2}")
    exec bash -c "$cache_cmd_exec"
  else
    exec ${DOCKER_COMPOSE_RUN_CMD} cli php ./bin/console cache:${cache_cmd} "${args[@]:2}"
  fi
fi

# Handle cache:subcommand syntax (e.g., cache:clear, cache:warmup)
if echo "$first_non_flag_arg" | grep -i '^cache:' > /dev/null; then
  # Extract cache subcommand (everything after 'cache:')
  cache_cmd="${first_non_flag_arg#cache:}"
  
  set -x
  if [[ "$NEEDS_ARG_PARSING" == "true" ]]; then
    exec ${DOCKER_COMPOSE_RUN_CMD} ${left_flags[@]} ${left_options[@]} cli php ./bin/console cache:${cache_cmd} "${args[@]:1}" "${right_flags[@]}" "${right_options[@]}"
  else
    exec ${DOCKER_COMPOSE_RUN_CMD} cli php ./bin/console cache:${cache_cmd} "${args[@]:1}"
  fi
fi

if echo "$first_non_flag_arg" | grep -i 'update' | grep -i 'platform' > /dev/null; then
  set -x
  if [[ "$NEEDS_ARG_PARSING" == "true" ]]; then
    exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} run -i --rm cli bash -c "rm -rf var/cache/* || true; php bin/console oro:platform:update --force"
  else
    exec ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "rm -rf var/cache/* || true; php bin/console oro:platform:update --force"
  fi
fi

if [[ "$first_non_flag_arg" == "platform" && "${args[1]}" == "update" ]]; then
  set -x
  if [[ "$NEEDS_ARG_PARSING" == "true" ]]; then
    exec ${DOCKER_COMPOSE_RUN_CMD} ${left_flags[@]} ${left_options[@]} cli php ./bin/console oro:platform:update --force "${args[@]:2}" "${right_flags[@]}" "${right_options[@]}"
  else
    exec ${DOCKER_COMPOSE_RUN_CMD} cli php ./bin/console oro:platform:update --force "${args[@]:2}"
  fi
fi

if echo ${args[0]} | grep -i 'composer' | grep -i 'install' > /dev/null; then
  URL=${args[1]:-"https://${DC_ORO_NAME}.docker.local"}
  # Create config/parameters.yml from dist file if not exists (prevents Incenteev interactive prompts)
  ${DOCKER_COMPOSE_BIN_CMD} run --rm cli bash -c "if [[ ! -f ${DC_ORO_APPDIR}/config/parameters.yml ]] && [[ -f ${DC_ORO_APPDIR}/config/parameters.yml.dist ]]; then cp ${DC_ORO_APPDIR}/config/parameters.yml.dist ${DC_ORO_APPDIR}/config/parameters.yml; fi" || true
  set -x
  ${DOCKER_COMPOSE_BIN_CMD} run --rm -T cli bash -c "composer install --no-interaction" || true
  exit 0
fi

if echo "$first_non_flag_arg" | grep -i 'export\|dump' | grep -i 'db\|database' > /dev/null; then
  DB_DUMP=$DC_ORO_APPDIR/database-$(date +'%Y%m%d%H%M%S').sql.gz
  DB_DUMP_BASENAME=$(echo "${DB_DUMP##*/}")
  touch "${DB_DUMP}"
  if [[ $DC_ORO_DATABASE_SCHEMA == "pgsql" ]] || [[ $DC_ORO_DATABASE_SCHEMA == "postgres" ]] || [[ $DC_ORO_DATABASE_SCHEMA == "postgresql" ]]; then
    DB_EXPORT_CMD="PGPASSWORD=\$DC_ORO_DATABASE_PASSWORD pg_dump -Fp --clean --if-exists -h \$DC_ORO_DATABASE_HOST -p \$DC_ORO_DATABASE_PORT -U \$DC_ORO_DATABASE_USER -d \$DC_ORO_DATABASE_DBNAME"
  elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
    DB_EXPORT_CMD="MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysqldump --no-tablespaces --column-statistics=0 --set-gtid-purged=OFF --quick --max-allowed-packet=16M --disable-keys --hex-blob --no-autocommit --insert-ignore --skip-lock-tables --single-transaction -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME | sed -E 's/[Dd][Ee][Ff][Ii][Nn][Ee][Rr][ ]*=[ ]*[^*]*\*/DEFINER=CURRENT_USER \*/'"
  fi

  msg_info "Starting export of the database..."
  msg_info "Database: $DC_ORO_DATABASE_HOST:$DC_ORO_DATABASE_PORT/$DC_ORO_DATABASE_DBNAME"
  msg_info "Export to: $DB_DUMP"
  
  export_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run --quiet --rm -v \"${DB_DUMP}:/${DB_DUMP_BASENAME}\" database-cli bash -c \"$DB_EXPORT_CMD | gzip > /${DB_DUMP_BASENAME}\""
  run_with_spinner "Exporting database" "$export_cmd" || exit $?
  
  msg_info "Saved to: $DB_DUMP"
  exit 0
fi



# Check if command is a special OroDC command (not PHP, not Docker Compose)
is_orodc_special_command() {
  local cmd="$1"
  case "$cmd" in
    psql|mysql|database-cli|ssh|cli|install|purge|help|man|tests|test|bash|config-refresh|refresh-config|init)
      return 0
      ;;
    # Database import/export commands
    importdb|exportdb|databaseimport|databaseexport|dbimport|dbexport)
      return 0
      ;;
    # Platform update commands
    platformupdate|updateplatform)
      return 0
      ;;
    *)
      # Check pattern-based commands
      if echo "$cmd" | grep -qi 'import.*\(db\|database\)'; then return 0; fi
      if echo "$cmd" | grep -qi '\(export\|dump\).*\(db\|database\)'; then return 0; fi
      if echo "$cmd" | grep -qi '\(db\|database\).*\(import\|export\)'; then return 0; fi
      if echo "$cmd" | grep -qi 'update.*platform\|platform.*update'; then return 0; fi
      if echo "$cmd" | grep -qi '^cache:'; then return 0; fi
      if echo "$cmd" | grep -qi '\(set\|update\).*\(url\|uri\)'; then return 0; fi
      if echo "$cmd" | grep -qi 'composer.*install'; then return 0; fi
      return 1
      ;;
  esac
}

# Show interactive menu when no arguments provided and in interactive terminal
# This must be checked BEFORE PHP redirect to prevent menu from being bypassed
if [[ $# -eq 0 ]] && [[ -z "${first_non_flag_arg:-}" ]] && [[ ${#args[@]} -eq 0 ]] && [[ ${#left_flags[@]} -eq 0 ]] && [[ ${#right_flags[@]} -eq 0 ]] && [[ ${#left_options[@]} -eq 0 ]] && [[ ${#right_options[@]} -eq 0 ]] && [[ -t 0 ]] && [[ -z "${ORODC_NO_MENU:-}" ]]; then
  # Check if current directory is an OroPlatform project
  if ! is_oroplatform_project "$PWD"; then
    # Try to switch to last used environment
    last_env=$(get_last_used_environment 2>/dev/null)
    if [[ -n "$last_env" ]] && [[ -d "$last_env" ]] && [[ "$last_env" != "$PWD" ]]; then
      msg_info "No project found in current directory."
      msg_info "Switching to last used environment: $(basename "$last_env")"
      cd "$last_env" || {
        show_interactive_menu
        exit $?
      }
      # Restart script in new directory
      unset DC_ORO_NAME
      unset DC_ORO_CONFIG_DIR
      unset COMPOSE_PROJECT_NAME
      exec "$0"
    fi
  fi
  show_interactive_menu
  exit $?
fi

# Handle PHP flags (redirect to PHP CLI when appropriate)
# Only redirect with bash -c for implicit PHP commands (flags only, no command)
# For explicit 'php' command, use direct exec for interactive mode
if [[ "$first_non_flag_arg" == "php" ]]; then
  # Explicit php command - use direct exec for interactive mode
  php_only_args=()
  for arg in "${args[@]}"; do
    if [[ "$arg" != "php" ]]; then
      php_only_args+=("$arg")
    fi
  done
  php_args=("${left_flags[@]}" "${left_options[@]}" "${php_only_args[@]}" "${right_flags[@]}" "${right_options[@]}")
  if [ "$DEBUG" ]; then echo "DEBUG: Direct PHP exec with args: ${php_args[*]}" >&2; fi
  execute_in_container "cli" "php" "${php_args[@]}"
elif [[ -z "$first_non_flag_arg" ]] && ([[ ${#left_flags[@]} -gt 0 ]] || [[ ${#right_flags[@]} -gt 0 ]] || [[ ${#right_options[@]} -gt 0 ]]); then
  # Only flags, no command - this is implicit PHP (orodc -v, orodc --version)
  # Setup logging for PHP binary usage
  setup_php_logging "$@"
  php_args=("${left_flags[@]}" "${left_options[@]}" "${args[@]}" "${right_flags[@]}" "${right_options[@]}")
  if [ "$DEBUG" ]; then echo "DEBUG: Implicit PHP redirect with args: ${php_args[*]}" >&2; fi
  execute_in_container "cli" "php" "${php_args[@]}"
fi

if echo "$first_non_flag_arg" | grep -i '^mysql' > /dev/null; then
  # Extract mysql arguments (everything after 'mysql')
  mysql_args=("${args[@]:1}")
  exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} run -i --rm -e MYSQL_PWD="$DC_ORO_DATABASE_PASSWORD" database-cli mysql -h"$DC_ORO_DATABASE_HOST" -P"$DC_ORO_DATABASE_PORT" -u"$DC_ORO_DATABASE_USER" "$DC_ORO_DATABASE_DBNAME" "${mysql_args[@]}"
fi

if echo "$first_non_flag_arg" | grep -i '^psql' > /dev/null; then
  # Extract psql arguments (everything after 'psql')
  psql_args=("${args[@]:1}")
  exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} run -i --rm -e PGPASSWORD="$DC_ORO_DATABASE_PASSWORD" database-cli psql -h "$DC_ORO_DATABASE_HOST" -p "$DC_ORO_DATABASE_PORT" -U "$DC_ORO_DATABASE_USER" -d "$DC_ORO_DATABASE_DBNAME" "${psql_args[@]}"
fi

if echo "$first_non_flag_arg" | grep -i '^database-cli' > /dev/null; then
  # Extract database-cli arguments (everything after 'database-cli')
  database_cli_args=("${args[@]:1}")
  # If no arguments provided, default to bash
  if [[ ${#database_cli_args[@]} -eq 0 ]]; then
    database_cli_args=("bash")
  fi
  exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} run -i --rm -e PGPASSWORD="$DC_ORO_DATABASE_PASSWORD" database-cli "${database_cli_args[@]}"
fi

if [ $# -eq 0 ] || [ "${args[0]}" = "ssh" ]; then
  SSH_HOST=${DC_ORO_SSH_BIND_HOST:-127.0.0.1}
  
  # Get SSH port directly (fast operation, no spinner needed)
  SSH_PORT=$(${DOCKER_BIN} inspect "$(${DOCKER_COMPOSE_BIN_CMD} ps | grep ssh | awk '{ print $1 }')" | jq -r '.[0].NetworkSettings.Ports["22/tcp"][0].HostPort')
  
  if [[ -z "$SSH_PORT" ]]; then
    msg_error "SSH service is not running. Start it with: orodc up -d"
    exit 1
  fi

  set -x
  exec ssh \
    -o SendEnv=COMPOSER_AUTH \
    -o UserKnownHostsFile=/dev/null \
    -o StrictHostKeyChecking=no \
    -o 'ForwardAgent no' \
    -o IdentitiesOnly=yes \
    -i "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519" \
    -p "${SSH_PORT}" \
    ${ORO_DC_SSH_ARGS} \
    "${DC_ORO_USER_NAME}@${SSH_HOST}" \
    "${args[@]:1}" \
    "${right_flags[@]}" \
    "${right_options[@]}"
fi

# Function to check if command is a built-in docker compose command
is_docker_compose_command() {
  local cmd="$1"
  # Get list of docker compose commands dynamically
  local compose_commands
  compose_commands=$(${DOCKER_COMPOSE_BIN} --help 2>/dev/null | grep -A 100 "Commands:" | grep "^  [a-z]" | awk '{print $1}' | tr '\n' '|')
  compose_commands="${compose_commands%|}" # remove trailing |
  
  # Check if command matches any docker compose command
  echo "$cmd" | grep -qE "^(${compose_commands})$"
}

# Function moved earlier to avoid "command not found" error

is_special_orodc_command() {
  local cmd="$1"
  case "$cmd" in
    ssh|cli|pgsql|psql|mysql|database-cli|install|purge|test|tests|bash|help|man|init)
      return 0
      ;;
    *)
      # Check complex patterns that are handled specially
      if echo "$cmd" | grep -qi 'import.*\(db\|database\)'; then return 0; fi
      if echo "$cmd" | grep -qi '\(set\|update\).*\(url\|uri\)'; then return 0; fi
      if echo "$cmd" | grep -qi '^cache'; then return 0; fi
      if [[ "$cmd" == "platform" ]]; then return 0; fi
      if echo "$cmd" | grep -qi 'composer.*install'; then return 0; fi
      if echo "$cmd" | grep -qi '\(export\|dump\).*\(db\|database\)'; then return 0; fi
      return 1
      ;;
  esac
}


# Check if any argument is a docker compose command (will be handled at the end)
is_docker_compose_cmd=false
if [[ ${#args[@]} -gt 0 ]]; then
  for arg in "${args[@]}"; do
    if is_docker_compose_command "$arg"; then
      is_docker_compose_cmd=true
      break
    fi
  done
fi
if [[ -n "${DEBUG:-}" ]]; then
  echo "DEBUG: is_docker_compose_cmd=$is_docker_compose_cmd, args=${args[*]:-none}" >&2
  echo "DEBUG: args[0]=${args[0]:-empty}, args length=${#args[@]}" >&2
fi


# Mount external PHP files will be called after DOCKER_COMPOSE_RUN_CMD is defined

if [[ "$is_docker_compose_cmd" != "true" ]]; then
  # Check if any argument contains a .php file
  has_php_file=false
  for arg in "${args[@]}" "${right_flags[@]}" "${right_options[@]}"; do
    if [[ "$arg" == *.php ]]; then
      has_php_file=true
      break
    fi
  done

# If arguments contain .php file, redirect to PHP
if [[ "$has_php_file" == true ]]; then
  # Special handling for bash -c commands with PHP files
  if [[ "${args[0]}" == "bash" && "${right_flags[0]}" == "-c" ]]; then
    # For bash -c 'php script.php', reconstruct proper argument order
    exec ${DOCKER_COMPOSE_RUN_CLI_CMD} ${left_flags[@]} ${left_options[@]} cli bash -c "${args[@]:1}" "${right_options[@]}"
  else
    # Prepend 'php' to the command if not already present
    if [[ "${args[0]}" != "php" ]]; then
      # For PHP files, treat left_flags as PHP flags (not docker compose flags)
      # Only use actual docker compose flags from left_flags
      docker_flags=()
      php_flags=()
      for flag in "${left_flags[@]}"; do
        case "$flag" in
          -d|-e|--env|--env-file|--label|--name|--user|--workdir|--entrypoint|--platform)
            docker_flags+=("$flag")
            ;;
          *)
            php_flags+=("$flag")
            ;;
        esac
      done
      execute_in_container "cli" "php" "${php_flags[@]}" "${right_flags[@]}" "${right_options[@]}" "${args[@]}"
    else
      execute_in_container "cli" "${args[@]}" "${right_flags[@]}" "${right_options[@]}"
    fi
  fi
fi
fi

# Auto-add --no-interaction to composer install/update commands
if [[ "$first_non_flag_arg" == "composer" ]] && [[ "${args[1]}" =~ ^(install|update|require|create-project)$ ]]; then
  # Check if --no-interaction is not already present
  has_no_interaction=false
  for flag in "${right_flags[@]}" "${right_options[@]}" "${args[@]:2}"; do
    if [[ "$flag" == "--no-interaction" ]] || [[ "$flag" == "-n" ]]; then
      has_no_interaction=true
      break
    fi
  done
  
  if [[ "$has_no_interaction" == "false" ]]; then
    # Add --no-interaction flag
    right_flags+=("--no-interaction")
    if [[ -n "${DEBUG:-}" ]]; then
      echo "DEBUG: Auto-added --no-interaction to composer ${args[1]}" >&2
    fi
  fi
  
  # For composer install, create config/parameters.yml from dist file if not exists (prevents Incenteev interactive prompts)
  if [[ "${args[1]}" == "install" ]]; then
    ${DOCKER_COMPOSE_BIN_CMD} run --rm cli bash -c "if [[ ! -f ${DC_ORO_APPDIR}/config/parameters.yml ]] && [[ -f ${DC_ORO_APPDIR}/config/parameters.yml.dist ]]; then cp ${DC_ORO_APPDIR}/config/parameters.yml.dist ${DC_ORO_APPDIR}/config/parameters.yml; fi" 2>/dev/null || true
    if [[ -n "${DEBUG:-}" ]]; then
      echo "DEBUG: Prepared config/parameters.yml from dist file" >&2
    fi
  fi
fi

# If command is not a docker compose built-in command and not a special orodc command, redirect to CLI container
if [[ -n "${DEBUG:-}" ]]; then
  echo "DEBUG: Checking special commands: args[0]='${args[0]}', first_non_flag_arg='$first_non_flag_arg'" >&2
fi

if [[ ${#args[@]} -gt 0 ]] && [[ "$is_docker_compose_cmd" != "true" ]] && ! is_special_orodc_command "$first_non_flag_arg"; then
  echo "Running command in 'cli' service..."
  # Special handling for bash -c commands
  if [[ "${args[0]}" == "bash" && "${right_flags[0]}" == "-c" ]]; then
    # For bash -c 'command', reconstruct proper argument order
    exec ${DOCKER_COMPOSE_RUN_CMD} ${left_flags[@]} ${left_options[@]} cli bash -c "${args[@]:1}" "${right_options[@]}"
  else
    # Pass arguments directly to docker compose exec without additional escaping
    # Combine args with right_flags and right_options in proper order
    cli_cmd=$(build_docker_compose_run_cmd "cli" "${args[@]}")
    exec bash -c "$cli_cmd"
  fi
fi

if echo ${args[0]} | grep -i '^cli$' > /dev/null; then
  exec bash -c "${DOCKER_COMPOSE_RUN_CMD} ${left_flags[@]} ${left_options[@]} cli"
fi

if echo ${args[0]} | grep -i '^install' | grep -i 'without' | grep -i 'demo' > /dev/null; then
  export XDEBUG_MODE=off
  
  # Get previous timing for statistics only
  prev_install_timing=$(get_previous_timing "install")
  
  # Record start time for full install
  install_start_time=$(date +%s)
  
  # Clear cache
  cache_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm cli bash -c \"[[ -d ${DC_ORO_APPDIR}/var/cache ]] && rm -rf ${DC_ORO_APPDIR}/var/cache/* || true\""
  run_with_spinner "Clearing cache" "$cache_cmd" || exit $?
  
  # Backup existing config/parameters.yml if exists, then create from dist file
  params_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm cli bash -c \"
    if [[ -f ${DC_ORO_APPDIR}/config/parameters.yml ]]; then
      BACKUP_NAME=\\\"${DC_ORO_APPDIR}/config/parameters.yml.\$(date +%Y%m%d%H%M).backup\\\"
      mv ${DC_ORO_APPDIR}/config/parameters.yml \\\"\\\${BACKUP_NAME}\\\"
      echo \\\"Backed up existing parameters.yml to \\\${BACKUP_NAME}\\\"
    fi
    if [[ -f ${DC_ORO_APPDIR}/config/parameters.yml.dist ]]; then
      cp ${DC_ORO_APPDIR}/config/parameters.yml.dist ${DC_ORO_APPDIR}/config/parameters.yml
    fi
  \""
  run_with_spinner "Preparing config files" "$params_cmd" || exit $?
  
  # Run composer install with spinner (use -T to disable pseudo-TTY for non-interactive mode)
  composer_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm -T cli bash -c \"composer install --no-interaction\""
  run_with_spinner "Running composer install" "$composer_cmd" || exit $?
  
  # Run oro:install with spinner (use -T to disable pseudo-TTY for non-interactive mode)
  install_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm -T cli bash -c \"php bin/console --env=prod --timeout=1800 oro:install --language=en --formatting-code=en_US --organization-name='Acme Inc.' --user-name=admin --user-email=admin@example.com --user-firstname=John --user-lastname=Doe --user-password='\\\$ecretPassw0rd' --application-url='https://${DC_ORO_NAME:-unnamed}.docker.local/' --sample-data=n\""
  run_with_spinner "Installing Application without demo data" "$install_cmd" || exit $?
  
  # Calculate and save total install time
  install_end_time=$(date +%s)
  install_duration=$((install_end_time - install_start_time))
  save_timing "install" "$install_duration"
  
  msg_ok "Installation completed in ${install_duration}s"
  
  exit 0
elif echo ${args[0]} | grep -i '^install$' > /dev/null; then
  export XDEBUG_MODE=off
  
  # Get previous timing for statistics only
  prev_install_timing=$(get_previous_timing "install")
  
  # Record start time for full install
  install_start_time=$(date +%s)
  
  # Clear cache
  cache_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm cli bash -c \"[[ -d ${DC_ORO_APPDIR}/var/cache ]] && rm -rf ${DC_ORO_APPDIR}/var/cache/* || true\""
  run_with_spinner "Clearing cache" "$cache_cmd" || exit $?
  
  # Backup existing config/parameters.yml if exists, then create from dist file
  params_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm cli bash -c \"
    if [[ -f ${DC_ORO_APPDIR}/config/parameters.yml ]]; then
      BACKUP_NAME=\\\"${DC_ORO_APPDIR}/config/parameters.yml.\$(date +%Y%m%d%H%M).backup\\\"
      mv ${DC_ORO_APPDIR}/config/parameters.yml \\\"\\\${BACKUP_NAME}\\\"
      echo \\\"Backed up existing parameters.yml to \\\${BACKUP_NAME}\\\"
    fi
    if [[ -f ${DC_ORO_APPDIR}/config/parameters.yml.dist ]]; then
      cp ${DC_ORO_APPDIR}/config/parameters.yml.dist ${DC_ORO_APPDIR}/config/parameters.yml
    fi
  \""
  run_with_spinner "Preparing config files" "$params_cmd" || exit $?
  
  # Run composer install with spinner (use -T to disable pseudo-TTY for non-interactive mode)
  composer_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm -T cli bash -c \"composer install --no-interaction\""
  run_with_spinner "Running composer install" "$composer_cmd" || exit $?
  
  # Run oro:install with spinner (use -T to disable pseudo-TTY for non-interactive mode)
  install_cmd="${DOCKER_COMPOSE_BIN_CMD} run --rm -T cli bash -c \"php bin/console --env=prod --timeout=1800 oro:install --language=en --formatting-code=en_US --organization-name='Acme Inc.' --user-name=admin --user-email=admin@example.com --user-firstname=John --user-lastname=Doe --user-password='\\\$ecretPassw0rd' --application-url='https://${DC_ORO_NAME:-unnamed}.docker.local/' --sample-data=y\""
  run_with_spinner "Installing Application with sample data" "$install_cmd" || exit $?
  
  # Calculate and save total install time
  install_end_time=$(date +%s)
  install_duration=$((install_end_time - install_start_time))
  save_timing "install" "$install_duration"
  
  msg_ok "Installation completed in ${install_duration}s"
  
  exit 0
fi


# Handle tests commands - unified entry point
if [[ "$first_non_flag_arg" == "tests" ]]; then
  # CRITICAL COMPOSE MERGING LOGIC - READ CAREFULLY BEFORE MODIFYING
  # =================================================================
  # 
  # PROBLEM: Test services in docker-compose-test.yml reference volumes (like 'appcode') 
  # that are defined in the main docker-compose.yml. Simply using docker-compose-test.yml 
  # alone causes "undefined volume" errors.
  #
  # SOLUTION: We must merge ALL compose files into a single compose.yml that contains:
  # 1. Base services and volumes from docker-compose.yml
  # 2. Database-specific services from docker-compose-{pgsql|mysql}.yml
  # 3. User customizations from .docker-compose.user.yml (if exists)
  # 4. Test services from docker-compose-test.yml
  #
  # WHY USE DOCKER_COMPOSE_BIN_CMD: This variable already contains the properly constructed
  # command with all base compose files in the correct order. We reuse this logic instead
  # of duplicating the file selection logic.
  #
  # WHY GENERATE compose.yml: The 'down' and 'purge' commands need to know about test 
  # services to stop them properly. By creating a merged compose.yml, these commands
  # can find and stop test containers even after the test session ends.
  
  # Reuse existing compose command logic and add test file
  # DOCKER_COMPOSE_BIN_CMD already contains: base + database + user compose files
  TEST_AWARE_COMPOSE_CMD="${DOCKER_COMPOSE_BIN_CMD}"
  if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-test.yml" ]]; then
    TEST_AWARE_COMPOSE_CMD="${TEST_AWARE_COMPOSE_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-test.yml"
  fi
  
  # Generate properly merged compose.yml using 'docker compose config'
  # This command merges all compose files and resolves all references (volumes, networks, etc.)
  if DC_ORO_NAME="$DC_ORO_NAME" bash -c "${TEST_AWARE_COMPOSE_CMD} config" > "${DC_ORO_CONFIG_DIR}/compose.yml" 2>/dev/null; then
    msg_info "All services merged into compose.yml for persistent management"
  else
    msg_warning "Failed to merge compose files, falling back to test-only mode"
    # Fallback: create basic merged file (this will likely cause volume errors)
    # This fallback exists for edge cases but is not the intended path
    cat > "${DC_ORO_CONFIG_DIR}/compose.yml" << 'EOF'
# Auto-generated merged compose file including test services
# This ensures test services are included in down/purge operations
# WARNING: This fallback may cause "undefined volume" errors
EOF
    if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-test.yml" ]]; then
      cat "${DC_ORO_CONFIG_DIR}/docker-compose-test.yml" >> "${DC_ORO_CONFIG_DIR}/compose.yml"
    fi
  fi
  
  # Build test-aware compose command using the merged compose.yml
  # IMPORTANT: We use the merged compose.yml file instead of multiple -f flags
  # because it already contains all services and resolved volume references
  TEST_COMPOSE_CMD="${DOCKER_COMPOSE_BIN} -f ${DC_ORO_CONFIG_DIR}/compose.yml"
  
  # Use test-cli container for test commands
  CLI_SERVICE="test-cli"
  
  # Define test-specific variables with fallbacks to main variables
  DC_ORO_TEST_DATABASE_HOST="${DC_ORO_TEST_DATABASE_HOST:-${DC_ORO_DATABASE_HOST:-database}}"
  DC_ORO_TEST_DATABASE_PORT="${DC_ORO_TEST_DATABASE_PORT:-${DC_ORO_DATABASE_PORT:-5432}}"
  DC_ORO_TEST_DATABASE_USER="${DC_ORO_TEST_DATABASE_USER:-${DC_ORO_DATABASE_USER:-oro_db_user}}"
  DC_ORO_TEST_DATABASE_PASSWORD="${DC_ORO_TEST_DATABASE_PASSWORD:-${DC_ORO_DATABASE_PASSWORD:-oro_db_pass}}"
  DC_ORO_TEST_DATABASE_DBNAME="${DC_ORO_TEST_DATABASE_DBNAME:-${DC_ORO_DATABASE_DBNAME:-oro_db}_test}"
  
  # Create test database URI using parse_dsn_uri function
  TEST_DB_URI="postgres://${DC_ORO_TEST_DATABASE_USER}:${DC_ORO_TEST_DATABASE_PASSWORD}@${DC_ORO_TEST_DATABASE_HOST}:${DC_ORO_TEST_DATABASE_PORT}/${DC_ORO_TEST_DATABASE_DBNAME}"
  parse_dsn_uri "$TEST_DB_URI" "database" "DC_ORO_TEST"
  # Function creates DC_ORO_TEST_DATABASE_URI automatically
  
  # Handle different test subcommands
  case "${args[1]}" in
    "install"|"setup")
      msg_info "Installing test environment and database..."
      # Start all required services
      ${TEST_COMPOSE_CMD} up -d >/dev/null 2>&1
      
      
      # Check if test database already exists
      DB_EXISTS=false
      if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]]; then
        # Check PostgreSQL database existence
        if ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=\$DC_ORO_DATABASE_PASSWORD psql -h \$DC_ORO_DATABASE_HOST -p \$DC_ORO_DATABASE_PORT -U \$DC_ORO_DATABASE_USER -d \$DC_ORO_DATABASE_DBNAME -c 'SELECT 1 FROM pg_database WHERE datname = '\''${DC_ORO_TEST_DATABASE_DBNAME}'\'';'" 2>/dev/null | grep -q "1 row"; then
          DB_EXISTS=true
        fi
      elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]]; then
        # Check MySQL/MariaDB database existence
        if ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME -e 'SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '\''${DC_ORO_TEST_DATABASE_DBNAME}'\'';'" 2>/dev/null | grep -q "${DC_ORO_TEST_DATABASE_DBNAME}"; then
          DB_EXISTS=true
        fi
      fi
      
      if [[ "$DB_EXISTS" == "true" ]]; then
        echo "Test database ${DC_ORO_TEST_DATABASE_DBNAME} already exists, skipping database setup..."
      else
        echo "Creating test database ${DC_ORO_TEST_DATABASE_DBNAME}..."
        if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]]; then
          # PostgreSQL commands using test-specific environment variables
          ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=${DC_ORO_TEST_DATABASE_PASSWORD} psql -h ${DC_ORO_TEST_DATABASE_HOST} -p ${DC_ORO_TEST_DATABASE_PORT} -U ${DC_ORO_TEST_DATABASE_USER} -d \$DC_ORO_DATABASE_DBNAME -c 'SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '\''${DC_ORO_TEST_DATABASE_DBNAME}'\'';'" 2>/dev/null || true
          ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=${DC_ORO_TEST_DATABASE_PASSWORD} psql -h ${DC_ORO_TEST_DATABASE_HOST} -p ${DC_ORO_TEST_DATABASE_PORT} -U ${DC_ORO_TEST_DATABASE_USER} -d \$DC_ORO_DATABASE_DBNAME -c 'DROP DATABASE IF EXISTS ${DC_ORO_TEST_DATABASE_DBNAME};'" 2>/dev/null || true
          ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=${DC_ORO_TEST_DATABASE_PASSWORD} psql -h ${DC_ORO_TEST_DATABASE_HOST} -p ${DC_ORO_TEST_DATABASE_PORT} -U ${DC_ORO_TEST_DATABASE_USER} -d \$DC_ORO_DATABASE_DBNAME -c 'CREATE DATABASE ${DC_ORO_TEST_DATABASE_DBNAME};'" || {
            echo "Failed to create test database"
            exit 1
          }
        elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]]; then
          # MySQL/MariaDB commands using environment variables like existing mysql command
          ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME -e 'DROP DATABASE IF EXISTS ${DC_ORO_TEST_DATABASE_DBNAME};'" 2>/dev/null || true
          ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME -e 'CREATE DATABASE ${DC_ORO_TEST_DATABASE_DBNAME};'" || {
            echo "Failed to create test database"
            exit 1
          }
        fi
      fi
      
      # Clear test cache and install (only if database was created)
      if [[ "$DB_EXISTS" == "false" ]]; then
        msg_info "Setting up Oro test environment..."
        echo "Running cache clear in 'test-cli' service..."
        ${TEST_COMPOSE_CMD} run --rm test-cli bash -c "rm -rf var/cache/test" 2>/dev/null || true
        echo "Running oro:install in 'test-cli' service..."
        # Run oro:install in background and monitor output for consumer messages
        ${TEST_COMPOSE_CMD} run --rm test-cli bin/console oro:install --disabled-listeners=all 2>&1 | while IFS= read -r line; do
          echo "$line"
          if [[ "$line" == *"Processing consumer messages"* ]]; then
            echo "==> Detected consumer message processing, stopping test-consumer..."
            # Wait for consumer processes to start
            for i in {1..10}; do
              if ${TEST_COMPOSE_CMD} exec -T test-cli bash -c "ps aux | grep 'oro:message-queue:consume' | grep -v grep >/dev/null 2>&1"; then
                echo "Consumer processes found, stopping them..."
                ${TEST_COMPOSE_CMD} exec -T test-cli bash -c "pids=\$(ps aux | grep 'oro:message-queue:consume' | grep -v grep | awk '{print \$2}'); [ -n \"\$pids\" ] && echo \$pids | xargs kill -9" 2>/dev/null || true
                break
              fi
              echo "Waiting for consumer processes to start... ($i/10)"
              sleep 0.5
            done
          fi
        done
      else
        echo "Oro test environment already installed, skipping oro:install..."
      fi
      
      # Warm up test environment caches
      msg_info "Warming up test environment caches..."
      echo "Warming up test cache..."
      ${TEST_COMPOSE_CMD} run --rm test-cli bin/console cache:warmup --env=test 2>/dev/null || true

      # Generate behat.yml with correct URLs for test environment
      msg_info "Generating behat.yml with test environment URLs..."
      BEHAT_DIST_FILE="${DC_ORO_APPDIR}/vendor/oro/platform/src/Oro/Bundle/TestFrameworkBundle/Resources/config/behat.yml.dist"
      BEHAT_CONFIG_FILE="${DC_ORO_APPDIR}/behat.yml"
      
      if [[ -f "$BEHAT_DIST_FILE" ]]; then
        # Copy behat.yml.dist and replace URLs with sed for test environment
        cp "$BEHAT_DIST_FILE" "$BEHAT_CONFIG_FILE"
        
        # Replace localhost:4444 with test-selenium:4444 for WebDriver host
        sed -i '' "s|localhost:4444|test-selenium:4444|g" "$BEHAT_CONFIG_FILE" 2>/dev/null || sed -i "s|localhost:4444|test-selenium:4444|g" "$BEHAT_CONFIG_FILE"
        # Replace localhost:9515 with test-selenium:9515 for ChromeDriver host  
        sed -i '' "s|localhost:9515|test-selenium:9515|g" "$BEHAT_CONFIG_FILE" 2>/dev/null || sed -i "s|localhost:9515|test-selenium:9515|g" "$BEHAT_CONFIG_FILE"
        
        # Note: OroCommerce admin panel is accessible at root path, not /admin/
        echo "Keeping base_url as root path for admin panel access"
        
        # Add necessary Chrome arguments for Docker environment to the main sessions (port 4444)
        # This fixes the "DevToolsActivePort file doesn't exist" error
        if grep -q -- '--load-extension.*chrome-extension' "$BEHAT_CONFIG_FILE"; then
          # Create temporary file with the Chrome arguments to add
          TEMP_CHROME_ARGS=$(mktemp)
          cat > "$TEMP_CHROME_ARGS" << 'EOF'
                                        - "--no-sandbox"
                                        - "--disable-gpu"
                                        - "--headless"
                                        - "--disable-dev-shm-usage"
                                        - "--no-first-run"
                                        - "--disable-extensions"
                                        - "--disable-renderer-backgrounding"
EOF
          
          # Use awk to insert the Chrome arguments after the line containing chrome-extension
          awk '
            /--load-extension.*chrome-extension/ {
              print $0
              while ((getline line < "'"$TEMP_CHROME_ARGS"'") > 0) print line
              close("'"$TEMP_CHROME_ARGS"'")
              next
            }
            { print }
          ' "$BEHAT_CONFIG_FILE" > "${BEHAT_CONFIG_FILE}.tmp" && mv "${BEHAT_CONFIG_FILE}.tmp" "$BEHAT_CONFIG_FILE"
          
          # Clean up temporary file
          rm -f "$TEMP_CHROME_ARGS"
        fi
        
        echo "Generated behat.yml with test environment URLs and Docker-compatible Chrome options"
      else
        echo "Warning: behat.yml.dist not found, skipping behat.yml generation"
      fi
      
      # Start test services including test-consumer
      ${TEST_COMPOSE_CMD} up -d test-fpm test-nginx test-selenium test-consumer
      echo "Test environment setup completed!"
      exit 0
      ;;
      
    "purge"|"destroy")
      echo "Purging test environment..."
      
      # Build compose command without test file to get list of test services
      MAIN_COMPOSE_CMD="${DOCKER_COMPOSE_BIN} -f ${DC_ORO_CONFIG_DIR}/docker-compose.yml"
      
      # Add database-specific compose file
      if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]];then
        MAIN_COMPOSE_CMD="${MAIN_COMPOSE_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-pgsql.yml"
      elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
        MAIN_COMPOSE_CMD="${MAIN_COMPOSE_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-mysql.yml"
      fi
      
      # Add user compose file if exists
      if [[ -f "$DC_ORO_APPDIR/.docker-compose.user.yml" ]]; then
        MAIN_COMPOSE_CMD="${MAIN_COMPOSE_CMD} -f $DC_ORO_APPDIR/.docker-compose.user.yml"
      fi
      
      # Get test services from docker-compose-test.yml using yq
      if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-test.yml" ]]; then
        TEST_SERVICES=$(yq e '.services | keys | .[]' "${DC_ORO_CONFIG_DIR}/docker-compose-test.yml" 2>/dev/null | tr '\n' ' ')
        if [[ -n "$TEST_SERVICES" ]]; then
          echo "Stopping test services: $TEST_SERVICES"
          ${TEST_COMPOSE_CMD} stop $TEST_SERVICES 2>/dev/null || true
          ${TEST_COMPOSE_CMD} rm -f $TEST_SERVICES 2>/dev/null || true
        fi
      fi
      
      # Drop test database using the same approach as existing database commands
      # Test database name = main database name + _test suffix
      echo "Dropping test database ${DC_ORO_TEST_DATABASE_DBNAME}..."
      
      if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]]; then
        # PostgreSQL commands using test-specific environment variables
        ${MAIN_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=${DC_ORO_TEST_DATABASE_PASSWORD} psql -h ${DC_ORO_TEST_DATABASE_HOST} -p ${DC_ORO_TEST_DATABASE_PORT} -U ${DC_ORO_TEST_DATABASE_USER} -d \$DC_ORO_DATABASE_DBNAME -c 'SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '\''${DC_ORO_TEST_DATABASE_DBNAME}'\'';'" 2>/dev/null || true
        ${MAIN_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=${DC_ORO_TEST_DATABASE_PASSWORD} psql -h ${DC_ORO_TEST_DATABASE_HOST} -p ${DC_ORO_TEST_DATABASE_PORT} -U ${DC_ORO_TEST_DATABASE_USER} -d \$DC_ORO_DATABASE_DBNAME -c 'DROP DATABASE ${DC_ORO_TEST_DATABASE_DBNAME};'" 2>/dev/null || true
      elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]]; then
        # MySQL/MariaDB commands using environment variables like existing mysql command
        ${MAIN_COMPOSE_CMD} run --rm database-cli bash -c "MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME -e 'DROP DATABASE IF EXISTS ${DC_ORO_TEST_DATABASE_DBNAME};'" 2>/dev/null || true
      fi
      
      # Remove merged compose.yml to restore original configuration
      # IMPORTANT: This cleanup prevents the merged compose.yml from interfering 
      # with normal operations. The merged file should only exist during test sessions.
      rm -f "${DC_ORO_CONFIG_DIR}/compose.yml" 2>/dev/null || true
      echo "Test environment destroyed!"
      exit 0
      ;;
      
    "status")
      echo "Test environment status:"
      ${TEST_COMPOSE_CMD} ps test-fpm test-nginx test-selenium
      echo ""
      echo "Test application: Available in Docker network (test-nginx)"
      echo "Selenium WebDriver: Available in Docker network (test-selenium:4444)"
      exit 0
      ;;
      
    "consumer-stop")
      echo "Stopping test consumer (SIGSTOP)..."
      ${TEST_COMPOSE_CMD} exec test-cli bash -c "pids=\$(pgrep -f 'oro:message-queue:consume'); [ -n \"\$pids\" ] && echo \$pids | xargs kill -STOP" 2>/dev/null || echo "Consumer process not found or already stopped"
      exit 0
      ;;
      
    "consumer-start")
      echo "Starting test consumer (SIGCONT)..."
      ${TEST_COMPOSE_CMD} exec test-cli bash -c "pids=\$(pgrep -f 'oro:message-queue:consume'); [ -n \"\$pids\" ] && echo \$pids | xargs kill -CONT" 2>/dev/null || echo "Consumer process not found"
      exit 0
      ;;
      
    "consumer-kill")
      echo "Killing test consumer (SIGKILL)..."
      ${TEST_COMPOSE_CMD} exec test-cli bash -c "pids=\$(pgrep -f 'oro:message-queue:consume'); [ -n \"\$pids\" ] && echo \$pids | xargs kill -9" 2>/dev/null || echo "Consumer process not found"
      exit 0
      ;;
      
    "consumer-status")
      echo "Test consumer status:"
      ${TEST_COMPOSE_CMD} exec test-cli bash -c "ps aux | grep -v grep | grep 'oro:message-queue:consume' || echo 'Consumer process not running'"
      exit 0
      ;;
      
    *)
      # Handle any other command by executing it in test-cli container
      # This makes 'orodc tests' a full replacement for 'orodc' but in test environment
      msg_info "Running command in 'test-cli' service..."
      ${TEST_COMPOSE_CMD} up -d >/dev/null 2>&1
      
      # For tests command, use arguments after 'tests' without parsing
      # Skip 'tests' (first argument) and use everything else as-is
      test_command_args=("${args[@]:1}")
      exec ${TEST_COMPOSE_CMD} run --rm test-cli "${test_command_args[@]}"
      ;;
  esac
  exit 0
fi

if [[ -n "${DEBUG:-}" ]]; then
  echo "DEBUG: Checking purge condition: first_non_flag_arg='$first_non_flag_arg'" >&2
fi

# Handle init command (interactive service configuration)
if [[ "$first_non_flag_arg" == "init" ]]; then
  msg_header "OroDC Interactive Configuration"
  msg_info "This will help you configure services for your project"
  echo ""
  
  ENV_FILE=".env.orodc"
  
  # Load existing configuration if available
  EXISTING_PHP_VERSION=""
  EXISTING_NODE_VERSION=""
  EXISTING_COMPOSER_VERSION=""
  EXISTING_PHP_IMAGE=""
  EXISTING_DB_SCHEMA=""
  EXISTING_DB_VERSION=""
  EXISTING_DB_IMAGE=""
  EXISTING_SEARCH_ENGINE=""
  EXISTING_SEARCH_VERSION=""
  EXISTING_SEARCH_IMAGE=""
  EXISTING_CACHE_ENGINE=""
  EXISTING_CACHE_VERSION=""
  EXISTING_CACHE_IMAGE=""
  EXISTING_RABBITMQ_VERSION=""
  EXISTING_RABBITMQ_IMAGE=""
  
  if [[ -f "$ENV_FILE" ]]; then
    msg_info "Found existing configuration, loading current values..."
    
    # Source the file to load variables
    while IFS='=' read -r key value; do
      # Skip comments and empty lines
      [[ "$key" =~ ^#.*$ ]] && continue
      [[ -z "$key" ]] && continue
      
      # Remove quotes if present
      value="${value%\"}"
      value="${value#\"}"
      value="${value%\'}"
      value="${value#\'}"
      
      case "$key" in
        DC_ORO_PHP_VERSION) EXISTING_PHP_VERSION="$value" ;;
        DC_ORO_NODE_VERSION) EXISTING_NODE_VERSION="$value" ;;
        DC_ORO_COMPOSER_VERSION) EXISTING_COMPOSER_VERSION="$value" ;;
        DC_ORO_PHP_IMAGE) EXISTING_PHP_IMAGE="$value" ;;
        DC_ORO_DATABASE_SCHEMA) EXISTING_DB_SCHEMA="$value" ;;
        DC_ORO_DATABASE_VERSION) EXISTING_DB_VERSION="$value" ;;
        DC_ORO_DATABASE_IMAGE) EXISTING_DB_IMAGE="$value" ;;
        DC_ORO_SEARCH_ENGINE) EXISTING_SEARCH_ENGINE="$value" ;;
        DC_ORO_SEARCH_VERSION) EXISTING_SEARCH_VERSION="$value" ;;
        DC_ORO_SEARCH_IMAGE) EXISTING_SEARCH_IMAGE="$value" ;;
        DC_ORO_CACHE_ENGINE) EXISTING_CACHE_ENGINE="$value" ;;
        DC_ORO_CACHE_VERSION) EXISTING_CACHE_VERSION="$value" ;;
        DC_ORO_CACHE_IMAGE) EXISTING_CACHE_IMAGE="$value" ;;
        DC_ORO_RABBITMQ_VERSION) EXISTING_RABBITMQ_VERSION="$value" ;;
        DC_ORO_RABBITMQ_IMAGE) EXISTING_RABBITMQ_IMAGE="$value" ;;
      esac
    done < "$ENV_FILE"
    
    echo ""
  fi
  
  # Function to get compatible Node.js versions based on PHP version (sorted newest to oldest)
  get_compatible_node_versions() {
    local php_ver="$1"
    case "$php_ver" in
      7.3) echo "16" ;;
      7.4) echo "18 16" ;;
      8.1) echo "22 20 18 16" ;;
      8.2|8.3|8.4) echo "22 20 18" ;;
      8.5) echo "24 22" ;;
      *) echo "22 20 18" ;;
    esac
  }
  
  # Function to prompt for selection with validation and retry
  prompt_select() {
    local prompt="$1"
    local default="$2"
    shift 2
    local options=("$@")
    local result=""
    
    # Debug: show what we received
    if [[ -n "${DEBUG:-}" ]]; then
      >&2 echo "DEBUG: prompt='$prompt', default='$default', options count=${#options[@]}"
      >&2 echo "DEBUG: options=(${options[*]})"
    fi
    
    # Check if we have options
    if [[ ${#options[@]} -eq 0 ]]; then
      >&2 echo "ERROR: No options provided!"
      echo "$default"
      return
    fi
    
    while true; do
      # Output to stderr to avoid interfering with return value
      >&2 echo -e "\033[36m==> $prompt\033[0m"
      
      local i=1
      for opt in "${options[@]}"; do
        if [[ "$opt" == "$default" ]]; then
          >&2 echo "  $i) $opt [default]"
        else
          >&2 echo "  $i) $opt"
        fi
        ((i++))
      done
      
      # Read from terminal
      local selection
      >&2 echo -n "Select [1-${#options[@]}] (default: $default): "
      read selection </dev/tty
      
      # Empty input - use default
      if [[ -z "$selection" ]]; then
        result="$default"
        break
      fi
      
      # Check if input is a valid number
      if [[ ! "$selection" =~ ^[0-9]+$ ]]; then
        >&2 echo -e "\033[31mInvalid input: '$selection'. Please enter a number between 1 and ${#options[@]}.\033[0m"
        continue
      fi
      
      # Check if number is in valid range
      local idx=$((selection - 1))
      if [[ $idx -ge 0 && $idx -lt ${#options[@]} ]]; then
        result="${options[$idx]}"
        break
      else
        >&2 echo -e "\033[31mInvalid choice: '$selection'. Please enter a number between 1 and ${#options[@]}.\033[0m"
      fi
    done
    
    # Debug output if needed
    if [[ -n "${DEBUG:-}" ]]; then
      >&2 echo "DEBUG: prompt_select returned: '$result'"
    fi
    
    # Return selected value to stdout
    echo "$result"
  }
  
  # Function to prompt yes/no with default and validation
  prompt_yes_no() {
    local prompt="$1"
    local default="${2:-yes}"
    local answer
    
    while true; do
      if [[ "$default" == "yes" ]]; then
        >&2 echo -n "$prompt [Y/n]: "
        read answer </dev/tty
        answer="${answer:-y}"
      else
        >&2 echo -n "$prompt [y/N]: "
        read answer </dev/tty
        answer="${answer:-n}"
      fi
      
      # Accept: y, yes, Y, YES, n, no, N, NO
      case "${answer,,}" in  # Convert to lowercase
        y|yes) return 0 ;;
        n|no) return 1 ;;
        *)
          >&2 echo "Invalid input: '$answer'. Please enter 'y' (yes) or 'n' (no)."
          ;;
      esac
    done
  }
  
  # 1. PHP Configuration
  echo ""
  msg_header "1. PHP Configuration"
  
  # Determine if using custom image
  USE_CUSTOM_PHP=false
  if [[ -n "$EXISTING_PHP_IMAGE" ]] && [[ ! "$EXISTING_PHP_IMAGE" =~ ^ghcr\.io/digitalspacestdio/orodc-php-node-symfony: ]]; then
    USE_CUSTOM_PHP=true
  fi
  
  if prompt_yes_no "Use custom PHP image?" "$([ "$USE_CUSTOM_PHP" = true ] && echo yes || echo no)"; then
    >&2 echo -n "Enter custom PHP image$([ -n "$EXISTING_PHP_IMAGE" ] && echo " [current: $EXISTING_PHP_IMAGE]" || echo ""): "
    read SELECTED_PHP_IMAGE </dev/tty
    # If empty, keep existing
    if [[ -z "$SELECTED_PHP_IMAGE" ]] && [[ -n "$EXISTING_PHP_IMAGE" ]]; then
      SELECTED_PHP_IMAGE="$EXISTING_PHP_IMAGE"
    fi
    # Extract versions from custom image if possible (or use defaults/existing)
    SELECTED_PHP="${EXISTING_PHP_VERSION:-8.4}"
    SELECTED_NODE="${EXISTING_NODE_VERSION:-22}"
    SELECTED_COMPOSER="${EXISTING_COMPOSER_VERSION:-2}"
  else
    # Select PHP version (sorted newest to oldest)
    PHP_VERSIONS=("8.5" "8.4" "8.3" "8.2" "8.1" "7.4" "7.3")
    DEFAULT_PHP="${EXISTING_PHP_VERSION:-8.4}"
    SELECTED_PHP=$(prompt_select "Select PHP version:" "$DEFAULT_PHP" "${PHP_VERSIONS[@]}")
    
    if [[ -n "${DEBUG:-}" ]]; then
      >&2 echo "DEBUG: Selected PHP: '$SELECTED_PHP'"
    fi
    
    # Select Node.js version (based on PHP compatibility)
    read -ra COMPATIBLE_NODE_VERSIONS <<< "$(get_compatible_node_versions "$SELECTED_PHP")"
    
    # Determine default Node.js version based on PHP or existing config
    if [[ -n "$EXISTING_NODE_VERSION" ]] && [[ " ${COMPATIBLE_NODE_VERSIONS[*]} " =~ " ${EXISTING_NODE_VERSION} " ]]; then
      DEFAULT_NODE="$EXISTING_NODE_VERSION"
    else
      case "$SELECTED_PHP" in
        8.5) DEFAULT_NODE="24" ;;
        8.4) DEFAULT_NODE="22" ;;
        8.1|8.2|8.3) DEFAULT_NODE="20" ;;
        7.3|7.4) DEFAULT_NODE="16" ;;
        *) DEFAULT_NODE="22" ;;
      esac
      
      # Ensure default is in compatible versions list
      if [[ ! " ${COMPATIBLE_NODE_VERSIONS[*]} " =~ " ${DEFAULT_NODE} " ]]; then
        DEFAULT_NODE="${COMPATIBLE_NODE_VERSIONS[0]}"
      fi
    fi
    
    SELECTED_NODE=$(prompt_select "Select Node.js version (compatible with PHP $SELECTED_PHP):" "$DEFAULT_NODE" "${COMPATIBLE_NODE_VERSIONS[@]}")
    
    if [[ -n "${DEBUG:-}" ]]; then
      >&2 echo "DEBUG: Selected Node.js: '$SELECTED_NODE'"
    fi
    
    # Select Composer version (only for PHP 7.3, others use Composer 2 automatically)
    if [[ "$SELECTED_PHP" == "7.3" ]]; then
      COMPOSER_VERSIONS=("1" "2")
      # Default Composer version for PHP 7.3
      if [[ -n "$EXISTING_COMPOSER_VERSION" ]]; then
        DEFAULT_COMPOSER="$EXISTING_COMPOSER_VERSION"
      else
        DEFAULT_COMPOSER="1"
      fi
      
      SELECTED_COMPOSER=$(prompt_select "Select Composer version:" "$DEFAULT_COMPOSER" "${COMPOSER_VERSIONS[@]}")
      
      if [[ -n "${DEBUG:-}" ]]; then
        >&2 echo "DEBUG: Selected Composer: '$SELECTED_COMPOSER'"
      fi
    else
      # PHP 7.4+ always uses Composer 2
      SELECTED_COMPOSER="2"
      if [[ -n "${DEBUG:-}" ]]; then
        >&2 echo "DEBUG: Using Composer 2 (automatic for PHP $SELECTED_PHP)"
      fi
    fi
    
    # Build default image name
    SELECTED_PHP_IMAGE="ghcr.io/digitalspacestdio/orodc-php-node-symfony:${SELECTED_PHP}-node${SELECTED_NODE}-composer${SELECTED_COMPOSER}-alpine"
  fi
  
  msg_info "PHP Image: $SELECTED_PHP_IMAGE"
  
  # 2. Database Configuration
  echo ""
  msg_header "2. Database Configuration"
  
  # Determine if using custom database image
  USE_CUSTOM_DB=false
  if [[ -n "$EXISTING_DB_IMAGE" ]] && [[ ! "$EXISTING_DB_IMAGE" =~ ^(ghcr\.io/digitalspacestdio/orodc-pgsql:|mysql:) ]]; then
    USE_CUSTOM_DB=true
  fi
  
  if prompt_yes_no "Use custom database image?" "$([ "$USE_CUSTOM_DB" = true ] && echo yes || echo no)"; then
    >&2 echo -n "Enter custom database image$([ -n "$EXISTING_DB_IMAGE" ] && echo " [current: $EXISTING_DB_IMAGE]" || echo ""): "
    read SELECTED_DB_IMAGE </dev/tty
    # If empty, keep existing
    if [[ -z "$SELECTED_DB_IMAGE" ]] && [[ -n "$EXISTING_DB_IMAGE" ]]; then
      SELECTED_DB_IMAGE="$EXISTING_DB_IMAGE"
    fi
    SELECTED_DB_SCHEMA="${EXISTING_DB_SCHEMA:-pgsql}"
    SELECTED_DB_VERSION="${EXISTING_DB_VERSION:-custom}"
  else
    # Select database type based on existing or default
    DB_TYPES=("PostgreSQL" "MySQL")
    if [[ "$EXISTING_DB_SCHEMA" == "mysql" ]]; then
      DEFAULT_DB_TYPE="MySQL"
    else
      DEFAULT_DB_TYPE="PostgreSQL"
    fi
    SELECTED_DB_TYPE=$(prompt_select "Select database type:" "$DEFAULT_DB_TYPE" "${DB_TYPES[@]}")
    
    if [[ -n "${DEBUG:-}" ]]; then
      >&2 echo "DEBUG: Selected DB type: '$SELECTED_DB_TYPE'"
    fi
    
    # Select version based on type (sorted newest to oldest)
    if [[ "$SELECTED_DB_TYPE" == "PostgreSQL" ]]; then
      PGSQL_VERSIONS=("17.4" "16.6" "15.1")
      # Only use existing version if it's valid for PostgreSQL and schema hasn't changed
      if [[ "$EXISTING_DB_SCHEMA" == "pgsql" ]] && [[ " ${PGSQL_VERSIONS[*]} " =~ " ${EXISTING_DB_VERSION} " ]]; then
        DEFAULT_PGSQL_VERSION="$EXISTING_DB_VERSION"
      else
        DEFAULT_PGSQL_VERSION="16.6"
      fi
      SELECTED_DB_VERSION=$(prompt_select "Select PostgreSQL version:" "$DEFAULT_PGSQL_VERSION" "${PGSQL_VERSIONS[@]}")
      SELECTED_DB_SCHEMA="pgsql"
      SELECTED_DB_IMAGE="ghcr.io/digitalspacestdio/orodc-pgsql:${SELECTED_DB_VERSION}"
    else
      MYSQL_VERSIONS=("9.0" "8.4" "8.0" "5.7")
      # Only use existing version if it's valid for MySQL and schema hasn't changed
      if [[ "$EXISTING_DB_SCHEMA" == "mysql" ]] && [[ " ${MYSQL_VERSIONS[*]} " =~ " ${EXISTING_DB_VERSION} " ]]; then
        DEFAULT_MYSQL_VERSION="$EXISTING_DB_VERSION"
      else
        DEFAULT_MYSQL_VERSION="8.4"
      fi
      SELECTED_DB_VERSION=$(prompt_select "Select MySQL version:" "$DEFAULT_MYSQL_VERSION" "${MYSQL_VERSIONS[@]}")
      SELECTED_DB_SCHEMA="mysql"
      SELECTED_DB_IMAGE="mysql:${SELECTED_DB_VERSION}"
    fi
  fi
  
  msg_info "Database Image: $SELECTED_DB_IMAGE"
  
  # 3. Search Engine Configuration
  echo ""
  msg_header "3. Search Engine Configuration"
  
  # Determine if using custom search image
  USE_CUSTOM_SEARCH=false
  if [[ -n "$EXISTING_SEARCH_IMAGE" ]] && [[ ! "$EXISTING_SEARCH_IMAGE" =~ ^(docker\.elastic\.co/elasticsearch/elasticsearch:|opensearchproject/opensearch:) ]]; then
    USE_CUSTOM_SEARCH=true
  fi
  
  if prompt_yes_no "Use custom search engine image?" "$([ "$USE_CUSTOM_SEARCH" = true ] && echo yes || echo no)"; then
    >&2 echo -n "Enter custom search image$([ -n "$EXISTING_SEARCH_IMAGE" ] && echo " [current: $EXISTING_SEARCH_IMAGE]" || echo ""): "
    read SELECTED_SEARCH_IMAGE </dev/tty
    # If empty, keep existing
    if [[ -z "$SELECTED_SEARCH_IMAGE" ]] && [[ -n "$EXISTING_SEARCH_IMAGE" ]]; then
      SELECTED_SEARCH_IMAGE="$EXISTING_SEARCH_IMAGE"
    fi
    SELECTED_SEARCH_TYPE="${EXISTING_SEARCH_ENGINE:-Custom}"
    SELECTED_SEARCH_VERSION="${EXISTING_SEARCH_VERSION:-custom}"
  else
    # Select search engine type based on existing or default
    SEARCH_TYPES=("Elasticsearch" "OpenSearch")
    DEFAULT_SEARCH_TYPE="${EXISTING_SEARCH_ENGINE:-Elasticsearch}"
    SELECTED_SEARCH_TYPE=$(prompt_select "Select search engine:" "$DEFAULT_SEARCH_TYPE" "${SEARCH_TYPES[@]}")
    
    # Select version based on type (sorted newest to oldest)
    if [[ "$SELECTED_SEARCH_TYPE" == "Elasticsearch" ]]; then
      ELASTIC_VERSIONS=("8.15.0" "8.10.3" "7.17.0")
      # Only use existing version if it's valid for Elasticsearch and type hasn't changed
      if [[ "$EXISTING_SEARCH_ENGINE" == "Elasticsearch" ]] && [[ " ${ELASTIC_VERSIONS[*]} " =~ " ${EXISTING_SEARCH_VERSION} " ]]; then
        DEFAULT_ELASTIC_VERSION="$EXISTING_SEARCH_VERSION"
      else
        DEFAULT_ELASTIC_VERSION="8.15.0"
      fi
      SELECTED_SEARCH_VERSION=$(prompt_select "Select Elasticsearch version:" "$DEFAULT_ELASTIC_VERSION" "${ELASTIC_VERSIONS[@]}")
      SELECTED_SEARCH_IMAGE="docker.elastic.co/elasticsearch/elasticsearch:${SELECTED_SEARCH_VERSION}"
    else
      OPENSEARCH_VERSIONS=("2.15.0" "2.11.0" "1.3.0")
      # Only use existing version if it's valid for OpenSearch and type hasn't changed
      if [[ "$EXISTING_SEARCH_ENGINE" == "OpenSearch" ]] && [[ " ${OPENSEARCH_VERSIONS[*]} " =~ " ${EXISTING_SEARCH_VERSION} " ]]; then
        DEFAULT_OPENSEARCH_VERSION="$EXISTING_SEARCH_VERSION"
      else
        DEFAULT_OPENSEARCH_VERSION="2.15.0"
      fi
      SELECTED_SEARCH_VERSION=$(prompt_select "Select OpenSearch version:" "$DEFAULT_OPENSEARCH_VERSION" "${OPENSEARCH_VERSIONS[@]}")
      SELECTED_SEARCH_IMAGE="opensearchproject/opensearch:${SELECTED_SEARCH_VERSION}"
    fi
  fi
  
  msg_info "Search Image: $SELECTED_SEARCH_IMAGE"
  
  # 4. Cache Configuration
  echo ""
  msg_header "4. Cache Configuration"
  
  # Determine if using custom cache image
  USE_CUSTOM_CACHE=false
  if [[ -n "$EXISTING_CACHE_IMAGE" ]] && [[ ! "$EXISTING_CACHE_IMAGE" =~ ^(redis:|eqalpha/keydb:) ]]; then
    USE_CUSTOM_CACHE=true
  fi
  
  if prompt_yes_no "Use custom cache image?" "$([ "$USE_CUSTOM_CACHE" = true ] && echo yes || echo no)"; then
    >&2 echo -n "Enter custom cache image$([ -n "$EXISTING_CACHE_IMAGE" ] && echo " [current: $EXISTING_CACHE_IMAGE]" || echo ""): "
    read SELECTED_CACHE_IMAGE </dev/tty
    # If empty, keep existing
    if [[ -z "$SELECTED_CACHE_IMAGE" ]] && [[ -n "$EXISTING_CACHE_IMAGE" ]]; then
      SELECTED_CACHE_IMAGE="$EXISTING_CACHE_IMAGE"
    fi
    SELECTED_CACHE_TYPE="${EXISTING_CACHE_ENGINE:-Custom}"
    SELECTED_CACHE_VERSION="${EXISTING_CACHE_VERSION:-custom}"
  else
    # Select cache engine type based on existing or default
    CACHE_TYPES=("Redis" "KeyDB")
    DEFAULT_CACHE_TYPE="${EXISTING_CACHE_ENGINE:-Redis}"
    SELECTED_CACHE_TYPE=$(prompt_select "Select cache engine:" "$DEFAULT_CACHE_TYPE" "${CACHE_TYPES[@]}")
    
    # Select version based on type (sorted newest to oldest)
    if [[ "$SELECTED_CACHE_TYPE" == "Redis" ]]; then
      REDIS_VERSIONS=("7.4" "7.2" "6.2")
      # Only use existing version if it's valid for Redis and type hasn't changed
      if [[ "$EXISTING_CACHE_ENGINE" == "Redis" ]] && [[ " ${REDIS_VERSIONS[*]} " =~ " ${EXISTING_CACHE_VERSION} " ]]; then
        DEFAULT_REDIS_VERSION="$EXISTING_CACHE_VERSION"
      else
        DEFAULT_REDIS_VERSION="7.4"
      fi
      SELECTED_CACHE_VERSION=$(prompt_select "Select Redis version:" "$DEFAULT_REDIS_VERSION" "${REDIS_VERSIONS[@]}")
      SELECTED_CACHE_IMAGE="redis:${SELECTED_CACHE_VERSION}-alpine"
    else
      KEYDB_VERSIONS=("6.3.4" "6.3.3")
      # Only use existing version if it's valid for KeyDB and type hasn't changed
      if [[ "$EXISTING_CACHE_ENGINE" == "KeyDB" ]] && [[ " ${KEYDB_VERSIONS[*]} " =~ " ${EXISTING_CACHE_VERSION} " ]]; then
        DEFAULT_KEYDB_VERSION="$EXISTING_CACHE_VERSION"
      else
        DEFAULT_KEYDB_VERSION="6.3.4"
      fi
      SELECTED_CACHE_VERSION=$(prompt_select "Select KeyDB version:" "$DEFAULT_KEYDB_VERSION" "${KEYDB_VERSIONS[@]}")
      SELECTED_CACHE_IMAGE="eqalpha/keydb:alpine_x86_64_v${SELECTED_CACHE_VERSION}"
    fi
  fi
  
  msg_info "Cache Image: $SELECTED_CACHE_IMAGE"
  
  # 5. RabbitMQ Configuration
  echo ""
  msg_header "5. RabbitMQ Configuration"
  
  # Determine if using custom RabbitMQ image
  USE_CUSTOM_RABBITMQ=false
  if [[ -n "$EXISTING_RABBITMQ_IMAGE" ]] && [[ ! "$EXISTING_RABBITMQ_IMAGE" =~ ^rabbitmq: ]]; then
    USE_CUSTOM_RABBITMQ=true
  fi
  
  if prompt_yes_no "Use custom RabbitMQ image?" "$([ "$USE_CUSTOM_RABBITMQ" = true ] && echo yes || echo no)"; then
    >&2 echo -n "Enter custom RabbitMQ image$([ -n "$EXISTING_RABBITMQ_IMAGE" ] && echo " [current: $EXISTING_RABBITMQ_IMAGE]" || echo ""): "
    read SELECTED_RABBITMQ_IMAGE </dev/tty
    # If empty, keep existing
    if [[ -z "$SELECTED_RABBITMQ_IMAGE" ]] && [[ -n "$EXISTING_RABBITMQ_IMAGE" ]]; then
      SELECTED_RABBITMQ_IMAGE="$EXISTING_RABBITMQ_IMAGE"
    fi
    SELECTED_RABBITMQ_VERSION="${EXISTING_RABBITMQ_VERSION:-custom}"
  else
    # Select RabbitMQ version based on existing or default
    RABBITMQ_VERSIONS=("3.13" "3.12" "3.11")
    DEFAULT_RABBITMQ_VERSION="${EXISTING_RABBITMQ_VERSION:-3.13}"
    SELECTED_RABBITMQ_VERSION=$(prompt_select "Select RabbitMQ version:" "$DEFAULT_RABBITMQ_VERSION" "${RABBITMQ_VERSIONS[@]}")
    SELECTED_RABBITMQ_IMAGE="rabbitmq:${SELECTED_RABBITMQ_VERSION}-management-alpine"
  fi
  
  msg_info "RabbitMQ Image: $SELECTED_RABBITMQ_IMAGE"
  
  # Summary
  echo ""
  msg_header "Configuration Summary"
  echo "PHP Version: $SELECTED_PHP"
  echo "Node.js Version: $SELECTED_NODE"
  echo "Composer Version: $SELECTED_COMPOSER"
  echo "PHP Image: $SELECTED_PHP_IMAGE"
  echo "Database: $SELECTED_DB_TYPE $SELECTED_DB_VERSION"
  echo "Database Image: $SELECTED_DB_IMAGE"
  echo "Search Engine: $SELECTED_SEARCH_TYPE $SELECTED_SEARCH_VERSION"
  echo "Search Image: $SELECTED_SEARCH_IMAGE"
  echo "Cache: $SELECTED_CACHE_TYPE $SELECTED_CACHE_VERSION"
  echo "Cache Image: $SELECTED_CACHE_IMAGE"
  echo "RabbitMQ: $SELECTED_RABBITMQ_VERSION"
  echo "RabbitMQ Image: $SELECTED_RABBITMQ_IMAGE"
  echo ""
  
  if prompt_yes_no "Save configuration to $ENV_FILE?" "yes"; then
    # Function to update or add env variable
    update_env_var() {
      local file="$1"
      local key="$2"
      local value="$3"
      
      if [[ -f "$file" ]]; then
        # Check if key exists
        if grep -q "^${key}=" "$file"; then
          # Update existing key (preserve surrounding content)
          sed -i.tmp "s|^${key}=.*|${key}=${value}|" "$file"
          rm -f "${file}.tmp"
        else
          # Add new key
          echo "${key}=${value}" >> "$file"
        fi
      else
        # Create new file with key
        echo "${key}=${value}" >> "$file"
      fi
    }
    
    # Create backup if file exists
    if [[ -f "$ENV_FILE" ]]; then
      cp "$ENV_FILE" "${ENV_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
      msg_info "Backup created: ${ENV_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
    else
      # Create new file with header
      cat > "$ENV_FILE" << EOF
# OroDC Configuration
# Generated by 'orodc init' on $(date)

EOF
    fi
    
    # Update configuration variables (preserves other variables)
    msg_info "Updating configuration..."
    
    # Update header comment if this is a new init
    if ! grep -q "# Last updated:" "$ENV_FILE" 2>/dev/null; then
      sed -i.tmp "1i# Last updated: $(date)" "$ENV_FILE"
      rm -f "${ENV_FILE}.tmp"
    else
      sed -i.tmp "s|^# Last updated:.*|# Last updated: $(date)|" "$ENV_FILE"
      rm -f "${ENV_FILE}.tmp"
    fi
    
    # PHP Configuration
    update_env_var "$ENV_FILE" "DC_ORO_PHP_VERSION" "$SELECTED_PHP"
    update_env_var "$ENV_FILE" "DC_ORO_NODE_VERSION" "$SELECTED_NODE"
    update_env_var "$ENV_FILE" "DC_ORO_COMPOSER_VERSION" "$SELECTED_COMPOSER"
    update_env_var "$ENV_FILE" "DC_ORO_PHP_IMAGE" "$SELECTED_PHP_IMAGE"
    
    # Database Configuration
    update_env_var "$ENV_FILE" "DC_ORO_DATABASE_SCHEMA" "$SELECTED_DB_SCHEMA"
    update_env_var "$ENV_FILE" "DC_ORO_DATABASE_VERSION" "$SELECTED_DB_VERSION"
    update_env_var "$ENV_FILE" "DC_ORO_DATABASE_IMAGE" "$SELECTED_DB_IMAGE"
    
    # Search Engine Configuration
    update_env_var "$ENV_FILE" "DC_ORO_SEARCH_ENGINE" "$SELECTED_SEARCH_TYPE"
    update_env_var "$ENV_FILE" "DC_ORO_SEARCH_VERSION" "$SELECTED_SEARCH_VERSION"
    update_env_var "$ENV_FILE" "DC_ORO_SEARCH_IMAGE" "$SELECTED_SEARCH_IMAGE"
    
    # Cache Configuration
    update_env_var "$ENV_FILE" "DC_ORO_CACHE_ENGINE" "$SELECTED_CACHE_TYPE"
    update_env_var "$ENV_FILE" "DC_ORO_CACHE_VERSION" "$SELECTED_CACHE_VERSION"
    update_env_var "$ENV_FILE" "DC_ORO_CACHE_IMAGE" "$SELECTED_CACHE_IMAGE"
    
    # RabbitMQ Configuration
    update_env_var "$ENV_FILE" "DC_ORO_RABBITMQ_VERSION" "$SELECTED_RABBITMQ_VERSION"
    update_env_var "$ENV_FILE" "DC_ORO_RABBITMQ_IMAGE" "$SELECTED_RABBITMQ_IMAGE"
    
    msg_ok "Configuration saved to $ENV_FILE"
    msg_info "All other variables in the file were preserved"
    msg_info "You can now run 'orodc install' to set up your environment"

    # Register environment in registry after successful init
    if [[ -n "${DC_ORO_NAME:-}" ]] && [[ -n "${DC_ORO_CONFIG_DIR:-}" ]]; then
      debug_log "init: Registering environment name='${DC_ORO_NAME}' path='$PWD' config='${DC_ORO_CONFIG_DIR}'"
      register_environment "${DC_ORO_NAME}" "$PWD" "${DC_ORO_CONFIG_DIR}"
    fi
  else
    msg_info "Configuration not saved"
  fi

  exit 0
fi

# Handle config-refresh command (clear cached compose files and force resync)
if [[ "$first_non_flag_arg" == "config-refresh" ]] || [[ "$first_non_flag_arg" == "refresh-config" ]]; then
  msg_info "Clearing cached compose files from ${DC_ORO_CONFIG_DIR}..."
  
  # Remove compose files from config directory
  if [[ -d "${DC_ORO_CONFIG_DIR}/compose" ]]; then
    rm -rf "${DC_ORO_CONFIG_DIR}/compose"
    msg_ok "Removed cached compose directory"
  fi
  
  if [[ -f "${DC_ORO_CONFIG_DIR}/compose.yml" ]]; then
    rm -f "${DC_ORO_CONFIG_DIR}/compose.yml"
    msg_ok "Removed cached compose.yml"
  fi
  
  # Remove docker directory
  if [[ -d "${DC_ORO_CONFIG_DIR}/docker" ]]; then
    rm -rf "${DC_ORO_CONFIG_DIR}/docker"
    msg_ok "Removed cached docker directory"
  fi
  
  # Remove cached profiles
  if [[ -f "${DC_ORO_CONFIG_DIR}/.cached_profiles" ]]; then
    rm -f "${DC_ORO_CONFIG_DIR}/.cached_profiles"
    msg_ok "Removed cached profiles"
  fi
  
  if [[ -f "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles" ]]; then
    rm -f "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles"
    msg_ok "Removed cached CLI profiles"
  fi
  
  msg_ok "Cache cleared successfully!"
  msg_info "Next orodc command will resync fresh compose files"
  exit 0
fi

if [[ "$first_non_flag_arg" == "purge" ]]; then
  # Handle purge command with proper flag processing
  if [[ -n "${DEBUG:-}" ]]; then
    echo "DEBUG: Processing purge command with flags: ${left_flags[@]} ${left_options[@]}" >&2
  fi
  
  # Show warning and ask for confirmation
  msg_warning "This will permanently delete ALL project data:"
  msg_info "  - All Docker containers for project: ${DC_ORO_NAME}"
  msg_info "  - All Docker volumes (database, uploads, cache)"
  msg_info "  - All project-specific Docker images"
  msg_info "  - Configuration directory: ${DC_ORO_CONFIG_DIR}"
  echo "" >&2
  
  # Check if running in non-interactive mode (CI/CD or piped)
  if [[ ! -t 0 ]] || [[ -n "${ORODC_PURGE_FORCE:-}" ]]; then
    msg_warning "Running in non-interactive mode or ORODC_PURGE_FORCE is set, proceeding without confirmation"
  else
    # Ask for confirmation with validation
    if ! confirm_yes_no "Are you sure you want to continue?" "no"; then
      msg_info "Purge cancelled"
      exit 0
    fi
  fi
  
  echo "" >&2
  
  if [[ -f "${DC_ORO_CONFIG_DIR}/compose.yml" ]]; then
    down_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} -f ${DC_ORO_CONFIG_DIR}/compose.yml down -v"
  else
    down_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} down -v"
  fi
  
  # Use spinner for down command
  run_with_spinner "Stopping and removing containers, volumes" "$down_cmd"

  ${DOCKER_BIN} volume ls | awk '{ print $2 }' | tail +2 | grep '^'${DC_ORO_NAME}'_appcode$' > /dev/null && {
    msg_info "Removing appcode volume"
    ${DOCKER_BIN} volume rm ${DC_ORO_NAME}'_appcode' >/dev/null 2>&1
    msg_ok "Appcode volume removed"
  }
  
  # Remove project-specific Docker images
  PROJECT_IMAGES=$(${DOCKER_BIN} images --format "{{.Repository}}:{{.Tag}}" | grep "^${DC_ORO_NAME}-")
  if [[ -n "$PROJECT_IMAGES" ]]; then
    IMAGE_COUNT=$(echo "$PROJECT_IMAGES" | wc -l)
    msg_info "Removing ${IMAGE_COUNT} project image(s)"
    echo "$PROJECT_IMAGES" | while read -r image; do
      if [[ -n "$image" ]]; then
        ${DOCKER_BIN} rmi "$image" >/dev/null 2>&1 || true
      fi
    done
    msg_ok "Project images removed"
  fi

  if [[ -d "${DC_ORO_CONFIG_DIR}" ]]; then
    msg_info "Removing configuration directory"
    rm -rf "${DC_ORO_CONFIG_DIR}"
    msg_ok "Configuration directory removed"
  fi
  
  echo "" >&2
  msg_ok "Project ${DC_ORO_NAME} purged successfully"
  exit 0
fi

if [[ "$first_non_flag_arg" == "down" ]] && [[ -f "${DC_ORO_CONFIG_DIR}/compose.yml" ]] && [[ -s "${DC_ORO_CONFIG_DIR}/compose.yml" ]]; then
  DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN} -f ${DC_ORO_CONFIG_DIR}/compose.yml"
  # Combine all arguments into a single string for proper execution
  full_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} ${args[*]} ${right_flags[*]} ${right_options[*]}"
  
  run_with_spinner "Stopping services" "$full_cmd"
  exit $?
fi

# Handle docker compose commands with all variables set
if [[ "$is_docker_compose_cmd" == "true" ]]; then
  # Generate config file only if it doesn't exist or if it's a management command (up, down, purge, etc.)
  if [[ ! -f "${DC_ORO_CONFIG_DIR}/compose.yml" ]] || [[ "${args[0]}" =~ ^(up|down|purge|build|pull|push|restart|start|stop|kill|rm|create)$ ]]; then
    DC_ORO_NAME="$DC_ORO_NAME" bash -c "${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} config" > "${DC_ORO_CONFIG_DIR}/compose.yml" 2>/dev/null || true

    # Register environment after creating compose.yml
    if [[ -f "${DC_ORO_CONFIG_DIR}/compose.yml" ]] && [[ -n "${DC_ORO_NAME:-}" ]] && [[ -n "${DC_ORO_CONFIG_DIR:-}" ]]; then
      debug_log "compose.yml created: Registering environment name='${DC_ORO_NAME}' path='$PWD' config='${DC_ORO_CONFIG_DIR}'"
      register_environment "${DC_ORO_NAME}" "$PWD" "${DC_ORO_CONFIG_DIR}"
    fi
  fi
  # For docker compose commands, proper order is: command flags services
  # Extract command (first element) and services (rest of elements)
  docker_cmd="${args[0]}"
  docker_services="${args[*]:1}"

  # Check if we're in a project for commands that require it
  if [[ "$docker_cmd" =~ ^(up|down|start|stop|restart|ps|logs|exec|run)$ ]]; then
    if ! check_in_project; then
      exit 1
    fi
  fi

  # Handle 'up' command with separate build and start phases
  if [[ "$docker_cmd" == "up" ]]; then
    # Get previous timing for statistics only
    prev_timing=$(get_previous_timing "up")
    
    # Check if we should skip build phase
    skip_build=false
    if [[ " ${right_flags[*]} " =~ " --no-build " ]]; then
      skip_build=true
    fi
    
    # If DEBUG or VERBOSE, run without timing wrapper
    if [[ -n "${DEBUG:-}" ]] || [[ -n "${VERBOSE:-}" ]]; then
      # Phase 1: Build images (unless --no-build is specified)
      if [[ "$skip_build" == "false" ]]; then
        build_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} build ${docker_services}"
        DC_ORO_NAME="$DC_ORO_NAME" bash -c "$build_cmd" || exit $?
      fi
      
      # Phase 2: Start services
      up_flags=()
      for flag in "${right_flags[@]}"; do
        if [[ "$flag" != "--build" ]]; then
          up_flags+=("$flag")
        fi
      done
      
      up_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} up ${up_flags[*]} ${right_options[*]} ${docker_services}"
      DC_ORO_NAME="$DC_ORO_NAME" bash -c "$up_cmd" || exit $?
      show_service_urls
      exit 0
    fi
    
    # Record start time for entire up operation
    up_start_time=$(date +%s)
    
    # Phase 1: Build images (unless --no-build is specified)
    if [[ "$skip_build" == "false" ]]; then
      build_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} build ${docker_services}"
      DC_ORO_NAME="$DC_ORO_NAME" run_with_spinner "Building services" "$build_cmd" || exit $?
    fi
    
    # Phase 2: Start services
    up_flags=()
    has_wait_flag=false
    for flag in "${right_flags[@]}"; do
      if [[ "$flag" != "--build" ]]; then
        up_flags+=("$flag")
        if [[ "$flag" == "--wait" ]]; then
          has_wait_flag=true
        fi
      fi
    done
    
    # Add --wait flag if -d is present and --wait is not already there
    # This ensures we wait for health checks before returning
    if [[ " ${up_flags[*]} " =~ " -d " ]] && [[ "$has_wait_flag" == "false" ]]; then
      up_flags+=("--wait")
    fi
    
    up_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} up ${up_flags[*]} ${right_options[*]} ${docker_services}"
    DC_ORO_NAME="$DC_ORO_NAME" run_with_spinner "Starting services" "$up_cmd" || exit $?
    
    # Calculate total up time and save
    up_end_time=$(date +%s)
    up_duration=$((up_end_time - up_start_time))
    
    # Save timing
    save_timing "up" "$up_duration"
    
    msg_ok "Services started in ${up_duration}s"
    
    show_service_urls
    exit 0
  fi
  
  # Handle 'build' command
  if [[ "$docker_cmd" == "build" ]]; then
    full_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} ${docker_cmd} ${right_flags[*]} ${right_options[*]} ${docker_services}"
    DC_ORO_NAME="$DC_ORO_NAME" run_with_spinner "Building services" "$full_cmd"
    exit $?
  fi
  
  # Handle all other docker compose commands
  full_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} ${docker_cmd} ${right_flags[*]} ${right_options[*]} ${docker_services}"
  DC_ORO_NAME="$DC_ORO_NAME" bash -c "$full_cmd"
  exit $?
fi

# Handle bash commands by running them in CLI container
if [[ "$first_non_flag_arg" == "bash" ]]; then
  # Generate config file only if it doesn't exist
  if [[ ! -f "${DC_ORO_CONFIG_DIR}/compose.yml" ]]; then
    DC_ORO_NAME="$DC_ORO_NAME" bash -c "${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} config" > "${DC_ORO_CONFIG_DIR}/compose.yml" 2>/dev/null || true
  fi
  
  # For bash commands, use docker compose run with cli container
  # Pass all arguments after "bash" to the bash command in the container
  bash_args=("${args[@]:1}")
  
  # Build the run command with proper argument handling
  if [[ ${#bash_args[@]} -gt 0 ]]; then
    # If there are arguments after bash, pass them through
    full_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run --rm cli bash ${bash_args[*]} ${right_flags[*]} ${right_options[*]}"
  else
    # If no arguments after bash, just run interactive bash
    full_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run --rm cli bash ${right_flags[*]} ${right_options[*]}"
  fi
  
  DC_ORO_NAME="$DC_ORO_NAME" bash -c "$full_cmd"
  exit $?
fi

# Generate config file only if it doesn't exist or if it's a management command (up, down, purge, etc.)
if [[ ! -f "${DC_ORO_CONFIG_DIR}/compose.yml" ]] || [[ "${args[0]}" =~ ^(up|down|purge|build|pull|push|restart|start|stop|kill|rm|create)$ ]]; then
  DC_ORO_NAME="$DC_ORO_NAME" bash -c "${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} config" > "${DC_ORO_CONFIG_DIR}/compose.yml" 2>/dev/null || true
fi
# Combine all arguments into a single string for proper execution  
full_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} ${args[*]} ${right_flags[*]} ${right_options[*]}"


DC_ORO_NAME="$DC_ORO_NAME" bash -c "$full_cmd"
exit $?
