#!/bin/bash
set -e
if [ "$DEBUG" ]; then set -x; fi

# Setup logging only when OroDC is used as PHP binary
setup_php_logging() {
  mkdir -p /tmp/.orodc
  local log_file="/tmp/.orodc/$(basename $0).$(echo "$@" | md5sum - | awk '{ print $1 }').log"
  local err_file="/tmp/.orodc/$(basename $0).$(echo "$@" | md5sum - | awk '{ print $1 }').err"
  touch "$log_file" "$err_file"
  exec 1> >(tee "$log_file")
  exec 2> >(tee "$err_file")
}

# Function to display informational messages with consistent formatting
msg_info() {
  >&2 echo -e "\033[36m==> $1\033[0m"
}

# Function to display warning messages
msg_warning() {
  >&2 echo -e "\033[31m==> Warning: $1\033[0m"
}

# Function to display success messages
msg_ok() {
  >&2 echo -e "\033[32m==> $1\033[0m"
}

# Function to display error messages
msg_error() {
  >&2 echo -e "\033[31m==> Error: $1\033[0m"
}

# Function to display header messages (bold blue)
msg_header() {
  >&2 echo -e "\033[1;34m==> $1\033[0m"
}

# Function to display highlighted text (bold white)
msg_highlight() {
  >&2 echo -e "\033[1;37m$1\033[0m"
}

# Backward compatibility aliases
echo_info() { msg_info "$*"; }
echo_ok() { msg_ok "$*"; }
echo_warn() { msg_warning "$*"; }
echo_error() { msg_error "$*"; }
echo_header() { msg_header "$*"; }

# Function to resolve binary location with error handling
# Usage: resolve_bin "binary_name" ["install_instructions"]
resolve_bin() {
  local bin_name="$1"
  local install_msg="${2:-}"
  local found_path=""
  
  # Try PATH first
  if command -v "$bin_name" >/dev/null 2>&1; then
    found_path=$(command -v "$bin_name")
    if [ "$DEBUG" ]; then echo "DEBUG: Found $bin_name in PATH: $found_path" >&2; fi
    echo "$found_path"
    return 0
  fi
  
  # Try common locations for specific binaries
  case "$bin_name" in
    "brew")
      local brew_paths=("/opt/homebrew/bin/brew" "/usr/local/bin/brew" "/home/linuxbrew/.linuxbrew/bin/brew")
      for brew_path in "${brew_paths[@]}"; do
        if [[ -x "$brew_path" ]]; then
          found_path="$brew_path"
          msg_warning "$bin_name found at $found_path but not in PATH"
          echo "   Add to PATH: export PATH=\"$(dirname "$found_path"):\$PATH\"" >&2
          echo "$found_path"
          return 0
        fi
      done
      ;;
    "docker")
      local docker_paths=("/usr/bin/docker" "/usr/local/bin/docker" "/snap/bin/docker")
      for docker_path in "${docker_paths[@]}"; do
        if [[ -x "$docker_path" ]]; then
          found_path="$docker_path"
          msg_warning "$bin_name found at $found_path but not in PATH"
          echo "$found_path"
          return 0
        fi
      done
      ;;
  esac
  
  # Not found - show error and exit
  msg_error "$bin_name not found in PATH or common locations"
  
  if [[ -n "$install_msg" ]]; then
    echo "   $install_msg"
  else
    # Default install instructions
    case "$bin_name" in
      "docker")
        echo "   Install: curl -fsSL https://get.docker.com | sh"
        echo "   Or visit: https://docs.docker.com/engine/install/"
        ;;
      "brew")
        echo "   Install: /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
        echo "   Then add to PATH: export PATH=\"/home/linuxbrew/.linuxbrew/bin:\$PATH\""
        ;;
      "rsync")
        echo "   Install: sudo apt-get install rsync  # Ubuntu/Debian"
        echo "   Or: brew install rsync"
        ;;
      "jq")
        echo "   Install: sudo apt-get install jq  # Ubuntu/Debian"
        echo "   Or: brew install jq"
        ;;
      *)
        echo "   Please install $bin_name and ensure it's in your PATH"
        ;;
    esac
  fi
  
  echo
  msg_error "OroDC cannot continue without $bin_name"
  exit 1
}
echo_highlight() { msg_highlight "$*"; }

# Save original arguments before any processing
original_args=("$@")

left_flags=()
right_flags=()
left_options=()
right_options=()
args=()

args_input=("$@")

# Save and load XDEBUG_MODE* environment variables
export PWD=$(pwd)
export DC_ORO_NAME=${DC_ORO_NAME-$(basename $(pwd))}
# CRITICAL: Set Docker Compose project name to match OroDC project name
# This ensures volumes and networks use consistent naming with DC_ORO_NAME
export COMPOSE_PROJECT_NAME="$DC_ORO_NAME"
# Allow override of config directory via environment variable
if [[ -z "${DC_ORO_CONFIG_DIR}" ]]; then
  export DC_ORO_CONFIG_DIR="$HOME/.$(basename $0)/${DC_ORO_NAME}"
fi

if [[ ! -d "${DC_ORO_CONFIG_DIR}" ]]; then
    mkdir -p "${DC_ORO_CONFIG_DIR}"
fi

XDEBUG_ENV_FILE="${DC_ORO_CONFIG_DIR}/.xdebug_env"

# Save XDEBUG_MODE* variables if they exist in environment
if [[ -n "${XDEBUG_MODE:-}" ]] || [[ -n "${XDEBUG_MODE_CLI:-}" ]] || [[ -n "${XDEBUG_MODE_FPM:-}" ]] || [[ -n "${XDEBUG_MODE_CONSUMER:-}" ]]; then
  {
    [[ -n "${XDEBUG_MODE:-}" ]] && echo "export XDEBUG_MODE=\"${XDEBUG_MODE}\""
    [[ -n "${XDEBUG_MODE_CLI:-}" ]] && echo "export XDEBUG_MODE_CLI=\"${XDEBUG_MODE_CLI}\""
    [[ -n "${XDEBUG_MODE_FPM:-}" ]] && echo "export XDEBUG_MODE_FPM=\"${XDEBUG_MODE_FPM}\""
    [[ -n "${XDEBUG_MODE_CONSUMER:-}" ]] && echo "export XDEBUG_MODE_CONSUMER=\"${XDEBUG_MODE_CONSUMER}\""
  } > "${XDEBUG_ENV_FILE}"
fi

# Load XDEBUG_MODE* variables from file if they don't exist in environment
if [[ -f "${XDEBUG_ENV_FILE}" ]]; then
  source "${XDEBUG_ENV_FILE}"
fi

# Set default value for XDEBUG_MODE if not set
[[ -z "${XDEBUG_MODE:-}" ]] && export XDEBUG_MODE="off"

# Set fallback values for XDEBUG_MODE_* variables if not set but XDEBUG_MODE exists
if [[ -n "${XDEBUG_MODE:-}" ]]; then
  [[ -z "${XDEBUG_MODE_CLI:-}" ]] && export XDEBUG_MODE_CLI="${XDEBUG_MODE}"
  [[ -z "${XDEBUG_MODE_FPM:-}" ]] && export XDEBUG_MODE_FPM="${XDEBUG_MODE}"
  [[ -z "${XDEBUG_MODE_CONSUMER:-}" ]] && export XDEBUG_MODE_CONSUMER="${XDEBUG_MODE}"
fi

# Handle version command (only "version", not --version)
if [[ "$1" == "version" ]]; then
  # Try to find and read version from Formula file
  FORMULA_VERSION=""
  FORMULA_FILE=""
  
  # Use find to locate Formula file, starting from script directory and going up
  SCRIPT_DIR="$(dirname "$0")"
  FORMULA_FILE=$(find "$SCRIPT_DIR" -name "docker-compose-oroplatform.rb" -type f 2>/dev/null | head -1)
  
  # If not found relative to script, try brew repository
  if [[ -z "$FORMULA_FILE" ]] && command -v brew >/dev/null 2>&1; then
    BREW_REPO=$(brew --repository 2>/dev/null)
    if [[ -n "$BREW_REPO" ]]; then
      FORMULA_FILE=$(find "$BREW_REPO" -name "docker-compose-oroplatform.rb" -type f 2>/dev/null | head -1)
    fi
  fi
  
  # Extract version from Formula file
  if [[ -n "$FORMULA_FILE" && -f "$FORMULA_FILE" ]]; then
    FORMULA_VERSION=$(grep -o 'version "[^"]*"' "$FORMULA_FILE" 2>/dev/null | sed 's/version "\(.*\)"/\1/')
  fi
  
  # Output version or fallback
  if [[ -n "$FORMULA_VERSION" ]]; then
    echo "orodc version $FORMULA_VERSION"
  else
    echo "orodc version 0.8.3 (fallback)"
  fi
  exit 0
fi

# Handle help/man command
if [[ "$1" == "help" ]] || [[ "$1" == "man" ]]; then
  # Try to find README.md file
  README_FILE=""
  SCRIPT_DIR="$(dirname "$0")"
  
  # Look for README.md in various locations
  # 1. Relative to script directory (development)
  if [[ -f "$SCRIPT_DIR/../README.md" ]]; then
    README_FILE="$SCRIPT_DIR/../README.md"
  elif [[ -f "$SCRIPT_DIR/README.md" ]]; then
    README_FILE="$SCRIPT_DIR/README.md"
  elif [[ -f "$SCRIPT_DIR/../../README.md" ]]; then
    README_FILE="$SCRIPT_DIR/../../README.md"
  fi
  
  # 2. Try to find in Homebrew tap directory
  if [[ -z "$README_FILE" ]] && command -v brew >/dev/null 2>&1; then
    BREW_REPO=$(brew --repository 2>/dev/null)
    if [[ -n "$BREW_REPO" ]]; then
      TAP_README="$BREW_REPO/Library/Taps/digitalspacestdio/homebrew-docker-compose-oroplatform/README.md"
      if [[ -f "$TAP_README" ]]; then
        README_FILE="$TAP_README"
      fi
    fi
  fi
  
  # If README found, display it without pager (always use cat)
  if [[ -n "$README_FILE" && -f "$README_FILE" ]]; then
    echo "==> OroDC Documentation"
    echo
    cat "$README_FILE"
  else
    echo "==> OroDC Help"
    echo
    msg_highlight "Documentation not found locally. Please visit:"
    echo "   https://github.com/digitalspacestdio/homebrew-docker-compose-oroplatform"
    echo
    msg_highlight "Quick Commands:"
    echo "   orodc version                    # Show version"
    echo "   orodc install && orodc up -d     # Setup and start"
    echo "   orodc --version                  # Check PHP version"
    echo "   orodc psql -l                    # List databases"
    echo "   orodc tests install              # Setup test environment"
    echo
    echo "ðŸ’¡ For full documentation, run: brew info docker-compose-oroplatform"
  fi
  exit 0
fi

# Function to get first non-flag argument
get_first_non_flag_arg() {
  local args=("$@")
  for arg in "${args[@]}"; do
    if [[ "$arg" != -* ]]; then
      echo "$arg"
      return 0
    fi
  done
  echo "php"
  return 0
}

# Check if first argument is a docker compose command
# Only docker compose commands need left/right argument parsing
is_compose_command() {
  local cmd="$1"
  local compose_commands="build|config|cp|create|down|events|exec|export|images|kill|logs|ls|pause|port|ps|pull|push|restart|rm|run|scale|start|stats|stop|top|unpause|up|version|volumes|wait|watch"
  echo "$cmd" | grep -qE "^($compose_commands)$"
}

# Find first non-flag argument to determine parsing needs
temp_first_non_flag_arg=""
if [[ $# -gt 0 ]]; then
  for arg in "$@"; do
    if [[ "$arg" != -* ]]; then
      temp_first_non_flag_arg="$arg"
      break
    fi
  done
fi

# If no command found (only flags), treat as PHP command
if [[ -z "$temp_first_non_flag_arg" && $# -gt 0 ]]; then
  temp_first_non_flag_arg="php"
fi

# Check if we need argument parsing
# Parse for docker compose commands OR commands with docker compose flags
has_docker_compose_flags=false
for arg in "$@"; do
  if [[ "$arg" =~ ^--profile(=.*)?$ ]] || [[ "$arg" =~ ^--env-file(=.*)?$ ]] || [[ "$arg" =~ ^--project-name(=.*)?$ ]] || [[ "$arg" =~ ^--file(=.*)?$ ]] || [[ "$arg" =~ ^-f$ ]]; then
    has_docker_compose_flags=true
    if [ "$DEBUG" ]; then echo "DEBUG: Found docker compose flag: $arg" >&2; fi
    break
  fi
done

if [ "$DEBUG" ]; then echo "DEBUG: has_docker_compose_flags=$has_docker_compose_flags, temp_first_non_flag_arg=$temp_first_non_flag_arg" >&2; fi

if [[ $# -gt 0 ]] && (is_compose_command "$temp_first_non_flag_arg" || [[ "$temp_first_non_flag_arg" == "purge" ]] || [[ "$temp_first_non_flag_arg" == "php" ]] || [[ "$has_docker_compose_flags" == "true" ]]); then
  NEEDS_ARG_PARSING=true
  if [ "$DEBUG" ]; then echo "DEBUG: NEEDS_ARG_PARSING=true" >&2; fi
else
  NEEDS_ARG_PARSING=false
  if [ "$DEBUG" ]; then echo "DEBUG: NEEDS_ARG_PARSING=false" >&2; fi
  # Save original arguments for non-compose commands
  non_compose_args=("$@")
fi




# Only parse arguments for docker compose commands or commands with docker compose flags
if [[ "$NEEDS_ARG_PARSING" == "true" ]]; then
  i=0
  saw_first_arg=false
  
  # Special case: if first argument is 'php' OR no non-flag arguments, treat all flags as right flags
  if [ "$DEBUG" ]; then echo "DEBUG: Checking special case: args_input[0]='${args_input[0]:-}', temp_first_non_flag_arg='$temp_first_non_flag_arg'" >&2; fi
  if [[ ${#args_input[@]} -gt 0 && "${args_input[0]}" == "php" ]] || [[ "$temp_first_non_flag_arg" == "php" ]]; then
    if [ "$DEBUG" ]; then echo "DEBUG: Setting saw_first_arg=true for PHP command" >&2; fi
    saw_first_arg=true
  fi

  while [[ $i -lt ${#args_input[@]} ]]; do
    arg="${args_input[$i]}"
    next="${args_input[$((i + 1))]:-}"

    if [[ "$arg" == --*=* ]]; then
      [[ -n "${DEBUG:-}" ]] && echo "DEBUG: Found --*=* flag: $arg, saw_first_arg=$saw_first_arg" >&2
      if [[ "$saw_first_arg" == false ]]; then
        left_options+=("$arg")
      else
        right_options+=("$arg")
      fi
      i=$((i + 1))

    elif [[ "$arg" == --* && "$next" != -* && -n "$next" ]]; then
      if [[ "$saw_first_arg" == false ]]; then
        left_options+=("$arg" "$next")
      else
        right_options+=("$arg" "$next")
      fi
      i=$((i + 2))

    elif [[ "$arg" == -* ]]; then
      if [[ "$saw_first_arg" == false ]]; then
        left_flags+=("$arg")
      else
        right_flags+=("$arg")
      fi
      i=$((i + 1))

    else
      args+=("$arg")
      saw_first_arg=true
      i=$((i + 1))
    fi
  done
  # Get first non-flag argument for command detection (after args is properly set)
  first_non_flag_arg=$(get_first_non_flag_arg "${args[@]}")
else
  # For non-compose commands, set args to original arguments without parsing
  args=("${non_compose_args[@]}")
  # Get first non-flag argument for command detection (after args is properly set)
  first_non_flag_arg=$(get_first_non_flag_arg "${args[@]}")
fi

# Ensure first_non_flag_arg is always set regardless of parsing mode
if [[ -z "${first_non_flag_arg:-}" ]]; then
  first_non_flag_arg=$(get_first_non_flag_arg "${args[@]}")
fi

if [[ -n "${DEBUG:-}" ]]; then
  echo "DEBUG: first_non_flag_arg='$first_non_flag_arg', args=(${args[*]})" >&2
fi


# Resolve critical dependencies with helpful error messages
BREW_BIN=$(resolve_bin "brew")
DOCKER_BIN=$(resolve_bin "docker")

# Check docker compose specifically (it's a subcommand, not a separate binary)
if ! "$DOCKER_BIN" compose version >/dev/null 2>&1; then
  msg_error "Docker Compose not found or outdated"
  echo "   Docker Compose V2 is required (docker compose, not docker-compose)"
  echo "   Update Docker: https://docs.docker.com/compose/install/"
  echo
  msg_error "OroDC cannot continue without Docker Compose"
  exit 1
fi

# Set up Homebrew environment if needed
if [[ "$BREW_BIN" != *"/usr/local/bin/brew"* ]] && [[ "$BREW_BIN" != *"/opt/homebrew/bin/brew"* ]]; then
  # For non-standard locations, ensure environment is set up
  eval "$("$BREW_BIN" shellenv)" 2>/dev/null || true
fi

DIR=$("$BREW_BIN" --prefix docker-compose-oroplatform)/share/docker-compose-oroplatform

# Try to get rsync from Homebrew, fallback to system rsync
RSYNC_BIN="$("$BREW_BIN" --prefix rsync)/bin/rsync"
if [[ ! -x "$RSYNC_BIN" ]]; then
  RSYNC_BIN=$(resolve_bin "rsync")
fi

# Set up Docker Compose command
DOCKER_COMPOSE_BIN="$DOCKER_BIN compose"
# DOCKER_COMPOSE_BIN_CMD is the main command that gets built up with compose files  
# This variable is reused throughout the script and in the test merging logic
DOCKER_COMPOSE_BIN_CMD="$DOCKER_COMPOSE_BIN"
DOCKER_COMPOSE_VERSION=$($DOCKER_COMPOSE_BIN_CMD version | grep -E '[0-9]+\.[0-9]+\.[0-9]+' -o | head -1 |awk -F. '{ print $1 }')
${RSYNC_BIN} -r "${DIR}/compose/" "${DC_ORO_CONFIG_DIR}/"

# Setup certificates synchronization
setup_project_certificates() {
  local project_crt_dir="${PWD}/.crt"
  local build_crt_dir="${DC_ORO_CONFIG_DIR}/docker/project-php-node-symfony/.crt"
  
  # Remove old certificates directory
  rm -rf "${build_crt_dir}"
  
  # Check if project has certificates
  if [[ -d "${project_crt_dir}" ]]; then
    local cert_count=$(find "${project_crt_dir}" -type f \( -name "*.crt" -o -name "*.pem" \) 2>/dev/null | wc -l)
    
    if [[ "${cert_count}" -gt 0 ]]; then
      msg_info "Found ${cert_count} certificate(s) in ${project_crt_dir}"
      echo "   Preparing project build context with custom certificates..."
      
      # Create .crt directory in build context
      mkdir -p "${build_crt_dir}"
      
      # Copy certificates to build context
      find "${project_crt_dir}" -type f \( -name "*.crt" -o -name "*.pem" \) -exec cp {} "${build_crt_dir}/" \;
      
      msg_ok "Certificates prepared for Docker build"
    else
      msg_info ".crt directory exists but contains no certificate files"
    fi
  else
    # Skip certificate message - building standard image silently
    true
  fi
}

# Call certificates setup after compose files are synced
setup_project_certificates
# Build the compose command by adding compose files in the correct order
# This logic is reused in test merging - DO NOT duplicate this logic elsewhere
if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose.yml" ]]; then
  DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose.yml"
fi

# Profile caching functions
save_profiles() {
  local profiles=()
  local cli_profiles=()
  local i=0
  
  # Extract --profile arguments from left_flags and left_options
  while [[ $i -lt ${#left_flags[@]} ]]; do
    if [[ "${left_flags[$i]}" == --profile=* ]]; then
      local profile_value="${left_flags[$i]#--profile=}"
      if [[ "$profile_value" == "database-cli" ]] || [[ "$profile_value" == "php-cli" ]]; then
        cli_profiles+=("${left_flags[$i]}")
      else
        profiles+=("${left_flags[$i]}")
      fi
    fi
    i=$((i + 1))
  done
  
  i=0
  while [[ $i -lt ${#left_options[@]} ]]; do
    if [[ "${left_options[$i]}" == "--profile" ]]; then
      local profile_value="${left_options[$((i + 1))]}"
      if [[ "$profile_value" == "database-cli" ]] || [[ "$profile_value" == "php-cli" ]]; then
        cli_profiles+=("--profile" "$profile_value")
      else
        profiles+=("--profile" "$profile_value")
      fi
      i=$((i + 2))
    else
      i=$((i + 1))
    fi
  done
  
  # Save regular profiles to cache file
  if [[ ${#profiles[@]} -gt 0 ]]; then
    printf '%s\n' "${profiles[@]}" > "${DC_ORO_CONFIG_DIR}/.cached_profiles"
  else
    # Remove cache file if no profiles
    [[ -f "${DC_ORO_CONFIG_DIR}/.cached_profiles" ]] && rm -f "${DC_ORO_CONFIG_DIR}/.cached_profiles" || true
  fi
  
  # Save CLI profiles to separate cache file
  if [[ ${#cli_profiles[@]} -gt 0 ]]; then
    printf '%s\n' "${cli_profiles[@]}" > "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles"
  else
    # Remove CLI cache file if no CLI profiles
    [[ -f "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles" ]] && rm -f "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles" || true
  fi
  return 0
}

load_cached_profiles() {
  local cached_profiles=()
  local include_cli_profiles=false
  
  # Check if we need CLI profiles based on the command
  if [[ ${#args[@]} -gt 0 ]]; then
    # Use the actual first non-flag argument for command detection
    local cmd_to_check="$first_non_flag_arg"
    
    # Commands that always need CLI profiles (for proper cleanup)
    if [[ "$cmd_to_check" =~ ^(down|purge)$ ]]; then
      include_cli_profiles=true
    # Commands that need database-cli profile
    elif [[ "$cmd_to_check" =~ ^(mysql|psql|database-cli)$ ]] || \
       echo "$cmd_to_check" | grep -i 'import.*db\|export.*db\|dump.*db' > /dev/null; then
      include_cli_profiles=true
    # Commands that need php-cli profile (already handled by auto-redirect, but for completeness)
    elif [[ "$cmd_to_check" =~ ^(cli|php|composer|bin/)$ ]] || \
       [[ "$cmd_to_check" == *.php ]] || \
       [[ "$cmd_to_check" == -* ]]; then
      include_cli_profiles=true
    fi
  fi
  
  # Load regular profiles
  if [[ -f "${DC_ORO_CONFIG_DIR}/.cached_profiles" ]]; then
    while IFS= read -r line; do
      cached_profiles+=("$line")
    done < "${DC_ORO_CONFIG_DIR}/.cached_profiles"
    
    if [[ ${#cached_profiles[@]} -gt 0 ]]; then
      # Add cached profiles to left_options (they will be applied to DOCKER_COMPOSE_BIN_CMD)
      left_options=("${cached_profiles[@]}" "${left_options[@]}")
    fi
  fi
  
  # Load CLI profiles only when needed
  if [[ "$include_cli_profiles" == "true" ]] && [[ -f "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles" ]]; then
    local cached_cli_profiles=()
    while IFS= read -r line; do
      cached_cli_profiles+=("$line")
    done < "${DC_ORO_CONFIG_DIR}/.cached_cli_profiles"
    
    if [[ ${#cached_cli_profiles[@]} -gt 0 ]]; then
      # Add CLI profiles to left_options
      left_options=("${cached_cli_profiles[@]}" "${left_options[@]}")
    fi
  fi
}

load_env_safe() {
  local env_file="$1"

  # if the file exists
  if [[ -f "$env_file" ]]; then
    # Read the file line by line
    while IFS= read -r line || [[ -n "$line" ]]; do
      # Trim leading/trailing whitespace (safe)
      line="${line#"${line%%[![:space:]]*}"}"
      line="${line%"${line##*[![:space:]]}"}"

      # Skip empty lines and comments
      [[ -z "$line" || "$line" == \#* ]] && continue

      # Skip lines without =
      [[ "$line" != *=* ]] && continue

      local key="${line%%=*}"
      local value="${line#*=}"

      # Trim key and value safely
      key="${key#"${key%%[![:space:]]*}"}"
      key="${key%"${key##*[![:space:]]}"}"
      value="${value#"${value%%[![:space:]]*}"}"
      value="${value%"${value##*[![:space:]]}"}"

      # Strip existing quotes from value
      value="${value%\"}"
      value="${value#\"}"
      value="${value%\'}"
      value="${value#\'}"

      # Export the variable safely
      export "$key=$value"
    done < "$env_file"
  fi
}

parse_dsn_uri() {
  local uri="$1"
  local name="$2"
  local prefix="$3"

  [[ -n "$uri" && -n "$name" ]] || return 0

  local host_alias
  host_alias=$(echo "$name" | tr '[:upper:]' '[:lower:]')

  local var_prefix=""
  if [[ -n "$prefix" ]]; then
    var_prefix="$(echo "$prefix" | tr '[:lower:]' '[:upper:]')_"
  fi
  var_prefix+=$(echo "$name" | tr '[:lower:]' '[:upper:]')_

  local schema rest
  if [[ "$uri" == *"://"* ]]; then
    schema="${uri%%://*}"
    rest="${uri#*://}"
  elif [[ "$uri" == *: ]]; then
    schema="${uri%:}"
    rest=""
  else
    schema="$uri"
    rest=""
  fi

  local query=""
  if [[ "$rest" == *\?* ]]; then
    query="${rest#*\?}"
    rest="${rest%%\?*}"
  fi

  local user="" password="" host="" port="" dbname=""

  # Special case: SQLite
  if [[ "$schema" == "sqlite" ]]; then
    if [[ "$uri" == "sqlite::memory:" ]]; then
      dbname=":memory:"
    else
      local sqlite_path="${uri#sqlite://}"
      dbname="${sqlite_path%%\?*}"
    fi

    eval "export ${var_prefix}SCHEMA=\"\$schema\""
    eval "export ${var_prefix}DBNAME=\"\$dbname\""
    eval "export ${var_prefix}QUERY=\"\$query\""
    eval "export ${var_prefix}URI=\"\$uri\""
    return
  fi

  # If rest includes @, extract user/password
  if [[ "$rest" == *@* ]]; then
    local userinfo="${rest%%@*}"
    rest="${rest#*@}"
    user="${userinfo%%:*}"
    password="${userinfo#*:}"
    [[ "$user" == "$password" ]] && password="app"
  fi

  # Extract host, port, dbname
  if [[ "$rest" == *:* ]]; then
    host="${rest%%:*}"
    port="${rest#*:}"
    if [[ "$port" == */* ]]; then
      dbname="${port#*/}"
      port="${port%%/*}"
    fi
  elif [[ "$rest" == */* ]]; then
    host="${rest%%/*}"
    dbname="${rest#*/}"
  elif [[ -n "$rest" ]]; then
    host="$rest"
  fi

  #[[ "$host" == "localhost" || "$host" == "127.0.0.1" ]] && host="$host_alias"
  # always use container host for services
  host="$host_alias"

  # Reconstruct URI only if it's not a simple scheme:
  local clean_uri=""
  if [[ "$schema" == "sqlite" && "$dbname" == ":memory:" ]]; then
    clean_uri="sqlite::memory:"
  elif [[ "$schema" == "sqlite" ]]; then
    clean_uri="sqlite://$dbname"
  elif [[ "$schema" == "dbal" && -z "$rest" ]]; then
    clean_uri="${schema}:"
  else
    clean_uri="${schema}://"
    [[ -n "$user" ]] && clean_uri+="${user}"
    [[ -n "$password" ]] && clean_uri+=":${password}"
    [[ -n "$user" || -n "$password" ]] && clean_uri+="@"
    clean_uri+="${host}"
    [[ -n "$port" ]] && clean_uri+=":${port}"
    [[ -n "$dbname" ]] && clean_uri+="/${dbname}"
    [[ -n "$query" ]] && clean_uri+="?${query}"
  fi

  # Export everything
  eval "export ${var_prefix}SCHEMA=\"\$schema\""
  eval "export ${var_prefix}USER=\"\$user\""
  eval "export ${var_prefix}PASSWORD=\"\$password\""
  eval "export ${var_prefix}HOST=\"\$host\""
  eval "export ${var_prefix}PORT=\"\$port\""
  eval "export ${var_prefix}DBNAME=\"\$dbname\""
  eval "export ${var_prefix}QUERY=\"\$query\""
  eval "export ${var_prefix}URI=\"\$clean_uri\""
}

find-up () {
  path=${2-$PWD}
  while [[ "$path" != "" && ! -e "$path/$1" ]]; do
    path=${path%/*}
  done
  echo "$path"
}

if [[ -z $DC_ORO_APPDIR ]]; then
  export DC_ORO_APPDIR=$(find-up composer.json "$PWD/www")
fi

if [[ -z $DC_ORO_APPDIR ]]; then
  if [ -z "$(ls -A "$PWD")" ]; then
    export DC_ORO_APPDIR="$PWD"
  else
    echo -e "\033[38;5;208m==> Application root folder not found, and current directory is not empty, terminating...\033[0m"
    exit 1
  fi
fi

if [[ ! -d "$DC_ORO_APPDIR" ]]; then
  mkdir -p "$DC_ORO_APPDIR"
fi

if [[ -z $DC_ORO_COMPOSER_AUTH ]] && [[ -z $COMPOSER_AUTH ]]; then
  cd "${DC_ORO_CONFIG_DIR}"
  if which php > /dev/null 2>&1 && which composer > /dev/null 2>&1; then
    COMPOSER_HOME=$(php -d display_startup_errors=0 $(which composer) config --working-dir=/tmp --no-interaction --global home 2> /dev/null) || {
      msg_info "Can't find Composer home. Try setting COMPOSER_AUTH manually."
    }
  fi

  if [[ -n ${COMPOSER_HOME} ]] && [[ -f "${COMPOSER_HOME}/auth.json" ]]; then
    DC_ORO_COMPOSER_AUTH=$(cat "${COMPOSER_HOME}/auth.json")
  fi
fi

cd "$DC_ORO_APPDIR"

load_env_safe "$DC_ORO_APPDIR/.env"
load_env_safe "$DC_ORO_APPDIR/.env-app"
load_env_safe "$DC_ORO_APPDIR/.env-app.local"
load_env_safe "$DC_ORO_APPDIR/.env.orodc"

parse_dsn_uri "$ORO_DB_URL" "database" "DC_ORO"
export DC_ORO_DATABASE_USER=${DC_ORO_DATABASE_USER:-app}
export DC_ORO_DATABASE_PASSWORD=${DC_ORO_DATABASE_PASSWORD:-app}

parse_dsn_uri "$ORO_SEARCH_URL" "search" "DC_ORO"
parse_dsn_uri "$ORO_MQ_DSN" "mq" "DC_ORO"
parse_dsn_uri "$ORO_REDIS_URL" "redis" "DC_ORO"

if [[ -n "$ORO_SEARCH_URL" ]] && echo "$ORO_SEARCH_URL" | grep 'orm:' > /dev/null; then
  export DC_ORO_SEARCH_DSN=
else
  export DC_ORO_SEARCH_DSN=$ORO_SEARCH_URL
fi

export DC_ORO_PORT_PREFIX=${DC_ORO_PORT_PREFIX:-"301"}

# Use batch port resolution for better performance
BATCH_PORTS=$(orodc-find_free_port --batch ${DC_ORO_NAME} $DC_ORO_CONFIG_DIR \
  nginx "${DC_ORO_PORT_PREFIX}80" \
  xhgui "${DC_ORO_PORT_PREFIX}81" \
  database "${DC_ORO_PORT_PREFIX}06" \
  database "${DC_ORO_PORT_PREFIX}32" \
  search "${DC_ORO_PORT_PREFIX}92" \
  mq "${DC_ORO_PORT_PREFIX}72" \
  redis "${DC_ORO_PORT_PREFIX}79" \
  mail "${DC_ORO_PORT_PREFIX}25" \
  ssh "${DC_ORO_PORT_PREFIX}22")

# Parse batch results and export individual port variables
while IFS=':' read -r service port; do
  case "$service" in
    nginx)
      export DC_ORO_PORT_NGINX="$port"
      ;;
    xhgui)
      export DC_ORO_PORT_XHGUI="$port"
      ;;
    database)
      if [[ -z "$DC_ORO_PORT_MYSQL" ]]; then
        export DC_ORO_PORT_MYSQL="$port"
      else
        export DC_ORO_PORT_PGSQL="$port"
      fi
      ;;
    search)
      export DC_ORO_PORT_SEARCH="$port"
      ;;
    mq)
      export DC_ORO_PORT_MQ="$port"
      ;;
    redis)
      export DC_ORO_PORT_REDIS="$port"
      ;;
    mail)
      export DC_ORO_PORT_MAIL_WEBGUI="$port"
      ;;
    ssh)
      export DC_ORO_PORT_SSH="$port"
      ;;
  esac
done <<< "$BATCH_PORTS"

export COMPOSER_AUTH=$(echo ${DC_ORO_COMPOSER_AUTH:-${COMPOSER_AUTH}} | jq -c .)
export DC_ORO_COMPOSER_AUTH=${COMPOSER_AUTH}

if ${DOCKER_BIN} system info --format '{{.SecurityOptions}}' 2>/dev/null | grep "name=rootless" > /dev/null 2>&1; then
  # Use root user in the rootless mode
  export DC_ORO_USER_NAME="root"
  export DC_ORO_USER_GROUP="root"
  export DC_ORO_USER_UID=0
  export DC_ORO_USER_GID=0
else
  export DC_ORO_USER_NAME="developer"
  export DC_ORO_USER_GROUP="developer"
  export DC_ORO_USER_UID=$UID
  export DC_ORO_USER_GID=$GID
fi

export DC_ORO_PHP_USER_NAME=${DC_ORO_USER_NAME}
export DC_ORO_PHP_USER_GROUP=${DC_ORO_USER_GROUP}
export DC_ORO_PHP_USER_UID=${DC_ORO_USER_UID}
export DC_ORO_PHP_USER_GID=${DC_ORO_USER_GID}

NETWORK_NAME="dc_shared_net"
# Check if the Docker network already exists
if ! docker network ls --format '{{.Name}}' | grep -qw "$NETWORK_NAME"; then
  msg_info "Creating Docker network: $NETWORK_NAME"
  docker network create "$NETWORK_NAME"
else
  # Docker network already exists - skip message
  true
fi

if [[ -z $DC_ORO_MODE ]] && [[ "$OSTYPE" == "darwin"* ]]; then
  export DC_ORO_MODE="mutagen"
elif [[ -z $DC_ORO_MODE ]]; then
  export DC_ORO_MODE="default"
fi

if [[ -z ${ORO_SSH_PUBLIC_KEY} ]]; then
  if [[ ! -e "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519" ]]; then
    ssh-keygen -t ed25519 -f "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519" -N "" -q
    chmod 0600 "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519"
  fi
  
  export ORO_SSH_PUBLIC_KEY=$(cat "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519.pub")
fi

if [[ "${DC_ORO_MODE}" == "default" ]] && [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-default.yml" ]]; then
  DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-default.yml"
fi

if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]];then
  export DC_ORO_DATABASE_PORT=${DC_ORO_DATABASE_PORT:-5432}
  DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-pgsql.yml"
elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
  export DC_ORO_DATABASE_PORT=${DC_ORO_DATABASE_PORT:-3306}
  DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-mysql.yml"
fi
if ${DOCKER_COMPOSE_BIN_CMD} ps --services 2>/dev/null | grep database > /dev/null; then
  SERVICE_DATABASE_ID=$(${DOCKER_COMPOSE_BIN_CMD} ps -q database)
  if [[ "" != $SERVICE_DATABASE_ID ]] && ${DOCKER_BIN} inspect -f '{{ .Config.Image }}' "$SERVICE_DATABASE_ID" | grep 'busybox'; then
    ${DOCKER_COMPOSE_BIN_CMD} stop database
    ${DOCKER_COMPOSE_BIN_CMD} rm -f database
  fi
fi

if [[ -f "$DC_ORO_APPDIR/.docker-compose.user.yml" ]]; then
  msg_info "Additional ${DOCKER_BIN} compose config will be used: $DC_ORO_APPDIR/.docker-compose.user.yml"
  DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN_CMD} -f $DC_ORO_APPDIR/.docker-compose.user.yml"
fi

# Auto-detect PHP version from composer.json
detect_php_version_from_composer() {
  if [[ -f "$DC_ORO_APPDIR/composer.json" ]]; then
    # Try direct PHP requirement first
    local php_constraint=$(jq -r '.require.php // empty' "$DC_ORO_APPDIR/composer.json" 2>/dev/null)
    if [[ -n "$php_constraint" ]]; then
      # Extract version from constraint (e.g., "^8.1" -> "8.1", ">=8.2" -> "8.2")
      local php_version=$(echo "$php_constraint" | sed -E 's/[^0-9.]*([0-9]+\.[0-9]+).*/\1/')
      if [[ "$php_version" =~ ^[0-9]+\.[0-9]+$ ]]; then
        echo "$php_version"
        return 0
      fi
    fi
    
    # Fallback: detect from Oro Platform version
    local oro_platform=$(jq -r '.require["oro/platform"] // empty' "$DC_ORO_APPDIR/composer.json" 2>/dev/null)
    if [[ -n "$oro_platform" ]]; then
      # Extract full Oro version (e.g., "6.0.8", "^6.1.0" -> "6.1.0")
      local oro_version=$(echo "$oro_platform" | sed -E 's/[^0-9.]*([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
      # If no patch version found, try major.minor
      if [[ ! "$oro_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        oro_version=$(echo "$oro_platform" | sed -E 's/[^0-9.]*([0-9]+\.[0-9]+).*/\1/')
      fi
      
      # Convert to comparable format and determine PHP version
      local major=$(echo "$oro_version" | cut -d. -f1)
      local minor=$(echo "$oro_version" | cut -d. -f2)
      local patch=$(echo "$oro_version" | cut -d. -f3 2>/dev/null || echo "0")
      
      # Version comparison logic
      if [[ $major -eq 6 && $minor -eq 0 ]]; then
        echo "8.3" && return 0  # Oro 6.0.x uses PHP 8.3
      elif [[ $major -eq 6 && $minor -ge 1 ]] || [[ $major -gt 6 ]]; then
        echo "8.4" && return 0  # Oro 6.1+ uses PHP 8.4
      elif [[ $major -eq 5 && $minor -eq 1 ]]; then
        echo "8.1" && return 0
      elif [[ $major -eq 5 && $minor -eq 0 ]]; then
        echo "8.1" && return 0
      elif [[ $major -eq 4 && $minor -eq 2 ]]; then
        echo "8.1" && return 0
      elif [[ $major -eq 4 && $minor -eq 1 ]]; then
        echo "8.1" && return 0
      elif [[ $major -eq 4 && $minor -eq 0 ]]; then
        echo "7.4" && return 0
      fi
    fi
  fi
  return 1
}


# Get compatible Node.js version for PHP version
get_compatible_node_version() {
  local php_version="$1"
  case "$php_version" in
    "8.4") echo "22" ;;
    "8.3") echo "20" ;;
    "8.2") echo "20" ;;
    "8.1") echo "18" ;;
    "7.4") echo "16" ;;
    *) echo "22" ;;  # Default to Node 22 for unknown PHP versions
  esac
}

# Auto-detect PHP version with fallback chain
if [[ -z $DC_ORO_PHP_VERSION ]]; then
  # Priority 1: .php-version file
  if [[ -f "$DC_ORO_APPDIR/.php-version" ]]; then
    export DC_ORO_PHP_VERSION=$(cat $DC_ORO_APPDIR/.php-version | head -n1)
    msg_info "Found .php-version with following version: $DC_ORO_PHP_VERSION"
  # Priority 2: .phprc file
  elif [[ -f "$DC_ORO_APPDIR/.phprc" ]]; then
    export DC_ORO_PHP_VERSION=$(cat $DC_ORO_APPDIR/.phprc | head -n1)
    msg_info "Found .phprc with following version: $DC_ORO_PHP_VERSION"
  # Priority 3: composer.json
  elif DC_ORO_PHP_VERSION=$(detect_php_version_from_composer); then
    export DC_ORO_PHP_VERSION
    msg_info "Detected PHP version from composer.json: $DC_ORO_PHP_VERSION"
  fi
fi

# Auto-detect Node.js version with fallback chain
if [[ -z $DC_ORO_NODE_VERSION ]]; then
  # Priority 1: .nvmrc file
  if [[ -f "$DC_ORO_APPDIR/.nvmrc" ]]; then
    export DC_ORO_NODE_VERSION=$(cat $DC_ORO_APPDIR/.nvmrc | head -n1)
    msg_info "Found .nvmrc with following version: $DC_ORO_NODE_VERSION"
  # Priority 2: Compatibility matrix based on detected PHP version
  elif [[ -n "$DC_ORO_PHP_VERSION" ]]; then
    export DC_ORO_NODE_VERSION=$(get_compatible_node_version "$DC_ORO_PHP_VERSION")
    msg_info "Using compatible Node.js version for PHP $DC_ORO_PHP_VERSION: $DC_ORO_NODE_VERSION"
  fi
fi

if [[ "${DC_ORO_MODE}" == "mutagen" ]] || [[ "${DC_ORO_MODE}" == "ssh" ]]; then
  if [[ ${args[0]} != "down" ]] && [[ ${args[0]} != "purge" ]]; then
    ${DOCKER_BIN} volume ls | awk '{ print $2 }' | tail +2 | grep '^'${DC_ORO_NAME}'_appcode$' > /dev/null 2>&1 || {
      ${DOCKER_BIN} volume create "${DC_ORO_NAME}_appcode"  > /dev/null
      msg_info "Copying source code to the '${DC_ORO_NAME}_appcode' docker volume"
      bash -c "${DOCKER_COMPOSE_BIN_CMD} up -d ssh"
      SSH_HOST=${DC_ORO_SSH_BIND_HOST:-127.0.0.1}
      SSH_PORT=$(${DOCKER_BIN} inspect $(${DOCKER_COMPOSE_BIN_CMD} ps | grep ssh | awk '{ print $1 }') | jq -r '.[0].NetworkSettings.Ports["22/tcp"][0].HostPort')
      if [[ 0 -eq $(ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o 'ForwardAgent no' -o IdentitiesOnly=yes -i "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519" -p ${SSH_PORT} ${ORO_DC_SSH_ARGS} ${DC_ORO_USER_NAME}@${SSH_HOST} sh -c 'ls "'${DC_ORO_APPDIR}'/"' | wc -l) ]]; then
        until ${RSYNC_BIN} --exclude var/cache --exclude vendor --exclude node_modules --links -e "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o 'ForwardAgent no' -o IdentitiesOnly=yes -i ${DC_ORO_CONFIG_DIR}/ssh_id_ed25519 -p ${SSH_PORT} ${ORO_DC_SSH_ARGS}" --timeout=3 --info=progress2 -r "${DC_ORO_APPDIR}/" ${DC_ORO_USER_NAME}@${SSH_HOST}:"${DC_ORO_APPDIR}/" 2> /dev/null; do
          echo -n ".";
          sleep 3
        done
        echo "";
      fi
    }
  fi
fi

if [[ "${DC_ORO_MODE}" == "mutagen" ]]; then
  MUTAGEN_SESSION_NAME=$(echo ${DC_ORO_NAME}-appcode | awk '{print tolower($0)}' | sed 's/[^0-9a-z]/-/g')
  WAIT_SYNC="1"

  if [[ "$first_non_flag_arg" == "down" ]] || [[ "$first_non_flag_arg" == "purge" ]]; then
    if mutagen sync list | grep -i "Name: ${MUTAGEN_SESSION_NAME}" > /dev/null 2>&1; then
      mutagen sync terminate "${MUTAGEN_SESSION_NAME}"
    fi
    WAIT_SYNC=""
  elif ! echo "$first_non_flag_arg" | grep -i '^\(build\|pull\|config\)' > /dev/null 2>&1; then
    if [[ "0" -eq $(${DOCKER_COMPOSE_BIN_CMD} ps -q ssh  2> /dev/null | wc -l 2> /dev/null) ]]; then
      bash -c "${DOCKER_COMPOSE_BIN_CMD} up -d ssh"
    fi
    DOCKER_CONTAINER_NAME_MUTAGEN=$(${DOCKER_BIN} inspect -f '{{.Name}}' $(bash -c "${DOCKER_COMPOSE_BIN_CMD} ps -q ssh") | cut -c2-)
    if ! mutagen sync list | grep -i "Name: ${MUTAGEN_SESSION_NAME}" > /dev/null 2>&1; then
      mutagen sync create --sync-mode=two-way-resolved \
      --scan-mode=accelerated \
      --watch-mode-alpha=portable \
      --watch-mode-beta=force-poll \
      --watch-polling-interval-beta=30 \
      --ignore=".git" \
      --ignore=".idea" \
      --ignore=".history" \
      --ignore=".mysql.initdb.d" \
      --ignore=".psql.initdb.d" \
      --ignore="var" \
      --ignore-vcs \
      --symlink-mode=ignore \
      --name=${MUTAGEN_SESSION_NAME} \
      "$DC_ORO_APPDIR" docker://${DC_ORO_USER_NAME}@${DOCKER_CONTAINER_NAME_MUTAGEN}${DC_ORO_APPDIR}
    else
      WAIT_SYNC=""
    fi

    if [[ "${WAIT_SYNC}" == "1" ]]; then
      until mutagen sync list "${MUTAGEN_SESSION_NAME}" | grep 'Status:' | grep 'Watching for changes' > /dev/null 2>&1; do
        if which tput > /dev/null 2>&1; then
          tput cuu 1 && tput el
        fi
        mutagen sync list "${MUTAGEN_SESSION_NAME}" | grep 'Status:' | echo $(awk -F: '{ print $2 }')
        sleep 3
      done
    fi
  fi
fi

if [[ ${DOCKER_COMPOSE_VERSION} -gt 1 ]]; then
  DOCKER_COMPOSE_RUN_CMD="${DOCKER_COMPOSE_BIN_CMD} run -i --rm"
else
  DOCKER_COMPOSE_RUN_CMD="${DOCKER_COMPOSE_BIN_CMD} run --rm"
fi

# Function to build docker compose run command with proper flag placement
build_docker_compose_run_cmd() {
  local service="$1"
  local cmd_args=("${@:2}")
  
  if [[ ${#left_flags[@]} -gt 0 ]] || [[ ${#left_options[@]} -gt 0 ]]; then
    # Place docker compose flags before 'run' command
    if [[ ${DOCKER_COMPOSE_VERSION} -gt 1 ]]; then
      echo "${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run -i --rm ${service} ${cmd_args[*]} ${right_flags[*]} ${right_options[*]}"
    else
      echo "${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run --rm ${service} ${cmd_args[*]} ${right_flags[*]} ${right_options[*]}"
    fi
  else
    # Use standard command without parsed flags
    echo "${DOCKER_COMPOSE_RUN_CMD} ${service} ${cmd_args[*]}"
  fi
}

# Function to check if a container is running
is_container_running() {
  local service="$1"
  local container_id
  
  # Get container ID for the service
  container_id=$(${DOCKER_COMPOSE_BIN_CMD} ps -q "$service" 2>/dev/null)
  
  # Check if container exists and is running
  if [[ -n "$container_id" ]] && ${DOCKER_BIN} inspect -f '{{.State.Running}}' "$container_id" 2>/dev/null | grep -q "true"; then
    return 0
  else
    return 1
  fi
}

# Function to execute command in container (use ssh if available, otherwise cli)
execute_in_container() {
  local service="$1"
  local cmd_args=("${@:2}")
  
  # Handle external PHP files for exec vs run scenarios
  local external_files=()
  local updated_cmd_args=()
  
  # Collect external PHP files from command arguments
  for arg in "${cmd_args[@]}"; do
    if [[ $arg == *.php ]]; then
      PHPFILE_PATH=$(echo $arg | grep -oE '.+\.php' | sed s~.\*=~~)
      PHPFILE_DIR=$(dirname "${PHPFILE_PATH}")
      
      # Check if file is outside project directory
      if [[ -z $DC_ORO_APPDIR ]] || [[ $PHPFILE_DIR != '.' && $PHPFILE_DIR != $DC_ORO_APPDIR && $PHPFILE_DIR != $DC_ORO_APPDIR/* ]]; then
        # Check if file exists locally
        if [[ -f "${PHPFILE_PATH}" ]]; then
          external_files+=("${PHPFILE_PATH}")
        fi
      fi
    fi
    updated_cmd_args+=("$arg")
  done
  
  # For CLI commands, prefer SSH container if it's running (much faster)
  if [[ "$service" == "cli" ]] && is_container_running "ssh"; then
    # Handle external files for SSH exec - copy to shared volume
    if [[ ${#external_files[@]} -gt 0 ]]; then
      for file in "${external_files[@]}"; do
        filename=$(basename "$file")
        # Copy external file to shared-private volume via SSH container
        if docker cp "$file" "${DC_ORO_NAME}_ssh_${DC_ORO_PHP_VERSION:-8.4}-${DC_ORO_NODE_VERSION:-22}-${DC_ORO_COMPOSER_VERSION:-2}:/private/$filename" 2>/dev/null; then
          if [ "$DEBUG" ]; then echo "DEBUG: Copied external file $file to /private/$filename" >&2; fi
          # Update command arguments to use shared volume path
          for i in "${!updated_cmd_args[@]}"; do
            if [[ "${updated_cmd_args[$i]}" == "$file" ]]; then
              updated_cmd_args[$i]="/private/$filename"
              break
            fi
          done
        else
          if [ "$DEBUG" ]; then echo "DEBUG: Failed to copy $file to SSH container, falling back to CLI run" >&2; fi
          # Fall back to CLI run with volume mount
          exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} run -i --rm -v "$(dirname "$file"):$(dirname "$file"):ro" "$service" "${cmd_args[@]}" "${right_flags[@]}" "${right_options[@]}"
        fi
      done
    fi
    
    if [ "$DEBUG" ]; then echo "DEBUG: Using SSH container for faster execution instead of CLI" >&2; fi
    exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} exec "ssh" "${updated_cmd_args[@]}" "${right_flags[@]}" "${right_options[@]}"
  elif is_container_running "$service"; then
    # Container is running, use exec for faster execution
    if [ "$DEBUG" ]; then echo "DEBUG: Using docker compose exec for service: $service" >&2; fi
    exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} exec "$service" "${updated_cmd_args[@]}" "${right_flags[@]}" "${right_options[@]}"
  else
    # Container is not running, use docker compose run with volume mounts for external files
    local run_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run -i --rm"
    
    # Add volume mounts for external files
    if [[ ${#external_files[@]} -gt 0 ]]; then
      for file in "${external_files[@]}"; do
        file_dir=$(dirname "${file}")
        run_cmd="$run_cmd -v ${file_dir}:${file_dir}:ro"
        if [ "$DEBUG" ]; then echo "DEBUG: Adding volume mount for external file: -v ${file_dir}:${file_dir}:ro" >&2; fi
      done
    fi
    
    run_cmd="$run_cmd $service"
    
    # Start the service in background first
    ${DOCKER_COMPOSE_BIN_CMD} up -d "$service" >/dev/null 2>&1
    
    # Wait a moment for the service to be ready
    sleep 1
    
    # Verify it's now running, if so use exec, otherwise use run
    if is_container_running "$service"; then
      if [ "$DEBUG" ]; then echo "DEBUG: Service $service started, using exec" >&2; fi
      exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} exec "$service" "${updated_cmd_args[@]}" "${right_flags[@]}" "${right_options[@]}"
    else
      # Fallback to run if start failed
      if [ "$DEBUG" ]; then echo "DEBUG: Failed to start service $service, using run with volume mounts" >&2; fi
      exec bash -c "$run_cmd ${cmd_args[*]} ${right_flags[*]} ${right_options[*]}"
    fi
  fi
}

if ${DOCKER_BIN} system info --format '{{.SecurityOptions}}' 2>/dev/null | grep "name=rootless" > /dev/null; then
  DOCKER_COMPOSE_RUN_CMD="${DOCKER_COMPOSE_RUN_CMD} --user root"
fi

# External PHP files are now handled in execute_in_container() function

# Load cached profiles for all commands except 'up' (which saves new profiles)
if [[ "$first_non_flag_arg" != "up" ]]; then
  load_cached_profiles
fi

if [[ "$first_non_flag_arg" == "up" ]]; then
  # Save profiles for future commands
  save_profiles
  
  
  printf "\033[0;37m[${DC_ORO_NAME}] Application: http://localhost:${DC_ORO_PORT_NGINX}\033[0m\n"
  printf "\033[0;37m[${DC_ORO_NAME}] Mailhog: http://localhost:${DC_ORO_PORT_MAIL_WEBGUI}\033[0m\n"
  printf "\033[0;37m[${DC_ORO_NAME}] Elasticsearch: http://localhost:${DC_ORO_PORT_SEARCH}\033[0m\n"
  printf "\033[0;37m[${DC_ORO_NAME}] Mq: http://localhost:${DC_ORO_PORT_MQ}\033[0m\n"
  
  if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pdo_pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]];then
    printf "\033[0;37m[${DC_ORO_NAME}] Database: 127.0.0.1:${DC_ORO_PORT_PGSQL}\033[0m\n"
  elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "pdo_mysql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
    printf "\033[0;37m[${DC_ORO_NAME}] Database: 127.0.0.1:${DC_ORO_PORT_MYSQL}\033[0m\n"
  fi

  printf "\033[0;37m[${DC_ORO_NAME}] SSH: 127.0.0.1:${DC_ORO_PORT_SSH}\033[0m\n"
fi


if echo "$first_non_flag_arg" | grep -i 'import' | grep -i 'db\|database' > /dev/null 2>&1 || false; then
  if [[ -z ${args[1]} ]]; then
    >&2 echo "Data file was not provided"
    exit 1
  fi
  if [[ -r ${args[1]} ]]; then
    DB_DUMP=$(realpath ${args[1]})
  elif [[ -r "$DC_ORO_APPDIR/${args[1]}" ]]; then
    DB_DUMP=$(realpath "$DC_ORO_APPDIR/${args[1]}")
  fi

  if [[ -z "$DB_DUMP" ]] || [[ ! -r "$DB_DUMP" ]]; then
    >&2 echo "Data file '${args[1]}' does not readable"
    exit 1
  fi

  DB_DUMP_BASENAME=$(echo "${DB_DUMP##*/}")
  if [[ $DC_ORO_DATABASE_SCHEMA == "pdo_pgsql" ]] || [[ $DC_ORO_DATABASE_SCHEMA == "postgres" ]];then
    DB_IMPORT_CMD="sed -E 's/[Oo][Ww][Nn][Ee][Rr]:[[:space:]]*[a-zA-Z0-9_]+/Owner: '\$DC_ORO_DATABASE_USER'/g' | sed -E 's/[Oo][Ww][Nn][Ee][Rr][[:space:]]+[Tt][Oo][[:space:]]+[a-zA-Z0-9_]+/OWNER TO '\$DC_ORO_DATABASE_USER'/g' | sed -E '/^[[:space:]]*[Rr][Ee][Vv][Oo][Kk][Ee][[:space:]]+[Aa][Ll][Ll]/d' | sed -e '/SET transaction_timeout = 0;/d' | sed -E '/^\\\\restrict|^\\\\unrestrict/d' | PGPASSWORD=\$DC_ORO_DATABASE_PASSWORD psql --set ON_ERROR_STOP=on -h \$DC_ORO_DATABASE_HOST -p \$DC_ORO_DATABASE_PORT -U \$DC_ORO_DATABASE_USER -d \$DC_ORO_DATABASE_DBNAME -1 >/dev/null"
  elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "pdo_mysql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
    DB_IMPORT_CMD="sed -E 's/[Dd][Ee][Ff][Ii][Nn][Ee][Rr][ ]*=[ ]*[^*]*\*/DEFINER=CURRENT_USER \*/' | MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME"
  fi

  if echo ${DB_DUMP_BASENAME} | grep -i 'sql\.gz$' > /dev/null; then
    DB_IMPORT_CMD="zcat ${DB_DUMP_BASENAME} | sed -E 's/^[[:space:]]*[Cc][Rr][Ee][Aa][Tt][Ee][[:space:]]+[Ff][Uu][Nn][Cc][Tt][Ii][Oo][Nn]/CREATE OR REPLACE FUNCTION/g' | ${DB_IMPORT_CMD}"
  else
    DB_IMPORT_CMD="cat /${DB_DUMP_BASENAME} | sed -E 's/^[[:space:]]*[Cc][Rr][Ee][Aa][Tt][Ee][[:space:]]+[Ff][Uu][Nn][Cc][Tt][Ii][Oo][Nn]/CREATE OR REPLACE FUNCTION/g' | ${DB_IMPORT_CMD}"
  fi

  >&2 echo "/* Starting import of the database dump... */"
  >&2 echo "/* From: $DB_DUMP */"

  exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} run -i --rm -v "${DB_DUMP}:/${DB_DUMP_BASENAME}" database-cli bash -c "$DB_IMPORT_CMD"
  exit 0
fi

if echo ${args[0]} | grep -i 'set\|update' | grep -i 'url\|uri' > /dev/null; then
  URL=${args[1]:-"https://${DC_ORO_NAME}.docker.local"}
  set -x
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:update oro_website.secure_url ${URL}" || true
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:update oro_ui.application_url ${URL}" || true
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console oro:config:update oro_website.url ${URL}" || true
  exit 0
fi

if [[ "$first_non_flag_arg" == "cache" ]]; then
  # Use second argument as cache subcommand, default to 'clear'
  cache_cmd="${args[1]:-clear}"
  
  set -x
  if [[ "$NEEDS_ARG_PARSING" == "true" ]]; then
    cache_cmd_exec=$(build_docker_compose_run_cmd "cli" "php" "./bin/console" "cache:${cache_cmd}" "${args[@]:2}")
    exec bash -c "$cache_cmd_exec"
  else
    exec ${DOCKER_COMPOSE_RUN_CMD} cli php ./bin/console cache:${cache_cmd} "${args[@]:2}"
  fi
fi

# Handle cache:subcommand syntax (e.g., cache:clear, cache:warmup)
if echo "$first_non_flag_arg" | grep -i '^cache:' > /dev/null; then
  # Extract cache subcommand (everything after 'cache:')
  cache_cmd="${first_non_flag_arg#cache:}"
  
  set -x
  if [[ "$NEEDS_ARG_PARSING" == "true" ]]; then
    exec ${DOCKER_COMPOSE_RUN_CMD} ${left_flags[@]} ${left_options[@]} cli php ./bin/console cache:${cache_cmd} "${args[@]:1}" "${right_flags[@]}" "${right_options[@]}"
  else
    exec ${DOCKER_COMPOSE_RUN_CMD} cli php ./bin/console cache:${cache_cmd} "${args[@]:1}"
  fi
fi

if echo "$first_non_flag_arg" | grep -i 'update' | grep -i 'platform' > /dev/null; then
  set -x
  if [[ "$NEEDS_ARG_PARSING" == "true" ]]; then
    exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} run -i --rm cli bash -c "rm -rf var/cache/* || true; php bin/console oro:platform:update --force"
  else
    exec ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "rm -rf var/cache/* || true; php bin/console oro:platform:update --force"
  fi
fi

if [[ "$first_non_flag_arg" == "platform" && "${args[1]}" == "update" ]]; then
  set -x
  if [[ "$NEEDS_ARG_PARSING" == "true" ]]; then
    exec ${DOCKER_COMPOSE_RUN_CMD} ${left_flags[@]} ${left_options[@]} cli php ./bin/console oro:platform:update --force "${args[@]:2}" "${right_flags[@]}" "${right_options[@]}"
  else
    exec ${DOCKER_COMPOSE_RUN_CMD} cli php ./bin/console oro:platform:update --force "${args[@]:2}"
  fi
fi

if echo ${args[0]} | grep -i 'composer' | grep -i 'install' > /dev/null; then
  URL=${args[1]:-"https://${DC_ORO_NAME}.docker.local"}
  set -x
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "composer install" || true
  exit 0
fi

if echo "$first_non_flag_arg" | grep -i 'export\|dump' | grep -i 'db\|database' > /dev/null; then
  DB_DUMP=$DC_ORO_APPDIR/database-$(date +'%Y%m%d%H%M%S').sql.gz
  DB_DUMP_BASENAME=$(echo "${DB_DUMP##*/}")
  touch "${DB_DUMP}"
  if [[ $DC_ORO_DATABASE_SCHEMA == "pgsql" ]] || [[ $DC_ORO_DATABASE_SCHEMA == "postgres" ]] || [[ $DC_ORO_DATABASE_SCHEMA == "postgresql" ]]; then
    DB_EXPORT_CMD="PGPASSWORD=\$DC_ORO_DATABASE_PASSWORD pg_dump -Fp --clean --if-exists -h \$DC_ORO_DATABASE_HOST -p \$DC_ORO_DATABASE_PORT -U \$DC_ORO_DATABASE_USER -d \$DC_ORO_DATABASE_DBNAME"
  elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
    DB_EXPORT_CMD="MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysqldump --no-tablespaces --column-statistics=0 --set-gtid-purged=OFF --quick --max-allowed-packet=16M --disable-keys --hex-blob --no-autocommit --insert-ignore --skip-lock-tables --single-transaction -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME | sed -E 's/[Dd][Ee][Ff][Ii][Nn][Ee][Rr][ ]*=[ ]*[^*]*\*/DEFINER=CURRENT_USER \*/'"
  fi

  >&2 echo "/* Starting export of the database... */"
  >&2 echo "/* Dumping database to: $DB_DUMP */"
  exec bash -c "${DOCKER_COMPOSE_RUN_CMD} ${left_flags[@]} ${left_options[@]} -v \"${DB_DUMP}:/${DB_DUMP_BASENAME}\" database-cli bash -c \"$DB_EXPORT_CMD | gzip > /${DB_DUMP_BASENAME}\""
fi



# Check if command is a special OroDC command (not PHP, not Docker Compose)
is_orodc_special_command() {
  local cmd="$1"
  case "$cmd" in
    psql|mysql|database-cli|ssh|cli|install|purge|help|man|tests|test|bash)
      return 0
      ;;
    # Database import/export commands
    importdb|exportdb|databaseimport|databaseexport|dbimport|dbexport)
      return 0
      ;;
    # Platform update commands
    platformupdate|updateplatform)
      return 0
      ;;
    *)
      # Check pattern-based commands
      if echo "$cmd" | grep -qi 'import.*\(db\|database\)'; then return 0; fi
      if echo "$cmd" | grep -qi '\(export\|dump\).*\(db\|database\)'; then return 0; fi
      if echo "$cmd" | grep -qi '\(db\|database\).*\(import\|export\)'; then return 0; fi
      if echo "$cmd" | grep -qi 'update.*platform\|platform.*update'; then return 0; fi
      if echo "$cmd" | grep -qi '^cache:'; then return 0; fi
      if echo "$cmd" | grep -qi '\(set\|update\).*\(url\|uri\)'; then return 0; fi
      if echo "$cmd" | grep -qi 'composer.*install'; then return 0; fi
      return 1
      ;;
  esac
}

# Handle PHP flags (redirect to PHP CLI when appropriate)
# Only redirect with bash -c for implicit PHP commands (flags only, no command)
# For explicit 'php' command, use direct exec for interactive mode
if [[ "$first_non_flag_arg" == "php" ]]; then
  # Explicit php command - use direct exec for interactive mode
  php_only_args=()
  for arg in "${args[@]}"; do
    if [[ "$arg" != "php" ]]; then
      php_only_args+=("$arg")
    fi
  done
  php_args=("${left_flags[@]}" "${left_options[@]}" "${php_only_args[@]}" "${right_flags[@]}" "${right_options[@]}")
  if [ "$DEBUG" ]; then echo "DEBUG: Direct PHP exec with args: ${php_args[*]}" >&2; fi
  execute_in_container "cli" "php" "${php_args[@]}"
elif [[ -z "$first_non_flag_arg" ]] && ([[ ${#left_flags[@]} -gt 0 ]] || [[ ${#right_flags[@]} -gt 0 ]] || [[ ${#right_options[@]} -gt 0 ]]); then
  # Only flags, no command - this is implicit PHP (orodc -v, orodc --version)
  # Setup logging for PHP binary usage
  setup_php_logging "$@"
  php_args=("${left_flags[@]}" "${left_options[@]}" "${args[@]}" "${right_flags[@]}" "${right_options[@]}")
  if [ "$DEBUG" ]; then echo "DEBUG: Implicit PHP redirect with args: ${php_args[*]}" >&2; fi
  execute_in_container "cli" "php" "${php_args[@]}"
fi

if echo "$first_non_flag_arg" | grep -i '^mysql' > /dev/null; then
  # Extract mysql arguments (everything after 'mysql')
  mysql_args=("${args[@]:1}")
  exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} run -i --rm -e MYSQL_PWD="$DC_ORO_DATABASE_PASSWORD" database-cli mysql -h"$DC_ORO_DATABASE_HOST" -P"$DC_ORO_DATABASE_PORT" -u"$DC_ORO_DATABASE_USER" "$DC_ORO_DATABASE_DBNAME" "${mysql_args[@]}"
fi

if echo "$first_non_flag_arg" | grep -i '^psql' > /dev/null; then
  # Extract psql arguments (everything after 'psql')
  psql_args=("${args[@]:1}")
  exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} run -i --rm -e PGPASSWORD="$DC_ORO_DATABASE_PASSWORD" database-cli psql -h "$DC_ORO_DATABASE_HOST" -p "$DC_ORO_DATABASE_PORT" -U "$DC_ORO_DATABASE_USER" -d "$DC_ORO_DATABASE_DBNAME" "${psql_args[@]}"
fi

if echo "$first_non_flag_arg" | grep -i '^database-cli' > /dev/null; then
  # Extract database-cli arguments (everything after 'database-cli')
  database_cli_args=("${args[@]:1}")
  # If no arguments provided, default to bash
  if [[ ${#database_cli_args[@]} -eq 0 ]]; then
    database_cli_args=("bash")
  fi
  exec ${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} run -i --rm -e PGPASSWORD="$DC_ORO_DATABASE_PASSWORD" database-cli "${database_cli_args[@]}"
fi

if [ $# -eq 0 ] || [ "${args[0]}" = "ssh" ]; then
  SSH_HOST=${DC_ORO_SSH_BIND_HOST:-127.0.0.1}
  SSH_PORT=$(${DOCKER_BIN} inspect "$(${DOCKER_COMPOSE_BIN_CMD} ps | grep ssh | awk '{ print $1 }')" | jq -r '.[0].NetworkSettings.Ports["22/tcp"][0].HostPort')

  set -x
  exec ssh \
    -o SendEnv=COMPOSER_AUTH \
    -o UserKnownHostsFile=/dev/null \
    -o StrictHostKeyChecking=no \
    -o 'ForwardAgent no' \
    -o IdentitiesOnly=yes \
    -i "${DC_ORO_CONFIG_DIR}/ssh_id_ed25519" \
    -p "${SSH_PORT}" \
    ${ORO_DC_SSH_ARGS} \
    "${DC_ORO_USER_NAME}@${SSH_HOST}" \
    "${args[@]:1}" \
    "${right_flags[@]}" \
    "${right_options[@]}"
fi

# Function to check if command is a built-in docker compose command
is_docker_compose_command() {
  local cmd="$1"
  # Get list of docker compose commands dynamically
  local compose_commands
  compose_commands=$(${DOCKER_COMPOSE_BIN} --help 2>/dev/null | grep -A 100 "Commands:" | grep "^  [a-z]" | awk '{print $1}' | tr '\n' '|')
  compose_commands="${compose_commands%|}" # remove trailing |
  
  # Check if command matches any docker compose command
  echo "$cmd" | grep -qE "^(${compose_commands})$"
}

# Function moved earlier to avoid "command not found" error

is_special_orodc_command() {
  local cmd="$1"
  case "$cmd" in
    ssh|cli|pgsql|psql|mysql|database-cli|install|purge|test|tests|bash|help|man)
      return 0
      ;;
    *)
      # Check complex patterns that are handled specially
      if echo "$cmd" | grep -qi 'import.*\(db\|database\)'; then return 0; fi
      if echo "$cmd" | grep -qi '\(set\|update\).*\(url\|uri\)'; then return 0; fi
      if echo "$cmd" | grep -qi '^cache'; then return 0; fi
      if [[ "$cmd" == "platform" ]]; then return 0; fi
      if echo "$cmd" | grep -qi 'composer.*install'; then return 0; fi
      if echo "$cmd" | grep -qi '\(export\|dump\).*\(db\|database\)'; then return 0; fi
      return 1
      ;;
  esac
}


# Check if any argument is a docker compose command (will be handled at the end)
is_docker_compose_cmd=false
if [[ ${#args[@]} -gt 0 ]]; then
  for arg in "${args[@]}"; do
    if is_docker_compose_command "$arg"; then
      is_docker_compose_cmd=true
      break
    fi
  done
fi
if [[ -n "${DEBUG:-}" ]]; then
  echo "DEBUG: is_docker_compose_cmd=$is_docker_compose_cmd, args=${args[*]:-none}" >&2
  echo "DEBUG: args[0]=${args[0]:-empty}, args length=${#args[@]}" >&2
fi


# Mount external PHP files will be called after DOCKER_COMPOSE_RUN_CMD is defined

if [[ "$is_docker_compose_cmd" != "true" ]]; then
  # Check if any argument contains a .php file
  has_php_file=false
  for arg in "${args[@]}" "${right_flags[@]}" "${right_options[@]}"; do
    if [[ "$arg" == *.php ]]; then
      has_php_file=true
      break
    fi
  done

# If arguments contain .php file, redirect to PHP
if [[ "$has_php_file" == true ]]; then
  # Special handling for bash -c commands with PHP files
  if [[ "${args[0]}" == "bash" && "${right_flags[0]}" == "-c" ]]; then
    # For bash -c 'php script.php', reconstruct proper argument order
    exec ${DOCKER_COMPOSE_RUN_CLI_CMD} ${left_flags[@]} ${left_options[@]} cli bash -c "${args[@]:1}" "${right_options[@]}"
  else
    # Prepend 'php' to the command if not already present
    if [[ "${args[0]}" != "php" ]]; then
      # For PHP files, treat left_flags as PHP flags (not docker compose flags)
      # Only use actual docker compose flags from left_flags
      docker_flags=()
      php_flags=()
      for flag in "${left_flags[@]}"; do
        case "$flag" in
          -d|-e|--env|--env-file|--label|--name|--user|--workdir|--entrypoint|--platform)
            docker_flags+=("$flag")
            ;;
          *)
            php_flags+=("$flag")
            ;;
        esac
      done
      execute_in_container "cli" "php" "${php_flags[@]}" "${right_flags[@]}" "${right_options[@]}" "${args[@]}"
    else
      execute_in_container "cli" "${args[@]}" "${right_flags[@]}" "${right_options[@]}"
    fi
  fi
fi
fi

# If command is not a docker compose built-in command and not a special orodc command, redirect to CLI container
if [[ -n "${DEBUG:-}" ]]; then
  echo "DEBUG: Checking special commands: args[0]='${args[0]}', first_non_flag_arg='$first_non_flag_arg'" >&2
fi

if [[ ${#args[@]} -gt 0 ]] && [[ "$is_docker_compose_cmd" != "true" ]] && ! is_special_orodc_command "$first_non_flag_arg"; then
  echo "Running command in 'cli' service..."
  # Special handling for bash -c commands
  if [[ "${args[0]}" == "bash" && "${right_flags[0]}" == "-c" ]]; then
    # For bash -c 'command', reconstruct proper argument order
    exec ${DOCKER_COMPOSE_RUN_CMD} ${left_flags[@]} ${left_options[@]} cli bash -c "${args[@]:1}" "${right_options[@]}"
  else
    # Pass arguments directly to docker compose exec without additional escaping
    # Combine args with right_flags and right_options in proper order
    cli_cmd=$(build_docker_compose_run_cmd "cli" "${args[@]}")
    exec bash -c "$cli_cmd"
  fi
fi

if echo ${args[0]} | grep -i '^cli$' > /dev/null; then
  exec bash -c "${DOCKER_COMPOSE_RUN_CMD} ${left_flags[@]} ${left_options[@]} cli"
fi

if echo ${args[0]} | grep -i '^install' | grep -i 'without' | grep -i 'demo' > /dev/null; then
  msg_info "Starting OroPlatform installation without demo data..."
  export XDEBUG_MODE=off
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "[[ -d ${DC_ORO_APPDIR}/var/cache ]] && rm -rf ${DC_ORO_APPDIR}/var/cache/* || true"
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "composer install"
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console --env=prod --timeout=1800 oro:install --language=en --formatting-code=en_US --organization-name='Acme Inc.' --user-name=admin --user-email=admin@example.com --user-firstname=John --user-lastname=Doe --user-password='\$ecretPassw0rd' --application-url='https://${DC_ORO_NAME:-unnamed}.docker.local/' --sample-data=n"
  exit 0
elif echo ${args[0]} | grep -i '^install$' > /dev/null; then
  msg_info "Starting OroPlatform installation with sample data..."
  export XDEBUG_MODE=off
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "[[ -d ${DC_ORO_APPDIR}/var/cache ]] && rm -rf ${DC_ORO_APPDIR}/var/cache/* || true"
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "composer install"
  ${DOCKER_COMPOSE_RUN_CMD} cli bash -c "php bin/console --env=prod --timeout=1800 oro:install --language=en --formatting-code=en_US --organization-name='Acme Inc.' --user-name=admin --user-email=admin@example.com --user-firstname=John --user-lastname=Doe --user-password='\$ecretPassw0rd' --application-url='https://${DC_ORO_NAME:-unnamed}.docker.local/' --sample-data=y"
  exit 0
fi

# Handle tests commands - unified entry point
if [[ "$first_non_flag_arg" == "tests" ]]; then
  # CRITICAL COMPOSE MERGING LOGIC - READ CAREFULLY BEFORE MODIFYING
  # =================================================================
  # 
  # PROBLEM: Test services in docker-compose-test.yml reference volumes (like 'appcode') 
  # that are defined in the main docker-compose.yml. Simply using docker-compose-test.yml 
  # alone causes "undefined volume" errors.
  #
  # SOLUTION: We must merge ALL compose files into a single compose.yml that contains:
  # 1. Base services and volumes from docker-compose.yml
  # 2. Database-specific services from docker-compose-{pgsql|mysql}.yml
  # 3. User customizations from .docker-compose.user.yml (if exists)
  # 4. Test services from docker-compose-test.yml
  #
  # WHY USE DOCKER_COMPOSE_BIN_CMD: This variable already contains the properly constructed
  # command with all base compose files in the correct order. We reuse this logic instead
  # of duplicating the file selection logic.
  #
  # WHY GENERATE compose.yml: The 'down' and 'purge' commands need to know about test 
  # services to stop them properly. By creating a merged compose.yml, these commands
  # can find and stop test containers even after the test session ends.
  
  # Reuse existing compose command logic and add test file
  # DOCKER_COMPOSE_BIN_CMD already contains: base + database + user compose files
  TEST_AWARE_COMPOSE_CMD="${DOCKER_COMPOSE_BIN_CMD}"
  if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-test.yml" ]]; then
    TEST_AWARE_COMPOSE_CMD="${TEST_AWARE_COMPOSE_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-test.yml"
  fi
  
  # Generate properly merged compose.yml using 'docker compose config'
  # This command merges all compose files and resolves all references (volumes, networks, etc.)
  if DC_ORO_NAME="$DC_ORO_NAME" bash -c "${TEST_AWARE_COMPOSE_CMD} config" > "${DC_ORO_CONFIG_DIR}/compose.yml" 2>/dev/null; then
    msg_info "All services merged into compose.yml for persistent management"
  else
    msg_warning "Failed to merge compose files, falling back to test-only mode"
    # Fallback: create basic merged file (this will likely cause volume errors)
    # This fallback exists for edge cases but is not the intended path
    cat > "${DC_ORO_CONFIG_DIR}/compose.yml" << 'EOF'
# Auto-generated merged compose file including test services
# This ensures test services are included in down/purge operations
# WARNING: This fallback may cause "undefined volume" errors
EOF
    if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-test.yml" ]]; then
      cat "${DC_ORO_CONFIG_DIR}/docker-compose-test.yml" >> "${DC_ORO_CONFIG_DIR}/compose.yml"
    fi
  fi
  
  # Build test-aware compose command using the merged compose.yml
  # IMPORTANT: We use the merged compose.yml file instead of multiple -f flags
  # because it already contains all services and resolved volume references
  TEST_COMPOSE_CMD="${DOCKER_COMPOSE_BIN} -f ${DC_ORO_CONFIG_DIR}/compose.yml"
  
  # Use test-cli container for test commands
  CLI_SERVICE="test-cli"
  
  # Define test-specific variables with fallbacks to main variables
  DC_ORO_TEST_DATABASE_HOST="${DC_ORO_TEST_DATABASE_HOST:-${DC_ORO_DATABASE_HOST:-database}}"
  DC_ORO_TEST_DATABASE_PORT="${DC_ORO_TEST_DATABASE_PORT:-${DC_ORO_DATABASE_PORT:-5432}}"
  DC_ORO_TEST_DATABASE_USER="${DC_ORO_TEST_DATABASE_USER:-${DC_ORO_DATABASE_USER:-oro_db_user}}"
  DC_ORO_TEST_DATABASE_PASSWORD="${DC_ORO_TEST_DATABASE_PASSWORD:-${DC_ORO_DATABASE_PASSWORD:-oro_db_pass}}"
  DC_ORO_TEST_DATABASE_DBNAME="${DC_ORO_TEST_DATABASE_DBNAME:-${DC_ORO_DATABASE_DBNAME:-oro_db}_test}"
  
  # Create test database URI using parse_dsn_uri function
  TEST_DB_URI="postgres://${DC_ORO_TEST_DATABASE_USER}:${DC_ORO_TEST_DATABASE_PASSWORD}@${DC_ORO_TEST_DATABASE_HOST}:${DC_ORO_TEST_DATABASE_PORT}/${DC_ORO_TEST_DATABASE_DBNAME}"
  parse_dsn_uri "$TEST_DB_URI" "database" "DC_ORO_TEST"
  # Function creates DC_ORO_TEST_DATABASE_URI automatically
  
  # Handle different test subcommands
  case "${args[1]}" in
    "install"|"setup")
      msg_info "Installing test environment and database..."
      # Start all required services
      ${TEST_COMPOSE_CMD} up -d >/dev/null 2>&1
      
      
      # Check if test database already exists
      DB_EXISTS=false
      if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]]; then
        # Check PostgreSQL database existence
        if ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=\$DC_ORO_DATABASE_PASSWORD psql -h \$DC_ORO_DATABASE_HOST -p \$DC_ORO_DATABASE_PORT -U \$DC_ORO_DATABASE_USER -d \$DC_ORO_DATABASE_DBNAME -c 'SELECT 1 FROM pg_database WHERE datname = '\''${DC_ORO_TEST_DATABASE_DBNAME}'\'';'" 2>/dev/null | grep -q "1 row"; then
          DB_EXISTS=true
        fi
      elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]]; then
        # Check MySQL/MariaDB database existence
        if ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME -e 'SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '\''${DC_ORO_TEST_DATABASE_DBNAME}'\'';'" 2>/dev/null | grep -q "${DC_ORO_TEST_DATABASE_DBNAME}"; then
          DB_EXISTS=true
        fi
      fi
      
      if [[ "$DB_EXISTS" == "true" ]]; then
        echo "Test database ${DC_ORO_TEST_DATABASE_DBNAME} already exists, skipping database setup..."
      else
        echo "Creating test database ${DC_ORO_TEST_DATABASE_DBNAME}..."
        if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]]; then
          # PostgreSQL commands using test-specific environment variables
          ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=${DC_ORO_TEST_DATABASE_PASSWORD} psql -h ${DC_ORO_TEST_DATABASE_HOST} -p ${DC_ORO_TEST_DATABASE_PORT} -U ${DC_ORO_TEST_DATABASE_USER} -d \$DC_ORO_DATABASE_DBNAME -c 'SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '\''${DC_ORO_TEST_DATABASE_DBNAME}'\'';'" 2>/dev/null || true
          ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=${DC_ORO_TEST_DATABASE_PASSWORD} psql -h ${DC_ORO_TEST_DATABASE_HOST} -p ${DC_ORO_TEST_DATABASE_PORT} -U ${DC_ORO_TEST_DATABASE_USER} -d \$DC_ORO_DATABASE_DBNAME -c 'DROP DATABASE IF EXISTS ${DC_ORO_TEST_DATABASE_DBNAME};'" 2>/dev/null || true
          ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=${DC_ORO_TEST_DATABASE_PASSWORD} psql -h ${DC_ORO_TEST_DATABASE_HOST} -p ${DC_ORO_TEST_DATABASE_PORT} -U ${DC_ORO_TEST_DATABASE_USER} -d \$DC_ORO_DATABASE_DBNAME -c 'CREATE DATABASE ${DC_ORO_TEST_DATABASE_DBNAME};'" || {
            echo "Failed to create test database"
            exit 1
          }
        elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]]; then
          # MySQL/MariaDB commands using environment variables like existing mysql command
          ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME -e 'DROP DATABASE IF EXISTS ${DC_ORO_TEST_DATABASE_DBNAME};'" 2>/dev/null || true
          ${TEST_COMPOSE_CMD} run --rm database-cli bash -c "MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME -e 'CREATE DATABASE ${DC_ORO_TEST_DATABASE_DBNAME};'" || {
            echo "Failed to create test database"
            exit 1
          }
        fi
      fi
      
      # Clear test cache and install (only if database was created)
      if [[ "$DB_EXISTS" == "false" ]]; then
        msg_info "Setting up Oro test environment..."
        echo "Running cache clear in 'test-cli' service..."
        ${TEST_COMPOSE_CMD} run --rm test-cli bash -c "rm -rf var/cache/test" 2>/dev/null || true
        echo "Running oro:install in 'test-cli' service..."
        # Run oro:install in background and monitor output for consumer messages
        ${TEST_COMPOSE_CMD} run --rm test-cli bin/console oro:install --disabled-listeners=all 2>&1 | while IFS= read -r line; do
          echo "$line"
          if [[ "$line" == *"Processing consumer messages"* ]]; then
            echo "==> Detected consumer message processing, stopping test-consumer..."
            # Wait for consumer processes to start
            for i in {1..10}; do
              if ${TEST_COMPOSE_CMD} exec -T test-cli bash -c "ps aux | grep 'oro:message-queue:consume' | grep -v grep >/dev/null 2>&1"; then
                echo "Consumer processes found, stopping them..."
                ${TEST_COMPOSE_CMD} exec -T test-cli bash -c "pids=\$(ps aux | grep 'oro:message-queue:consume' | grep -v grep | awk '{print \$2}'); [ -n \"\$pids\" ] && echo \$pids | xargs kill -9" 2>/dev/null || true
                break
              fi
              echo "Waiting for consumer processes to start... ($i/10)"
              sleep 0.5
            done
          fi
        done
      else
        echo "Oro test environment already installed, skipping oro:install..."
      fi
      
      # Warm up test environment caches
      msg_info "Warming up test environment caches..."
      echo "Warming up test cache..."
      ${TEST_COMPOSE_CMD} run --rm test-cli bin/console cache:warmup --env=test 2>/dev/null || true

      # Generate behat.yml with correct URLs for test environment
      msg_info "Generating behat.yml with test environment URLs..."
      BEHAT_DIST_FILE="${DC_ORO_APPDIR}/vendor/oro/platform/src/Oro/Bundle/TestFrameworkBundle/Resources/config/behat.yml.dist"
      BEHAT_CONFIG_FILE="${DC_ORO_APPDIR}/behat.yml"
      
      if [[ -f "$BEHAT_DIST_FILE" ]]; then
        # Copy behat.yml.dist and replace URLs with sed for test environment
        cp "$BEHAT_DIST_FILE" "$BEHAT_CONFIG_FILE"
        
        # Replace localhost:4444 with test-selenium:4444 for WebDriver host
        sed -i '' "s|localhost:4444|test-selenium:4444|g" "$BEHAT_CONFIG_FILE" 2>/dev/null || sed -i "s|localhost:4444|test-selenium:4444|g" "$BEHAT_CONFIG_FILE"
        # Replace localhost:9515 with test-selenium:9515 for ChromeDriver host  
        sed -i '' "s|localhost:9515|test-selenium:9515|g" "$BEHAT_CONFIG_FILE" 2>/dev/null || sed -i "s|localhost:9515|test-selenium:9515|g" "$BEHAT_CONFIG_FILE"
        
        # Note: OroCommerce admin panel is accessible at root path, not /admin/
        echo "Keeping base_url as root path for admin panel access"
        
        # Add necessary Chrome arguments for Docker environment to the main sessions (port 4444)
        # This fixes the "DevToolsActivePort file doesn't exist" error
        if grep -q -- '--load-extension.*chrome-extension' "$BEHAT_CONFIG_FILE"; then
          # Create temporary file with the Chrome arguments to add
          TEMP_CHROME_ARGS=$(mktemp)
          cat > "$TEMP_CHROME_ARGS" << 'EOF'
                                        - "--no-sandbox"
                                        - "--disable-gpu"
                                        - "--headless"
                                        - "--disable-dev-shm-usage"
                                        - "--no-first-run"
                                        - "--disable-extensions"
                                        - "--disable-renderer-backgrounding"
EOF
          
          # Use awk to insert the Chrome arguments after the line containing chrome-extension
          awk '
            /--load-extension.*chrome-extension/ {
              print $0
              while ((getline line < "'"$TEMP_CHROME_ARGS"'") > 0) print line
              close("'"$TEMP_CHROME_ARGS"'")
              next
            }
            { print }
          ' "$BEHAT_CONFIG_FILE" > "${BEHAT_CONFIG_FILE}.tmp" && mv "${BEHAT_CONFIG_FILE}.tmp" "$BEHAT_CONFIG_FILE"
          
          # Clean up temporary file
          rm -f "$TEMP_CHROME_ARGS"
        fi
        
        echo "Generated behat.yml with test environment URLs and Docker-compatible Chrome options"
      else
        echo "Warning: behat.yml.dist not found, skipping behat.yml generation"
      fi
      
      # Start test services including test-consumer
      ${TEST_COMPOSE_CMD} up -d test-fpm test-nginx test-selenium test-consumer
      echo "Test environment setup completed!"
      exit 0
      ;;
      
    "purge"|"destroy")
      echo "Purging test environment..."
      
      # Build compose command without test file to get list of test services
      MAIN_COMPOSE_CMD="${DOCKER_COMPOSE_BIN} -f ${DC_ORO_CONFIG_DIR}/docker-compose.yml"
      
      # Add database-specific compose file
      if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]];then
        MAIN_COMPOSE_CMD="${MAIN_COMPOSE_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-pgsql.yml"
      elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]];then
        MAIN_COMPOSE_CMD="${MAIN_COMPOSE_CMD} -f ${DC_ORO_CONFIG_DIR}/docker-compose-mysql.yml"
      fi
      
      # Add user compose file if exists
      if [[ -f "$DC_ORO_APPDIR/.docker-compose.user.yml" ]]; then
        MAIN_COMPOSE_CMD="${MAIN_COMPOSE_CMD} -f $DC_ORO_APPDIR/.docker-compose.user.yml"
      fi
      
      # Get test services from docker-compose-test.yml using yq
      if [[ -f "${DC_ORO_CONFIG_DIR}/docker-compose-test.yml" ]]; then
        TEST_SERVICES=$(yq e '.services | keys | .[]' "${DC_ORO_CONFIG_DIR}/docker-compose-test.yml" 2>/dev/null | tr '\n' ' ')
        if [[ -n "$TEST_SERVICES" ]]; then
          echo "Stopping test services: $TEST_SERVICES"
          ${TEST_COMPOSE_CMD} stop $TEST_SERVICES 2>/dev/null || true
          ${TEST_COMPOSE_CMD} rm -f $TEST_SERVICES 2>/dev/null || true
        fi
      fi
      
      # Drop test database using the same approach as existing database commands
      # Test database name = main database name + _test suffix
      echo "Dropping test database ${DC_ORO_TEST_DATABASE_DBNAME}..."
      
      if [[ "${DC_ORO_DATABASE_SCHEMA}" == "pgsql" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgres" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "postgresql" ]]; then
        # PostgreSQL commands using test-specific environment variables
        ${MAIN_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=${DC_ORO_TEST_DATABASE_PASSWORD} psql -h ${DC_ORO_TEST_DATABASE_HOST} -p ${DC_ORO_TEST_DATABASE_PORT} -U ${DC_ORO_TEST_DATABASE_USER} -d \$DC_ORO_DATABASE_DBNAME -c 'SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '\''${DC_ORO_TEST_DATABASE_DBNAME}'\'';'" 2>/dev/null || true
        ${MAIN_COMPOSE_CMD} run --rm database-cli bash -c "PGPASSWORD=${DC_ORO_TEST_DATABASE_PASSWORD} psql -h ${DC_ORO_TEST_DATABASE_HOST} -p ${DC_ORO_TEST_DATABASE_PORT} -U ${DC_ORO_TEST_DATABASE_USER} -d \$DC_ORO_DATABASE_DBNAME -c 'DROP DATABASE ${DC_ORO_TEST_DATABASE_DBNAME};'" 2>/dev/null || true
      elif [[ "${DC_ORO_DATABASE_SCHEMA}" == "mariadb" ]] || [[ "${DC_ORO_DATABASE_SCHEMA}" == "mysql" ]]; then
        # MySQL/MariaDB commands using environment variables like existing mysql command
        ${MAIN_COMPOSE_CMD} run --rm database-cli bash -c "MYSQL_PWD=\$DC_ORO_DATABASE_PASSWORD mysql -h\$DC_ORO_DATABASE_HOST -P\$DC_ORO_DATABASE_PORT -u\$DC_ORO_DATABASE_USER \$DC_ORO_DATABASE_DBNAME -e 'DROP DATABASE IF EXISTS ${DC_ORO_TEST_DATABASE_DBNAME};'" 2>/dev/null || true
      fi
      
      # Remove merged compose.yml to restore original configuration
      # IMPORTANT: This cleanup prevents the merged compose.yml from interfering 
      # with normal operations. The merged file should only exist during test sessions.
      rm -f "${DC_ORO_CONFIG_DIR}/compose.yml" 2>/dev/null || true
      echo "Test environment destroyed!"
      exit 0
      ;;
      
    "status")
      echo "Test environment status:"
      ${TEST_COMPOSE_CMD} ps test-fpm test-nginx test-selenium
      echo ""
      echo "Test application: Available in Docker network (test-nginx)"
      echo "Selenium WebDriver: Available in Docker network (test-selenium:4444)"
      exit 0
      ;;
      
    "consumer-stop")
      echo "Stopping test consumer (SIGSTOP)..."
      ${TEST_COMPOSE_CMD} exec test-cli bash -c "pids=\$(pgrep -f 'oro:message-queue:consume'); [ -n \"\$pids\" ] && echo \$pids | xargs kill -STOP" 2>/dev/null || echo "Consumer process not found or already stopped"
      exit 0
      ;;
      
    "consumer-start")
      echo "Starting test consumer (SIGCONT)..."
      ${TEST_COMPOSE_CMD} exec test-cli bash -c "pids=\$(pgrep -f 'oro:message-queue:consume'); [ -n \"\$pids\" ] && echo \$pids | xargs kill -CONT" 2>/dev/null || echo "Consumer process not found"
      exit 0
      ;;
      
    "consumer-kill")
      echo "Killing test consumer (SIGKILL)..."
      ${TEST_COMPOSE_CMD} exec test-cli bash -c "pids=\$(pgrep -f 'oro:message-queue:consume'); [ -n \"\$pids\" ] && echo \$pids | xargs kill -9" 2>/dev/null || echo "Consumer process not found"
      exit 0
      ;;
      
    "consumer-status")
      echo "Test consumer status:"
      ${TEST_COMPOSE_CMD} exec test-cli bash -c "ps aux | grep -v grep | grep 'oro:message-queue:consume' || echo 'Consumer process not running'"
      exit 0
      ;;
      
    *)
      # Handle any other command by executing it in test-cli container
      # This makes 'orodc tests' a full replacement for 'orodc' but in test environment
      msg_info "Running command in 'test-cli' service..."
      ${TEST_COMPOSE_CMD} up -d >/dev/null 2>&1
      
      # For tests command, use arguments after 'tests' without parsing
      # Skip 'tests' (first argument) and use everything else as-is
      test_command_args=("${args[@]:1}")
      exec ${TEST_COMPOSE_CMD} run --rm test-cli "${test_command_args[@]}"
      ;;
  esac
  exit 0
fi

if [[ -n "${DEBUG:-}" ]]; then
  echo "DEBUG: Checking purge condition: first_non_flag_arg='$first_non_flag_arg'" >&2
fi

if [[ "$first_non_flag_arg" == "purge" ]]; then
  # Handle purge command with proper flag processing
  if [[ -n "${DEBUG:-}" ]]; then
    echo "DEBUG: Processing purge command with flags: ${left_flags[@]} ${left_options[@]}" >&2
  fi
  
  if [[ -f "${DC_ORO_CONFIG_DIR}/compose.yml" ]]; then
    bash -c "${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} -f ${DC_ORO_CONFIG_DIR}/compose.yml down -v"
  else
    bash -c "${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} down -v"
  fi

  ${DOCKER_BIN} volume ls | awk '{ print $2 }' | tail +2 | grep '^'${DC_ORO_NAME}'_appcode$' > /dev/null && {
    echo "Removing docker volume: ${DC_ORO_NAME}_appcode"
    ${DOCKER_BIN} volume rm ${DC_ORO_NAME}'_appcode'
  }

  if [[ -d "${DC_ORO_CONFIG_DIR}" ]]; then
    rm -rf "${DC_ORO_CONFIG_DIR}"
  fi

  exit 0
fi

if [[ "$first_non_flag_arg" == "down" ]] && [[ -f "${DC_ORO_CONFIG_DIR}/compose.yml" ]] && [[ -s "${DC_ORO_CONFIG_DIR}/compose.yml" ]]; then
  DOCKER_COMPOSE_BIN_CMD="${DOCKER_COMPOSE_BIN} -f ${DC_ORO_CONFIG_DIR}/compose.yml"
  # Combine all arguments into a single string for proper execution
  full_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} ${args[*]} ${right_flags[*]} ${right_options[*]}"
  exec bash -c "$full_cmd"
fi

# Handle docker compose commands with all variables set
if [[ "$is_docker_compose_cmd" == "true" ]]; then
  # Generate config file only if it doesn't exist or if it's a management command (up, down, purge, etc.)
  if [[ ! -f "${DC_ORO_CONFIG_DIR}/compose.yml" ]] || [[ "${args[0]}" =~ ^(up|down|purge|build|pull|push|restart|start|stop|kill|rm|create)$ ]]; then
    DC_ORO_NAME="$DC_ORO_NAME" bash -c "${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} config" > "${DC_ORO_CONFIG_DIR}/compose.yml" 2>/dev/null || true
  fi
  # For docker compose commands, proper order is: command flags services
  # Extract command (first element) and services (rest of elements)
  docker_cmd="${args[0]}"
  docker_services="${args[*]:1}"
  full_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} ${docker_cmd} ${right_flags[*]} ${right_options[*]} ${docker_services}"
  DC_ORO_NAME="$DC_ORO_NAME" exec bash -c "$full_cmd"
fi

# Handle bash commands by running them in CLI container
if [[ "$first_non_flag_arg" == "bash" ]]; then
  # Generate config file only if it doesn't exist
  if [[ ! -f "${DC_ORO_CONFIG_DIR}/compose.yml" ]]; then
    DC_ORO_NAME="$DC_ORO_NAME" bash -c "${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} config" > "${DC_ORO_CONFIG_DIR}/compose.yml" 2>/dev/null || true
  fi
  
  # For bash commands, use docker compose run with cli container
  # Pass all arguments after "bash" to the bash command in the container
  bash_args=("${args[@]:1}")
  
  # Build the run command with proper argument handling
  if [[ ${#bash_args[@]} -gt 0 ]]; then
    # If there are arguments after bash, pass them through
    full_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run --rm cli bash ${bash_args[*]} ${right_flags[*]} ${right_options[*]}"
  else
    # If no arguments after bash, just run interactive bash
    full_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} run --rm cli bash ${right_flags[*]} ${right_options[*]}"
  fi
  
  DC_ORO_NAME="$DC_ORO_NAME" exec bash -c "$full_cmd"
fi

# Generate config file only if it doesn't exist or if it's a management command (up, down, purge, etc.)
if [[ ! -f "${DC_ORO_CONFIG_DIR}/compose.yml" ]] || [[ "${args[0]}" =~ ^(up|down|purge|build|pull|push|restart|start|stop|kill|rm|create)$ ]]; then
  DC_ORO_NAME="$DC_ORO_NAME" bash -c "${DOCKER_COMPOSE_BIN_CMD} ${left_flags[@]} ${left_options[@]} config" > "${DC_ORO_CONFIG_DIR}/compose.yml" 2>/dev/null || true
fi
# Combine all arguments into a single string for proper execution  
full_cmd="${DOCKER_COMPOSE_BIN_CMD} ${left_flags[*]} ${left_options[*]} ${args[*]} ${right_flags[*]} ${right_options[*]}"


DC_ORO_NAME="$DC_ORO_NAME" exec bash -c "$full_cmd"
